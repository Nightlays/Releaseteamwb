
<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Regress Dashboard ‚Äî –î–∞—à–±–æ—Ä–¥ + –†–ê–ù-–æ—Ç—á—ë—Ç</title>

<!-- Chart.js -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<!-- ExcelJS (–Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –Ω–∞–ø—Ä—è–º—É—é, –æ—Å—Ç–∞–≤–ª—è—é –∫–∞–∫ –±—ã–ª–æ) -->
<script src="https://cdn.jsdelivr.net/npm/exceljs@4.4.0/dist/exceljs.min.js"></script>
<!-- SheetJS (Excel) -->
<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
<!-- XlsxPopulate (—Å—Ç–∏–ª–∏ Excel –≤ –±—Ä–∞—É–∑–µ—Ä–µ) -->
<script src="https://unpkg.com/xlsx-populate/browser/xlsx-populate.min.js"></script>


<!-- INLINE FILTERS OVERRIDE: keep controls on one line -->

  <link rel="stylesheet" href="dashboard_run.css">
</head>

<body class="authed">


<div class="wrap">
  <h1>–û—Å—Ç–∞—Ç–æ–∫ –∫–µ–π—Å–æ–≤ –Ω–∞ —Ä–µ–≥—Ä–µ—Å—Å</h1>

 <div class="tabs">
  <button id="tabDashBtn" class="active">–î–∞—à–±–æ—Ä–¥</button>
  <button id="tabRunBtn">–†–ê–ù-–æ—Ç—á—ë—Ç</button>
</div>

  <!-- ======= –ü–ê–ù–ï–õ–¨ –ü–ê–†–ê–ú–ï–¢–†–û–í ======= -->
  <div class="panel card" style="grid-template-columns:repeat(12,minmax(0,1fr));">
    <div class="field" style="grid-column:span 3"><label>Base URL</label><input id="baseUrl" placeholder="https://allure-testops.wb.ru"></div>
    <div class="field" style="grid-column:span 2"><label>Project ID</label><input id="projectId" placeholder="7"></div>
    <div class="field" style="grid-column:span 2"><label>–í–µ—Ä—Å–∏—è (–ø—Ä–∏–º–µ—Ä: 7.2.6)</label><input id="version" placeholder="7.2.6"></div>
    <div class="field" style="grid-column:span 3"><label>API —Ç–æ–∫–µ–Ω</label><input id="token" placeholder="–≤—Å—Ç–∞–≤—å—Ç–µ —Ç–æ–∫–µ–Ω"></div>
    <div style="grid-column:span 4;display:flex;gap:8px;align-items:end;flex-wrap:wrap">
      <button id="runBtn" class="btn primary">–ó–∞–ø—É—Å—Ç–∏—Ç—å</button>
      <button id="saveSettingsBtn" class="btn">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏</button>
    </div>

    <div style="grid-column:span 12;display:flex;flex-wrap:wrap;gap:8px;align-items:end">
      <button id="dataPick" class="btn">–ü–æ–¥–∫–ª—é—á–∏—Ç—å —Ñ–∞–π–ª –¥–∞–Ω–Ω—ã—Ö</button>
      <button id="dataCreate" class="btn">–°–æ–∑–¥–∞—Ç—å —Ñ–∞–π–ª –¥–∞–Ω–Ω—ã—Ö</button>
      <button id="dataSave" class="btn success" disabled>–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –≤ —Ñ–∞–π–ª</button>

      <input id="dataImport" type="file" accept="application/json" style="display:none">
      <button id="dataImportBtn" class="btn">–ò–º–ø–æ—Ä—Ç JSON</button>
      <button id="dataExportBtn" class="btn">–≠–∫—Å–ø–æ—Ä—Ç JSON</button>
      <button id="dataExportCsv" class="btn">–≠–∫—Å–ø–æ—Ä—Ç CSV (—Å—Ä–µ–∑—ã)</button>

      <div class="auto" style="margin-left:auto;display:grid;grid-auto-flow:column;gap:10px;align-items:center">
        <div class="nums" id="autoState">–ê–≤—Ç–æ–∑–∞–ø—É—Å–∫: –≤—ã–∫–ª—é—á–µ–Ω</div>
        <div class="field" style="display:grid;grid-template-columns:auto"><label>–ò–Ω—Ç–µ—Ä–≤–∞–ª (–º–∏–Ω)</label><input id="autoMins" value="20"></div>
        <button id="autoStart" class="btn success">–°—Ç–∞—Ä—Ç</button>
        <button id="autoStop" class="btn danger" disabled>–°—Ç–æ–ø</button>
      </div>
    </div>
  </div>

  <!-- ====================== –î–ê–®–ë–û–†–î ====================== -->
  <div id="tabDash" class="tab-section">
    <!-- –ì–æ—Ç–æ–≤–Ω–æ—Å—Ç—å –∫ —Ä–µ–ª–∏–∑—É (Android + iOS) -->
    <div class="card" id="releaseWrap" style="margin-bottom:16px">
      <div class="head">
        <div>–ì–æ—Ç–æ–≤–Ω–æ—Å—Ç—å –∫ —Ä–µ–ª–∏–∑—É</div>
        <div class="nums" id="releaseHeadVer">–í–µ—Ä—Å–∏—è: ‚Äî</div>
      </div>
      <div class="release-row" id="releaseRow"></div>
    </div>

    <!-- –ú–∏–Ω–∏-–¥–∏–∞–≥—Ä–∞–º–º—ã –ø–æ –ª–∞—É–Ω—á–∞–º -->
    <div class="card" id="miniLaunchCard" style="margin-bottom:16px">
      <div class="head">
        <div>–ú–∏–Ω–∏-–¥–∏–∞–≥—Ä–∞–º–º—ã –ø–æ –ª–∞—É–Ω—á–∞–º</div>

        <div class="export" style="display:flex;gap:6px;align-items:center;flex-wrap:wrap">
          <button id="miniToggleBtn" class="mini">–ü–æ–∫–∞–∑–∞—Ç—å</button>

          <label class="nums">–ü–æ–∫–∞–∑–∞—Ç—å</label>
          <input id="miniCount" class="mini" type="number" value="150" min="1" max="300" style="width:70px">

          <label class="nums">–°–æ—Ä—Ç</label>
          <select id="miniSortKey" class="mini">
            <option value="pct" selected>% –ø—Ä–æ–π–¥–µ–Ω–æ</option>
            <option value="finished">–ü—Ä–æ–π–¥–µ–Ω–æ (—à—Ç)</option>
            <option value="total">–í—Å–µ–≥–æ (—à—Ç)</option>
            <option value="created">–°–≤–µ–∂–µ—Å—Ç—å</option>
          </select>
          <select id="miniSortDir" class="mini">
            <option value="desc" selected>DESC</option>
            <option value="asc">ASC</option>
          </select>

          <label class="nums">–û—Ç–¥–µ–ª</label>
          <select id="miniDept" class="mini">
            <option value="all" selected>–í—Å–µ</option>
            <option value="–ö–æ—Ä–∑–∏–Ω–∞">–ö–æ—Ä–∑–∏–Ω–∞</option>
            <option value="–§–∏–Ω—Ç–µ—Ö">–§–∏–Ω—Ç–µ—Ö</option>
            <option value="–ß–∞—Ç—ã">–ß–∞—Ç—ã</option>
            <option value="–í–•">–í–•</option>
            <option value="–û—Å—Ç–∞–ª—å–Ω—ã–µ">–û—Å—Ç–∞–ª—å–Ω—ã–µ</option>
          </select>

          <!-- —Ñ–∏–ª—å—Ç—Ä –ø–æ –ø–ª–∞—Ç—Ñ–æ—Ä–º–µ -->
          <label class="nums">–ü–ª–∞—Ç—Ñ–æ—Ä–º–∞</label>
          <select id="miniPlatform" class="mini">
            <option value="all" selected>–í—Å–µ</option>
            <option value="android">Android</option>
            <option value="ios">iOS</option>
          </select>
        </div>
      </div>
      <div id="miniWrap" style="display:none">
        <div class="nums" id="miniInfo">‚Äî</div>
        <div class="mini-grid" id="miniGrid"></div>
      </div>
    </div>

    <!-- –°–≤–æ–¥–Ω—ã–π –±–∞—Ä—á–∞—Ä—Ç -->
    <div class="card">
      <div class="head">
        <div>–°–≤–æ–¥–Ω—ã–π –±–∞—Ä—á–∞—Ä—Ç</div>
        <div class="export">
          <button id="expBarPng" class="mini">PNG</button>
          <button id="expBarSvg" class="mini">SVG</button>
          <button id="expAggCsv" class="mini">CSV</button>
          <button id="expAggJson" class="mini">JSON</button>
        </div>
      </div>
      <div id="chartFiltersWrap" style="margin:8px 0 -4px; padding:6px 10px; background:rgba(255,255,255,.6); border:1px solid #eee; border-radius:10px; display:flex; flex-wrap:wrap; gap:14px; align-items:center;">
        <div>
          <span style="font-weight:600;color:#444;margin-right:6px;">–ü–ª–∞—Ç—Ñ–æ—Ä–º–∞:</span>
          <label style="display:inline-flex;align-items:center;gap:6px;margin-right:10px;"><input type="checkbox" id="fltPlatIOS" checked> iOS</label>
          <label style="display:inline-flex;align-items:center;gap:6px;margin-right:10px;"><input type="checkbox" id="fltPlatAndroid" checked> Android</label>
        </div>
        <div>
          <span style="font-weight:600;color:#444;margin:0 6px 0 2px;">–¢–∏–ø:</span>
          <label style="display:inline-flex;align-items:center;gap:6px;margin-right:10px;"><input type="checkbox" id="fltTypeSmoke" checked> Smoke</label>
          <label style="display:inline-flex;align-items:center;gap:6px;margin-right:10px;"><input type="checkbox" id="fltTypeSelective" checked> Selective</label>
          <label style="display:inline-flex;align-items:center;gap:6px;margin-right:10px;"><input type="checkbox" id="fltTypeHB" checked> High/Blocker</label>
        </div>
        <div style="margin-left:auto; display:flex; gap:8px;">
          <button type="button" id="fltAll"  class="mini" style="padding:6px 12px;">–í—Å–µ</button>
          <button type="button" id="fltNone" class="mini" style="padding:6px 12px;">–°–±—Ä–æ—Å</button>
        </div>
      </div>
    
      <div class="nums" id="summaryInfo">‚Äî</div>
      <div class="chart-wrap"><canvas id="barAll" class="chart"></canvas></div>
    </div>

    <div class="grid" id="cards"></div>

    <div class="split">
      <div class="card">
        <div class="head">
          <div>–õ–æ–≥</div>
          <div class="nums" id="logInfo">‚Äî</div>
        </div>

        <div id="logProgressWrap" style="margin:4px 0 8px 0">
          <div class="nums" id="logProgressCaption"></div>
          <div class="progress"><div id="logProgressBar"></div></div>
        </div>

        <div class="log" id="log"></div>
      </div>

      <div class="card">
        <div class="head">
          <div>–ê–ª–ª–µ—Ä—Ç –ø–æ –ª–∞—É–Ω—á–∞–º</div>
          <div class="export">
            <label class="nums">–§–∏–ª—å—Ç—Ä:</label>
            <select id="alertFilter" class="mini">
              <option value="all" selected>–í—Å–µ</option>
              <option value="passed">–ï—Å—Ç—å –ø—Ä–æ–π–¥–µ–Ω–Ω—ã–µ</option>
              <option value="none">–ù–µ—Ç –ø—Ä–æ–π–¥–µ–Ω–Ω—ã—Ö</option>
              <option value="empty">–ë–µ–∑ –∫–µ–π—Å–æ–≤</option>
            </select>
          </div>
        </div>
        <div class="log" id="alertLog">–ü–æ–∫–∞ –∞–ª–ª–µ—Ä—Ç–æ–≤ –Ω–µ—Ç.</div>
      </div>
    </div>

    <!-- ====== –°—Ä–µ–∑—ã: –û–±—â–∏–µ –∏ –ü–æ —Å—Ç—Ä–∏–º—É ====== -->
    <div class="card" style="margin-top:16px">
      <div class="head">
        <div>–°–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã–µ —Å—Ä–µ–∑—ã</div>
        <div class="subtabs">
          <button id="subtabGeneral" class="mini active">–û–±—â–∏–µ</button>
          <button id="subtabStream" class="mini">–ü–æ —Å—Ç—Ä–∏–º—É</button>
        </div>
      </div>

      <!-- === –û–±—â–∏–µ === -->
      <div id="snapGeneralSection">
        <div class="export" style="display:flex;gap:6px;align-items:center;flex-wrap:wrap;margin-bottom:8px">
          <label class="nums">–ú–µ—Ç—Ä–∏–∫–∞</label>
          <select id="dashMetric" class="mini">
            <option value="finished" selected>–ü—Ä–æ–π–¥–µ–Ω–æ</option>
            <option value="total">–í—Å–µ–≥–æ</option>
            <option value="remaining_total">–û—Å—Ç–∞–ª–æ—Å—å</option>
            <option value="remaining">–ù–∞–∑–Ω–∞—á–µ–Ω–æ</option>
            <option value="in_progress">–í –ø—Ä–æ—Ü–µ—Å—Å–µ</option>
          </select>
          <button id="dashSnapSave" class="mini">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Å—Ä–µ–∑</button>
          <button id="dashSnapBuild" class="mini">–ü–æ—Å—Ç—Ä–æ–∏—Ç—å —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ</button>
          <button id="dashSnapClear" class="mini">–û—á–∏—Å—Ç–∏—Ç—å –≤—Å—ë</button>
        </div>
        <div id="snapListDash" class="snap-list"></div>
        <div class="kpis" id="dashDelta" style="margin-top:8px"></div>
        <div class="chart-wrap" style="height:320px"><canvas id="dashPrevCurr" class="chart"></canvas></div>
        <div class="chart-wrap" style="height:320px"><canvas id="dashMultiBar" class="chart"></canvas></div>
      </div>

      <!-- === –ü–æ —Å—Ç—Ä–∏–º—É (Smoke / Selective) === -->
      <div id="snapStreamSection" style="display:none">
        <div class="export" style="display:flex;gap:6px;align-items:center;flex-wrap:wrap;margin-bottom:8px">
          <label class="nums">–°—Ç—Ä–∏–º</label>
          <select id="streamKind" class="mini">
            <option value="Smoke" selected>Smoke</option>
            <option value="Selective">Selective</option>
          </select>
          <label class="nums">–ù–∞–∑–≤–∞–Ω–∏–µ —Å—Ç—Ä–∏–º–∞</label>
<select id="streamName" class="mini">
  <option value="__all__" selected>‚Äî –≤—ã–±–µ—Ä–∏—Ç–µ —Å—Ç—Ä–∏–º ‚Äî</option>
</select>
          <label class="nums">–ú–µ—Ç—Ä–∏–∫–∞</label>
          <select id="dashMetricStream" class="mini">
            <option value="finished" selected>–ü—Ä–æ–π–¥–µ–Ω–æ</option>
            <option value="total">–í—Å–µ–≥–æ</option>
            <option value="remaining_total">–û—Å—Ç–∞–ª–æ—Å—å</option>
            <option value="remaining">–ù–∞–∑–Ω–∞—á–µ–Ω–æ</option>
            <option value="in_progress">–í –ø—Ä–æ—Ü–µ—Å—Å–µ</option>
          </select>
          <button id="dashStreamSnapSave" class="mini">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Å—Ä–µ–∑ (—Å—Ç—Ä–∏–º)</button>
          <button id="dashStreamSnapBuild" class="mini">–ü–æ—Å—Ç—Ä–æ–∏—Ç—å —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ</button>
          <button id="dashStreamSnapClear" class="mini">–û—á–∏—Å—Ç–∏—Ç—å –≤—Å—ë</button>
        </div>
        <div id="snapListDashStream" class="snap-list"></div>
        <div class="kpis" id="dashDeltaStream" style="margin-top:8px"></div>
        <div class="chart-wrap" style="height:320px"><canvas id="dashPrevCurrStream" class="chart"></canvas></div>
        <div class="chart-wrap" style="height:320px"><canvas id="dashMultiBarStream" class="chart"></canvas></div>
      </div>
    </div>
  </div>

  <div class="title">Regress Dashboard by Iliasov D.S n Rusakov A.G</div>

  <!-- ====================== –†–ê–ù-–û–¢–ß–Å–¢ ====================== -->
  <div id="tabRun" style="display:none" class="tab-section">
    <div class="card">
      <div class="head">
        <div>–ó–∞–≥—Ä—É–∑–∫–∞ –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤ (Excel + SWAT.txt) –∏ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã</div>
        <div class="export">
          <button id="runBuildBtn" class="mini">–ü–æ—Å—Ç—Ä–æ–∏—Ç—å</button>
          <button id="runExportCsvBtn" class="mini">–≠–∫—Å–ø–æ—Ä—Ç CSV</button>
          <button id="runExportXlsxBtn" class="mini">–≠–∫—Å–ø–æ—Ä—Ç Excel</button>
        </div>
      </div>

      <div class="panel" style="grid-template-columns:repeat(12,minmax(0,1fr));align-items:end">
        <div class="field" style="grid-column:span 4">
          <label>Excel –æ—Ç—á—ë—Ç (*.xlsx) ‚Äî –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ</label>
          <input id="runExcel" type="file" accept=".xlsx,.xls">
        </div>
        <div class="field" style="grid-column:span 4">
          <label>SWAT.txt (–ª–æ–≥–∏–Ω—ã –ø–æ –æ–¥–Ω–æ–º—É –≤ —Å—Ç—Ä–æ–∫–µ)</label>
          <input id="runSwat" type="file" accept=".txt">
        </div>
        <div class="field" style="grid-column:span 2">
          <label>–¢–û–ü-N (–¥–æ 150)</label>
          <input id="runTopN" type="number" value="50" min="1" max="150">
        </div>
        <div class="field" style="grid-column:span 2">
          <label>–¢–∏–ø –∫–µ–π—Å–æ–≤ (Excel-—Ä–µ–∂–∏–º)</label>
          <select id="runType">
            <option value="all" selected>–í—Å–µ</option>
            <option value="auto">–ê–≤—Ç–æ—Ç–µ—Å—Ç—ã</option>
            <option value="manual">–†—É—á–Ω—ã–µ</option>
          </select>
        </div>
      </div>

      <div class="filters">
        <div class="field" style="grid-column:span 5">
          <label>–§–∏–ª—å—Ç—Ä –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é –†–ê–ù–∞</label>
          <input id="runFilterName" placeholder="–ù–∞–ø—Ä–∏–º–µ—Ä: iOS Smoke">
        </div>
        <div class="field small">
          <label>–û—Ç–¥–µ–ª</label>
          <select id="runFilterDept">
            <option value="all" selected>–í—Å–µ</option>
            <option value="–ö–æ—Ä–∑–∏–Ω–∞">–ö–æ—Ä–∑–∏–Ω–∞</option>
            <option value="–§–∏–Ω—Ç–µ—Ö">–§–∏–Ω—Ç–µ—Ö</option>
            <option value="–ß–∞—Ç—ã">–ß–∞—Ç—ã</option>
            <option value="–í–•">–í–•</option>
            <option value="–û—Å—Ç–∞–ª—å–Ω—ã–µ">–û—Å—Ç–∞–ª—å–Ω—ã–µ</option>
          </select>
        </div>
        <div class="field small">
          <label>–ú–∏–Ω. –∫-–≤–æ –∫–µ–π—Å–æ–≤</label>
          <input id="runFilterMin" type="number" value="0" min="0">
        </div>
        <div class="field small">
          <label>–°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞</label>
          <select id="runSort">
            <option value="total_desc" selected>–ü–æ –∫–µ–π—Å–∞–º ‚Üì</option>
            <option value="auto_desc">–ü–æ –∞–≤—Ç–æ ‚Üì</option>
            <option value="name_asc">–ü–æ –∏–º–µ–Ω–∏ A‚ÜíZ</option>
          </select>
        </div>
        <div class="field" style="grid-column:span 2">
          <label>&nbsp;</label>
          <button id="runFiltersApply" class="btn">–ü—Ä–∏–º–µ–Ω–∏—Ç—å —Ñ–∏–ª—å—Ç—Ä—ã</button>
        </div>
      </div>

      <div class="nums" id="runInfo" style="margin-top:8px">‚Äî</div>
      <div class="progress" style="margin:10px 0"><div id="runProgressBar"></div></div>

      <div class="nums" id="runTotals" style="margin:6px 0 8px 2px">‚Äî</div>

      <div class="chart-wrap" id="runChartWrap" style="height:360px">
        <canvas id="runChart" class="chart"></canvas>
      </div>
    </div>

    <div class="card" style="margin-top:16px">
      <div class="head">
        <div>–¢–∞–±–ª–∏—Ü–∞ (–∫–∞–∫ –≤ Excel / –ø–æ API)</div>
        <div class="nums" id="runLogInfo">‚Äî</div>
      </div>
      <div class="log" id="runLog" style="max-height:240px"></div>
      <div style="overflow:auto;margin-top:10px">
        <table id="runTable"></table>
      </div>
    </div>
  </div>

  </div>

<div id="toast" class="toast"></div>

<script>
(function(){
  /* ===== —É—Ç–∏–ª–∏—Ç—ã DOM/—Å—Ç–∏–ª—è ===== */
  function $(s){ return document.querySelector(s); }
  function $all(s){ return Array.prototype.slice.call(document.querySelectorAll(s)); }
  function toast(msg){ var t=$('#toast'); if(!t) return; t.textContent=msg; t.classList.add('show'); setTimeout(function(){ t.classList.remove('show'); },1600); }
  function getCSS(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }
  function hexA(hex, a){ var c=hex.replace('#',''); var n=parseInt(c,16); var r=(n>>16)&255,g=(n>>8)&255,b=n&255; return 'rgba('+r+','+g+','+b+','+a+')'; }
  function fitHiDPICanvas(canvas){ var dpr=Math.max(1,window.devicePixelRatio||1); var rect=canvas.getBoundingClientRect(); var w=Math.round(rect.width*dpr), h=Math.round(rect.height*dpr); if(canvas.width!==w||canvas.height!==h){ canvas.width=w; canvas.height=h; } }
  function makeCtx(canvas){ fitHiDPICanvas(canvas); return canvas.getContext('2d'); }
  function escapeHtml(str){
    return String(str||'').replace(/[&<>"']/g, s=>({
      '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'
    }[s]));
  }

  /* ===== –≥–ª–æ–±–∞–ª—å–Ω—ã–µ ===== */
  window.__charts={}; window.addEventListener('resize', function(){ for(var k in window.__charts){ if(window.__charts[k].maker) window.__charts[k].maker(); } });

  Chart.defaults.devicePixelRatio=Math.max(1,window.devicePixelRatio||1);
  Chart.defaults.font.family="Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
  Chart.defaults.font.size=13;
  Chart.defaults.color=getComputedStyle(document.documentElement).getPropertyValue('--text').trim()||'#2a1446';
  Chart.defaults.plugins.legend.labels.usePointStyle=true;

  // –ú–∏–Ω–∏-–¥–∏–∞–≥—Ä–∞–º–º—ã: —Ç–µ–∫—É—â–∏–µ –¥–∞–Ω–Ω—ã–µ + –æ–ø—Ü–∏–∏
  window.__mini_last = null;
  const MINI_DEFAULTS = { count: 24, sortKey: 'pct', sortDir: 'desc', dept: 'all', platform: 'all' };

  function readMiniOpts(){
    const count = Math.max(1, Math.min(120, parseInt($('#miniCount')?.value||MINI_DEFAULTS.count,10)||MINI_DEFAULTS.count));
    const sortKey = ($('#miniSortKey')?.value)||MINI_DEFAULTS.sortKey;
    const sortDir = ($('#miniSortDir')?.value)||MINI_DEFAULTS.sortDir;
    const dept = ($('#miniDept')?.value)||MINI_DEFAULTS.dept;
    const platform = ($('#miniPlatform')?.value)||MINI_DEFAULTS.platform;
    return {count, sortKey, sortDir, dept, platform};
  }

  function rebuildMini(){
    if(!window.__mini_last) return;
    const {launches, perLaunchFinished, perLaunchTotal} = window.__mini_last;
    buildMiniLaunchCharts(launches, perLaunchFinished, perLaunchTotal, readMiniOpts());
  }

  /* –¶–µ–Ω—Ç—Ä–æ–≤–æ–π —Ç–µ–∫—Å—Ç –¥–ª—è doughnut */
  const DoughnutCenterText = {
    id: 'doughnutCenterText',
    afterDraw(chart){
      const ds = chart.data.datasets?.[0];
      if(!ds || typeof ds.__pct !== 'number') return;
      const {ctx, chartArea} = chart;
      const x = (chartArea.left + chartArea.right)/2;
      const y = (chartArea.top + chartArea.bottom)/2;
      ctx.save();
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = getCSS('--text');
      ctx.font = '700 16px ' + Chart.defaults.font.family;
      ctx.fillText(ds.__pct + '%', x, y);
      ctx.restore();
    }
  };

  var COLORS={ total:getCSS('--c1'), finished:getCSS('--c2'), remaining_total:getCSS('--c3'), remaining:getCSS('--c3'), in_progress:getCSS('--c4') };
  var ORDER = ["[iOS][Smoke]","[iOS][Selective]","[Android][Smoke]","[Android][Selective]","[iOS][High/Blocker]","[Android][High/Blocker]"];
  var CURRENT_BASE_URL = '';
  var barAllChartRef = null;

  /* ===== –º–∏–∫—Ä–æ-–æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ ===== */
  const now = ()=> performance.now();

  // –ü–∞–∫–µ—Ç–Ω–æ–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
  const logBuf=[]; let logTimer=null;
  function flushLog(){
    if(!logBuf.length) return;
    const el=$('#log')||$('#runLog'); if(!el) { logBuf.length=0; return; }
    el.textContent += (el.textContent ? '\n' : '') + logBuf.join('\n');
    el.scrollTop = el.scrollHeight;
    logBuf.length=0; logTimer=null;
  }
  function appendLogLine(line){
    logBuf.push(line);
    if(!logTimer) logTimer=setTimeout(flushLog, 80);
  }
  function logDash(msg){ appendLogLine(msg); }

  // –ö–µ—à GET-–∑–∞–ø—Ä–æ—Å–æ–≤
  const GET_CACHE = new Map();
  function cacheKey(url, params, headers){
    const qs=params?new URLSearchParams(params).toString():'';
    return url + (qs?('?'+qs):'') + '|' + (headers?.Authorization||'');
  }

  // –ü—É–ª –ø—Ä–æ–º–∏—Å–æ–≤
  async function pMap(arr, mapper, {concurrency=8, onProgress}={}){
    return new Promise((resolve,reject)=>{
      let i=0, done=0, out=new Array(arr.length), active=0, stopped=false;
      const next=()=>{
        if(stopped) return;
        while(active<concurrency && i<arr.length){
          const idx=i++, val=arr[idx]; active++;
          Promise.resolve().then(()=>mapper(val, idx)).then(res=>{
            out[idx]=res; active--; done++; if(onProgress) onProgress(done, arr.length); (done===arr.length)?resolve(out):next();
          }).catch(e=>{ stopped=true; reject(e); });
        }
      };
      next();
    });
  }

  async function safeJson(resp){ try{ return await resp.json(); }catch(_){ return null; } }

/* ===== —Ä–µ–Ω–¥–µ—Ä –≥—Ä–∞—Ñ–∏–∫–æ–≤ ===== */
function makeBarChart(canvasId, labels, datasets){
  var canvas = document.getElementById(canvasId);
  if (!canvas) return;

  var maker = function(){
    fitHiDPICanvas(canvas);
    var ctx = makeCtx(canvas);

    if (window.__charts[canvasId] && window.__charts[canvasId].chart){
      try { window.__charts[canvasId].chart.destroy(); } catch(e){}
    }

    function colorFor(key){
      return key==='total' ? COLORS.total
           : key==='finished' ? COLORS.finished
           : key==='remaining_total' ? COLORS.remaining_total
           : key==='remaining' ? COLORS.remaining
           : key==='in_progress' ? COLORS.in_progress
           : COLORS.finished;
    }

    // 1) –õ–µ–π–±–ª—ã-–∑–Ω–∞—á–µ–Ω–∏—è –ø–æ–≤–µ—Ä—Ö —Å—Ç–æ–ª–±—Ü–æ–≤ (—á–∏—Ç–∞–±–µ–ª—å–Ω–æ –∏ —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–æ)
    const valueLabelsPlugin = {
      id: 'valueLabels',
      afterDatasetsDraw(chart){
        const {ctx, chartArea} = chart;
        ctx.save();
        ctx.textAlign = 'center';
        ctx.textBaseline = 'bottom';
        ctx.font = Chart.helpers.toFont(Chart.defaults.font).string;

        chart.data.datasets.forEach((ds, di)=>{
          const meta = chart.getDatasetMeta(di);
          if (!meta || !meta.data) return;

          meta.data.forEach((bar, i)=>{
            if (!bar) return;
            const val = Number(ds.data?.[i] || 0);
            if (val === 0) return;

            const {x, y} = bar.getProps(['x','y'], true);
            // –¥–µ—Ä–∂–∏–º –ø–æ–¥–ø–∏—Å—å –≤–Ω—É—Ç—Ä–∏ –æ–±–ª–∞—Å—Ç–∏ –≥—Ä–∞—Ñ–∏–∫–∞
            const yy = Math.min(Math.max(y - 6, chartArea.top + 6), chartArea.bottom - 6);

            ctx.fillStyle = getCSS('--ink');
            ctx.fillText(val.toLocaleString('ru-RU'), x, yy);
          });
        });
        ctx.restore();
      }
    };

    // 2) –î–µ–ª—å—Ç–∞ –Ω–∞–¥ ¬´–¢–µ–∫—É—â–∏–º¬ª –≤ prev/curr
    const deltaPlugin = {
      id: 'deltaInside',
      afterDatasetsDraw(chart) {
        if (chart.canvas.id !== 'dashPrevCurr' && chart.canvas.id !== 'dashPrevCurrStream') return;

        const dsCurr = chart.data.datasets[1];
        const deltas = (dsCurr && dsCurr.__delta) || [];
        const meta = chart.getDatasetMeta(1);
        if (!meta || !meta.data) return;

        const { ctx, chartArea } = chart;
        ctx.save();
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.font = '700 12px ' + Chart.defaults.font.family;

        // helper: —Å–∫—Ä—É–≥–ª—ë–Ω–Ω—ã–π –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫
        function rrect(x, y, w, h, r){
          const rr = Math.min(r, h/2, w/2);
          ctx.beginPath();
          ctx.moveTo(x+rr, y);
          ctx.arcTo(x+w, y,   x+w, y+h, rr);
          ctx.arcTo(x+w, y+h, x,   y+h, rr);
          ctx.arcTo(x,   y+h, x,   y,   rr);
          ctx.arcTo(x,   y,   x+w, y,   rr);
          ctx.closePath();
        }

        meta.data.forEach((elem, i) => {
          if (!elem) return;
          const d = Number(deltas[i] || 0);
if (d === 0) return;  // üî¥ –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –Ω—É–ª–µ–≤—ã–µ –¥–µ–ª—å—Ç—ã
const txt = (d > 0 ? '+' : '') + d.toLocaleString('ru-RU');

          const { x, y, base } = elem.getProps(['x','y','base'], true);
          let cy = y + (base - y) / 2;               // —Ü–µ–Ω—Ç—Ä —Å—Ç–æ–ª–±—Ü–∞
          const pad = 12;
          cy = Math.max(chartArea.top + pad, Math.min(chartArea.bottom - pad, cy));

          const w = ctx.measureText(txt).width + 10;
          const h = 18;
          ctx.fillStyle = 'rgba(255,255,255,.85)';
          rrect(x - w/2, cy - h/2, w, h, 8);
          ctx.fill();

          ctx.fillStyle = getCSS('--ink') || getCSS('--text') || '#2a1446';
          ctx.fillText(txt, x, cy);
        });

        ctx.restore();
      }
    };

    const isPrevCurr = (canvasId==='dashPrevCurr' || canvasId==='dashPrevCurrStream');

    var cfg = {
      type: 'bar',
      data: {
        labels: labels,
        datasets: datasets.map(function(ds){
          return {
            label: ds.label,
            data: ds.data,
            backgroundColor: ds.backgroundColor || hexA(colorFor(ds.key), ds.key==='total' ? .45 : .85),
            borderColor: ds.borderColor || colorFor(ds.key),
            borderWidth: 1.5,
            borderRadius: 6,
            borderSkipped: false,
            barThickness: 'flex',
            maxBarThickness: 46,
            categoryPercentage: 0.7,
            barPercentage: 0.9
          };
        })
      },
      options: {
        maintainAspectRatio: false,
        animation: false,
        layout: { padding: { top: 8, bottom: 8 } },
        plugins: {
          legend: { position: 'bottom' },
          // –ù–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π –≥–∞—Å–∏–º chartjs-plugin-datalabels, –µ—Å–ª–∏ –ø–æ–¥–∫–ª—é—á–µ–Ω –≥–ª–æ–±–∞–ª—å–Ω–æ
          datalabels: false
        },
        scales: {
          x: { grid: { display: false } },
          y: {
            beginAtZero: true,
            grid: { color: 'rgba(148,163,184,.2)' },
            ticks: { stepSize: 500 }
          }
        }
      },
      // –ü–æ–¥–∫–ª—é—á–∞–µ–º –ø–ª–∞–≥–∏–Ω—ã —É—Å–ª–æ–≤–Ω–æ
      plugins: isPrevCurr ? [valueLabelsPlugin, deltaPlugin] : [valueLabelsPlugin]
    };

    var chart = new Chart(ctx, cfg);
    window.__charts[canvasId] = { chart: chart, maker: maker };
    if (canvasId === 'barAll') barAllChartRef = chart;
  };

  maker();
}

  function makeDonut(canvas, values){
  // values –æ–∂–∏–¥–∞–µ—Ç: [finished, remaining_total]
  var maker=function(){
    fitHiDPICanvas(canvas);
    var ctx=makeCtx(canvas);

    if(window.__charts[canvas.id] && window.__charts[canvas.id].chart){
      try{ window.__charts[canvas.id].chart.destroy(); }catch(e){}
    }

    const percentCenter = {
      id: 'percentCenter',
      afterDraw(chart){
        const data = (chart.data.datasets?.[0]?.data || []).map(Number);
        const finished = data[0] || 0;
        const rest     = data[1] || 0;
        const total    = Math.max(1, finished + rest);

        const donePct  = (finished / total) * 100;
        const leftPct  = (rest     / total) * 100;

        const {ctx} = chart;
        const {left, right, top, bottom} = chart.chartArea;
        const x = (left + right) / 2;
        const y = (top  + bottom) / 2;

        ctx.save();
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        const baseSize = Math.max(14, Math.min(chart.width, chart.height) * 0.18);
        ctx.fillStyle = getCSS('--ink') || getCSS('--text') || '#2a1446';
        ctx.font = `700 ${Math.round(baseSize)}px Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif`;
        ctx.fillText(`${donePct.toFixed(1)}%`, x, y - baseSize*0.03);

        ctx.fillStyle = getCSS('--muted') || '#8d77a6';
        ctx.font = `600 ${Math.round(baseSize*0.37)}px Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif`;
        ctx.fillText(`–æ—Å—Ç–∞–ª–æ—Å—å ${leftPct.toFixed(1)}%`, x, y + baseSize*0.75);
        ctx.restore();
      }
    };

    var chart=new Chart(ctx,{
      type:'doughnut',
      data:{
        labels:['–ü—Ä–æ–π–¥–µ–Ω–æ','–û—Å—Ç–∞–ª–æ—Å—å'],
        datasets:[{
          data:values,
          backgroundColor:[COLORS.finished, COLORS.remaining_total],
          borderColor:'#ffffff',
          borderWidth:2,
          spacing:3,
          hoverOffset:4
        }]
      },
      options:{
        maintainAspectRatio:false,
        animation:false,
        plugins:{
          legend:{ position:'bottom', labels:{ padding:10, boxWidth:10, boxHeight:10 } },
          tooltip:{
            callbacks:{
              label: (ct)=>{
                const ds = (ct.dataset.data||[]).map(Number);
                const total = ds.reduce((s,v)=>s+v,0) || 1;
                const val = Number(ct.raw||0);
                const pct = (val/total*100).toFixed(1);
                return `${ct.label}: ${val.toLocaleString('ru-RU')} (${pct}%)`;
              }
            }
          }
        },
        cutout:'68%'
      },
      plugins:[percentCenter]
    });

    window.__charts[canvas.id]={chart:chart, maker:maker};
  };
  return maker;
}
  /* ===== —Å–µ—Ç—å/–≤—ã–∑–æ–≤—ã API ===== */
  function b64Utf8(str){ return btoa(unescape(encodeURIComponent(str))); }
  function makeSearchValue(kind, version){
    try{
      const arr = [
        { id:'name', type:'string', value:`[${kind}]` },
        { id:'name', type:'string', value:String(version) }
      ];
      return b64Utf8(JSON.stringify(arr));
    }catch(_){ 
      return b64Utf8(JSON.stringify([{id:'name', type:'string', value:`[${kind}] –†–µ–≥—Ä–µ—Å—Å ${version}`} ]));
    }
  }  function searchB64NameContains(str){
    return btoa(unescape(encodeURIComponent(JSON.stringify([{id:'name', type:'string', value:String(str)}]))));
  }
  async function fetchJson(url, params, headers){
    const qs=params?new URLSearchParams(params).toString():'';
    const full=qs?(url+'?'+qs):url;
    const key = cacheKey(url, params, headers);
    if(GET_CACHE.has(key)) return GET_CACHE.get(key);

    const fetchOnce = async (hdrs)=> {
      const r = await fetch(full,{headers:hdrs});
      if(!r.ok) return {status:r.status, data:await safeJson(r)};
      return {status:r.status, data:await r.json()};
    };

    let res = await fetchOnce(headers);
    if(res.status===401 && headers?.Authorization?.startsWith('Api-Token ')){
      const h2={...headers, Authorization: headers.Authorization.replace('Api-Token ','Bearer ')};
      res = await fetchOnce(h2);
    }
    if(!res || (res.status<200 || res.status>=300)) throw new Error('HTTP '+(res?.status||''));
    GET_CACHE.set(key, res.data);
    return res.data;
  }

  async function fetchPaginated(baseUrl, paramsBase, headers, {size=100, maxPages=8, window=4, logger}={}){
    const out = [];
    let active = 0, stopped = false, i = 0;

    return await new Promise((resolve, reject)=>{
      const run = ()=>{
        if (stopped) return;
        while (active < window && i < maxPages) {
          const page = i++;
          active++;
          const params = { ...paramsBase, page, size };
          fetchJson(baseUrl + '/api/launch', params, headers).then(data=>{
            const items = (data && data.content) || [];
            if (logger) logger('[launch] page=' + page + ' items=' + items.length);
            for (let k = 0; k < items.length; k++) out.push(items[k]);
            if (items.length < size) stopped = true;
          }).catch(reject).finally(()=>{
            active--;
            if ((stopped || i >= maxPages) && active === 0) resolve(out);
            else run();
          });
        }
      };
      run();
    });
  }

  async function fetchLaunches(baseUrl, projectId, version, includeSmoke, includeSelective, headers, pages, size, logger){
    const maxPages = pages==null?8:pages;
    const pageSize = size==null?100:size;

    const kinds=[];
    if(includeSmoke) kinds.push(getSmokeKey());
    if(includeSelective) kinds.push(getSelectiveKey());

    const tasks = kinds.map(kind=>{
      const search = version ? makeSearchValue(kind,version) : undefined;
      const paramsBase = { projectId, preview:'true', sort:'createdDate,desc' };
      if (search) paramsBase.search = search;
      return fetchPaginated(baseUrl, paramsBase, headers, {size:pageSize, maxPages, window:4, logger});
    });

    const result = (await Promise.all(tasks)).flat();

    const seen=new Set(); const uniq=[];
    for(const it of result){
      if(!it || seen.has(it.id)) continue;
      seen.add(it.id); uniq.push(it);
    }
    return uniq;
  }

  function fetchStat(baseUrl, id, headers, elog){
    return fetchJson(baseUrl+'/api/launch/'+id+'/statistic', null, headers).then(function(stat){ return Array.isArray(stat)?stat:[]; })
      .catch(function(e){ if(elog) elog('[stat '+id+'] '+e.message); return []; });
  }

  async function fetchMemberStats(baseUrl, id, headers){
    return fetchJson(baseUrl+'/api/launch/'+id+'/memberstats', {size:1000,page:0}, headers).then(function(d){
      if(Array.isArray(d)) return d;
      return (d&&d.content)||[];
    }).catch(()=>[]);
  }

  async function fetchLeafCount(baseUrl, id, headers, searchFilter){
    const urlLeaf = baseUrl + '/api/testresulttree/leaf';
    const size = 2000;
    let page = 0;
    const uniq = new Set();
    while (true){
      const params = { launchId:id, treeId:14, sort:'duration,asc', size, page };
      if (searchFilter) params.search = searchFilter;
      const data = await fetchJson(urlLeaf, params, headers).catch(()=>null);
      const content = (data && data.content) || [];
      if (!content.length) break;
      for (const leaf of content){
        const uid = leaf?.uid ?? leaf?.id ?? leaf?.testCaseId ?? leaf?.entityId;
        if (uid != null) uniq.add(String(uid));
        else uniq.add('p'+page+'_'+uniq.size);
      }
      if (content.length < size) break;
      if (uniq.size > 250000) break;
      page += 1;
    }
    return uniq.size;
  }

  /* ===== –∞–≥—Ä–µ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ/–ø–æ–¥—Å—á—ë—Ç—ã ===== */
  function normalizeStatus(raw){
    if (raw == null) return 'in_progress';
    const s = String(raw).toLowerCase();
    if (s === 'passed' || s === 'failed' || s === 'broken' || s === 'skipped') return s;
    return 'in_progress';
  }
  const COMPLETED = new Set(['passed','failed','broken','skipped']);
  const NON_COMPLETED = new Set(['in_progress']);

  function sumByStatuses(list, allowedSet){
    let sum = 0;
    (list || []).forEach(s => {
      const st = normalizeStatus(s && s.status);
      if (allowedSet.has(st)) sum += Number(s.count || 0);
    });
    return sum;
  }

  function computeCountsExact(statList){
    const finished   = sumByStatuses(statList, COMPLETED);
    const unfinished = sumByStatuses(statList, NON_COMPLETED);
    const total      = finished + unfinished;
    const remaining_total = unfinished;
    return {
      total,
      finished,
      remaining_total,
      in_progress: unfinished,
      remaining: 0
    };
  }

  function assignedUnfinishedFromMemberStats(mstats){
    let assigned=0;
    (mstats||[]).forEach(m=>{
      assigned += sumByStatuses(m.statistic, NON_COMPLETED);
    });
    return assigned;
  }

  function setLogProgress(state){
    var cap = $('#logProgressCaption');
    var bar = $('#logProgressBar');
    var loaded = Number(state.loaded||0), total = Number(state.total||0);
    var step = Number(state.step||0), steps = Number(state.steps||0);
    if(cap) cap.textContent = '–ó–∞–ø—É—Å–∫–æ–≤: '+loaded+' –∏–∑ '+(total||loaded)+' ‚Ä¢ –®–∞–≥–∏: '+step+' / '+(steps||step);
    if(bar){
      var p = total>0 ? Math.min(100, Math.round(loaded/Math.max(1,total)*100)) : (steps>0? Math.min(100, Math.round(step/Math.max(1,steps)*100)) : 0);
      bar.style.width = p + '%';
    }
  }

  async function aggregateByGroups(launches, baseUrl, headers, logger, elog){
    var agg={};
    for(var oi=0;oi<ORDER.length;oi++){
      agg[ORDER[oi]]={total:0,finished:0,remaining_total:0,remaining:0,in_progress:0};
    }

    var perLaunchFinished = {}, perLaunchTotal = {};
    const totalSteps = launches.length;
    let doneSteps = 0;

    await pMap(launches, async (it)=>{
      try{
        const [stat, mstats] = await Promise.all([
          fetchStat(baseUrl, it.id, headers, elog),
          fetchMemberStats(baseUrl, it.id, headers)
        ]);
        const c = computeCountsExact(stat);

        const assignedUnf = assignedUnfinishedFromMemberStats(mstats);
        const unfinishedAll = Math.max(0, c.remaining_total);
        const unassigned = Math.max(0, unfinishedAll - assignedUnf);

        perLaunchFinished[it.id]=c.finished||0;
        perLaunchTotal[it.id]=c.total||0;

        for(var gi=0;gi<ORDER.length;gi++){
          var key=ORDER[gi]; var first=key.split(']')[0]+']'; var second=key.split('][')[1];
          var nm = it.name||'';
          if(nm.indexOf(first)!==-1 && nm.indexOf(second)!==-1){
            agg[key].total           += c.total;
            agg[key].finished        += c.finished;
            agg[key].remaining_total += unfinishedAll;
            agg[key].remaining       += assignedUnf;
            agg[key].in_progress     += unassigned;
            break;
          }
        }
      }catch(e){ if(elog) elog('[aggregate '+it.id+'] '+(e.message||e)); }
      doneSteps++;
      if(doneSteps%2===0) setLogProgress({ step: doneSteps, steps: totalSteps, loaded: doneSteps, total: totalSteps });
    }, {concurrency: 10});

    setLogProgress({ step: totalSteps, steps: totalSteps, loaded: totalSteps, total: totalSteps });
    return {agg, perLaunchFinished, perLaunchTotal};
  }

  function renderAgg(agg, cardsId, barId, summaryEl){
    var container=document.getElementById(cardsId);
    container.innerHTML='';
    var grand=0;
    for(var oi=0;oi<ORDER.length;oi++){
      var label=ORDER[oi];
      var a=agg[label]||{total:0,finished:0,remaining_total:0,remaining:0,in_progress:0};
      grand+=a.total;
      var canId='dn_'+cardsId+'_'+oi;
      var card=document.createElement('div');
card.className='card';
card.innerHTML='' +
  '<div class="head"><div>'+label+'</div><div class="export"><div class="nums">–í—Å–µ–≥–æ: <b>'+(a.total||0).toLocaleString('ru-RU')+'</b></div></div></div>'+
  '<div class="chart-wrap"><canvas id="'+canId+'" class="chart"></canvas></div>'+
  '<div class="kpis">'+
    '<div class="kpi"><span class="label">–ü—Ä–æ–π–¥–µ–Ω–æ</span><span class="val">'+(a.finished||0).toLocaleString('ru-RU')+'</span></div>'+
    '<div class="kpi"><span class="label">–û—Å—Ç–∞–ª–æ—Å—å</span><span class="val">'+(a.remaining_total||0).toLocaleString('ru-RU')+'</span></div>'+
  '</div>';
container.appendChild(card);
(function(canId,a){
  // –ø–µ—Ä–µ–¥–∞—ë–º —Ç–æ–ª—å–∫–æ 2 —á–∏—Å–ª–∞: –ø—Ä–æ–π–¥–µ–Ω–æ –∏ –æ—Å—Ç–∞–ª–æ—Å—å
  var maker=makeDonut(document.getElementById(canId), [a.finished, a.remaining_total]);
  requestAnimationFrame(function(){ maker(); });
})(canId, a);
    }
    if(summaryEl) summaryEl.textContent='–í—Å–µ–≥–æ –≥—Ä—É–ø–ø: '+ORDER.length+', –≤—Å–µ–≥–æ –∫–µ–π—Å–æ–≤: '+grand.toLocaleString('ru-RU');


// === build datasets with FILTERS applied ===
  // Inline checker independent from later helpers
  function __allowLabel(label){
    label = String(label||'');
    var isIOS     = label.indexOf('[iOS]')===0;
    var isAndroid = label.indexOf('[Android]')===0;
    var isSmoke   = label.indexOf('[Smoke]')!==-1;
    var isSel     = label.indexOf('[Selective]')!==-1;
    var isHB      = label.indexOf('[High/Blocker]')!==-1;

    var on = function(id){ var el=document.getElementById(id); return !el || !!el.checked; };
    if (isIOS && !on('fltPlatIOS')) return false;
    if (isAndroid && !on('fltPlatAndroid')) return false;
    if (isSmoke && !on('fltTypeSmoke')) return false;
    if (isSel   && !on('fltTypeSelective')) return false;
    if (isHB    && !on('fltTypeHB')) return false;
    // if label doesn't specify a known platform/type, keep it
    return true;
  }
  var __ORDER_USED = ORDER.filter(__allowLabel);

  var ds = ['total','finished','remaining_total'].map(function(k){
    return {
      key: k,
      label: ({ total:'–í—Å–µ–≥–æ', finished:'–ü—Ä–æ–π–¥–µ–Ω–æ', remaining_total:'–û—Å—Ç–∞–ª–æ—Å—å' })[k],
      data: __ORDER_USED.map(function(l){ return (agg[l] && agg[l][k]) || 0; })
    };
  });

  // Update summary (visible only)
  try{
    var totalCasesVisible = 0;
    for (var i=0;i<__ORDER_USED.length;i++){
      var a = agg[__ORDER_USED[i]] || {};
      totalCasesVisible += Number(a.total||0) || 0;
    }
    var sumEl = document.getElementById('summaryInfo');
    if (sumEl) sumEl.textContent = '–í—Å–µ–≥–æ –≥—Ä—É–ø–ø: ' + __ORDER_USED.length + ', –≤—Å–µ–≥–æ –∫–µ–π—Å–æ–≤: ' + (totalCasesVisible.toLocaleString ? totalCasesVisible.toLocaleString('ru-RU') : totalCasesVisible);
  }catch(e){}
  if(barId) makeBarChart(barId, __ORDER_USED, ds);

  }

  /* ===== –•—Ä–∞–Ω–∏–ª–∏—â–µ ===== */
  var STORE_DEFAULT={ snaps:[], streamSnaps:[], lastPerLaunch:{} };
  function getStore(){ try{ return JSON.parse(localStorage.getItem('allure-regress-store-v1')) || JSON.parse(JSON.stringify(STORE_DEFAULT)); }catch(e){ return JSON.parse(JSON.stringify(STORE_DEFAULT)); } }
  function setLocalStore(s){ localStorage.setItem('allure-regress-store-v1', JSON.stringify(s)); }
  let storeFromFile=null, dataFileHandle=null;
  function setStore(newStore){
    storeFromFile = JSON.parse(JSON.stringify({ ...STORE_DEFAULT, ...(newStore||{}) }));
    setLocalStore(storeFromFile);
    var saveBtn = $('#dataSave'); if(saveBtn) saveBtn.disabled = !dataFileHandle;
  }
  async function saveStoreMaybe(){
    if(!dataFileHandle || !storeFromFile) return;
    try{
      const writable = await dataFileHandle.createWritable();
      await writable.write(JSON.stringify(storeFromFile, null, 2));
      await writable.close();
      toast('–î–∞–Ω–Ω—ã–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã –≤ —Ñ–∞–π–ª');
    }catch(e){ toast('–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å: '+(e.message||e)); }
  }
  async function pickDataFile(){
    if(!window.showOpenFilePicker){ toast('–ë—Ä–∞—É–∑–µ—Ä –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ —Ñ–∞–π–ª–∞. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –ò–º–ø–æ—Ä—Ç JSON.'); return; }
    try{
      const [handle] = await window.showOpenFilePicker({ multiple:false, types:[{ description:'JSON', accept:{'application/json':['.json']} }] });
      dataFileHandle = handle;
      const file = await handle.getFile();
      const text = await file.text(); const obj = JSON.parse(text||'{}');
      setStore({ ...STORE_DEFAULT, ...obj }); renderSnapList(); renderStreamSnapList(); toast('–§–∞–π–ª –¥–∞–Ω–Ω—ã—Ö –ø–æ–¥–∫–ª—é—á—ë–Ω');
    }catch(e){ if(e?.name!=='AbortError') toast('–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è —Ñ–∞–π–ª–∞: '+(e.message||e)); }
  }
  async function createDataFile(){
    if(!window.showSaveFilePicker){ toast('–ë—Ä–∞—É–∑–µ—Ä –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç —Å–æ–∑–¥–∞–Ω–∏–µ —Ñ–∞–π–ª–∞. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –≠–∫—Å–ø–æ—Ä—Ç JSON.'); return; }
    try{
      const handle = await window.showSaveFilePicker({ suggestedName:'regress-data.json', types:[{ description:'JSON', accept:{'application/json':['.json']} }] });
      dataFileHandle = handle;
      setStore(getStore()); await saveStoreMaybe();
      toast('–§–∞–π–ª –¥–∞–Ω–Ω—ã—Ö —Å–æ–∑–¥–∞–Ω –∏ –ø–æ–¥–∫–ª—é—á—ë–Ω');
    }catch(e){ if(e?.name!=='AbortError') toast('–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å —Ñ–∞–π–ª: '+(e.message||e)); }
  }

  function exportSnapsCSV(){
    var st=getStore(); var snaps=st.snaps||[];
    var rows=[['snap_id','ts_iso','title','group','total','finished','remaining_total','remaining','in_progress']];
    snaps.forEach(function(s){
      ORDER.forEach(function(g){
        var o=(s.data||{})[g]||{total:0,finished:0,remaining_total:0,remaining:0,in_progress:0};
        rows.push([s.id, new Date(s.ts).toISOString(), s.title, g, o.total, o.finished, o.remaining_total, o.remaining, o.in_progress]);
      });
    });
    var csv = rows.map(r => r.map(v=>{
      var x=(v==null?'':String(v));
      if(/[",\n]/.test(x)) x='"'+x.replace(/"/g,'""')+'"';
      return x;
    }).join(',')).join('\n');
    var blob=new Blob([csv],{type:'text/csv;charset=utf-8'});
    var url=URL.createObjectURL(blob); var a=document.createElement('a'); a.href=url; a.download='regress-data.csv'; a.click(); URL.revokeObjectURL(url);
  }

  /* ===== –î–∞—à–±–æ—Ä–¥: –∫–Ω–æ–ø–∫–∏/—Ä–µ–Ω–¥–µ—Ä (–û–±—â–∏–µ) ===== */
  function renderSnapList(){
    var box=$('#snapListDash'); if(!box) return; box.innerHTML='';
    var store=getStore(); var list=store.snaps||[];
    for(var i=list.length-1;i>=0;i--){
      var s=list[i];
      var totalFinished = ORDER.reduce(function(sum,k){ return sum + (((s.data||{})[k]||{}).finished||0);}, 0);
      var row=document.createElement('div');
      row.className='snap';
      row.innerHTML='<input type="checkbox" data-id="'+s.id+'" />'+
        '<label style="flex:1;display:flex;flex-direction:column;gap:2px;min-width:0">'+
        '<span class="title">'+s.title+'</span>'+
        '<span class="meta">'+(new Date(s.ts)).toLocaleString()+' ‚Ä¢ –≤—Å–µ–≥–æ –ø—Ä–æ–π–¥–µ–Ω–æ: '+totalFinished.toLocaleString('ru-RU')+'</span></label>'+
        '<button class="del" data-id="'+s.id+'">–£–¥–∞–ª–∏—Ç—å</button>';
      box.appendChild(row);
    }
    var dels=box.querySelectorAll('.del');
    for(var d=0;d<dels.length;d++){
      dels[d].addEventListener('click', function(){
        var id=this.getAttribute('data-id'); var st=getStore();
        st.snaps=(st.snaps||[]).filter(function(x){return x.id!==id});
        setStore(st); renderSnapList();
      });
    }
    $('#dashSnapSave')?.addEventListener('click', function(){
      if(!window.lastAgg){ toast('–°–Ω–∞—á–∞–ª–∞ —Å–æ–±–µ—Ä–∏—Ç–µ –¥–∞—à–±–æ—Ä–¥'); return; }
      takeSnapshot({ version:($('#version')?.value.trim())||'', timeISO:(new Date()).toISOString(), data: window.lastAgg });
    });
    $('#dashSnapClear')?.addEventListener('click', function(){
      var st=getStore(); st.snaps=[]; setStore(st); renderSnapList(); toast('–°—Ä–µ–∑—ã —É–¥–∞–ª–µ–Ω—ã');
    });
    $('#dashSnapBuild')?.addEventListener('click', ()=>buildDashMultiCompare({silent:false}));
  }

  // === –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–û–ï: –∫—Ä–∞—Å–∏–≤—ã–µ –ø–æ–¥–ø–∏—Å–∏ –¥–ª—è –ª–µ–≥–µ–Ω–¥—ã/—Å—Ä–µ–∑–æ–≤ ===
function prettySnapTitle(raw){
  // –ë—ã–ª–æ: "[Smoke] –ö–æ—Ä–∑–∏–Ω–∞... v=7.2.9 2025-09-02T12:44:33Z"
  // –°—Ç–∞–Ω–µ—Ç: "[Smoke] –ö–æ—Ä–∑–∏–Ω–∞... v=7.2.9 2025-09-02 12:44"
  const s = String(raw||'');
  const m = s.match(/(\d{4}-\d{2}-\d{2})T(\d{2}:\d{2})/);
  const neat = m ? s.replace(/T\d{2}:\d{2}:\d{2}.*Z?/,' '+m[2]) : s;
  return neat.replace('Z','').trim();
}

// === –°–¢–ê–†–ê–Ø –§–£–ù–ö–¶–ò–Ø ===
function makeSnapTitle(o){
  var ver=o.version||'all';
  return `[Smoke+Selective] v=${ver} ${o.timeISO}`;
}

  function makeSnapTitle(o){
    var ver=o.version||'all';
    return `[Smoke+Selective] v=${ver} ${o.timeISO}`;
  }
  function takeSnapshot(ctx){
    var st=getStore();
    var id=String(Date.now())+Math.random().toString(16).slice(2);
    var snap={ id:id, ts:Date.now(), title:makeSnapTitle(ctx), data:ctx.data };
    st.snaps=(st.snaps||[]); st.snaps.push(snap);
    setStore(st); renderSnapList(); saveStoreMaybe(); toast('–°—Ä–µ–∑ —Å–æ—Ö—Ä–∞–Ω—ë–Ω');
  }

  function buildDashMultiCompare(opts){
    const silent = !!(opts && opts.silent);

    var metric=$('#dashMetric')?.value || 'finished';
    var labels=ORDER;
    var chosen=[].slice.call(document.querySelectorAll('#snapListDash input[type=checkbox]:checked'))
                 .map(cb=>cb.getAttribute('data-id'));

    var snaps=(getStore().snaps||[]).filter(s=> chosen.indexOf(s.id)!==-1);

    if(!snaps.length){
      if(!silent) toast('–í—ã–±–µ—Ä–∏—Ç–µ —Å—Ä–µ–∑—ã');
      return;
    }

    // —Å–æ–±—Ä–∞—Ç—å –Ω–∞–±–æ—Ä—ã
    const palette = [
      '#7a3af9','#00c48c','#ffb020','#ff5aad','#3b82f6','#10b981','#f59e0b','#ef4444','#8b5cf6','#14b8a6'
    ];
    const datasets = snaps.map((s, i)=>{
      const col = palette[i % palette.length];
      return {
        key: metric,
        label: prettySnapTitle(s.title || ('–°—Ä–µ–∑ '+(i+1))),
        data: labels.map(k => ((s.data||{})[k]||{})[metric] || 0),
        backgroundColor: hexA(col,.85),
        borderColor: col
      };
    });

    var wrap = document.getElementById('dashMultiBar')?.parentElement;
    if(wrap){
      var extra = Math.max(0, datasets.length - 6);
      wrap.style.height = Math.min(900, 320 + extra*24) + 'px';
    }

    makeBarChart('dashMultiBar', labels, datasets);
  }

  function renderDashPrevCurrent(currentAgg, metric){
    metric=metric||'finished'; var color=COLORS[metric]||COLORS.finished; var labels=ORDER;
    var list=(getStore().snaps||[]); var prev=list.length>0?list[list.length-1]:null;
    var currData=labels.map(function(k){ return (currentAgg[k]&&currentAgg[k][metric])||0; });
    var prevData=labels.map(function(k){ return (prev&&prev.data&&prev.data[k]&&prev.data[k][metric])?prev.data[k][metric]:0; });
    var deltas = currData.map(function(v,i){ return v - (prevData[i]||0); });

    var box=$('#dashDelta');
    if(box){
      box.innerHTML='';
      for(var i=0;i<labels.length;i++){
        var d=deltas[i]; var sign=d>0?'+':'';
        var item=document.createElement('div'); item.className='kpi';
        item.innerHTML='<span class="label">'+labels[i]+' ‚Äî Œî</span><span class="val">'+sign+d.toLocaleString('ru-RU')+'</span>';
        box.appendChild(item);
      }
    }

    var dsPrev = {key:metric, label:'–ü—Ä–µ–¥—ã–¥—É—â–∏–π', data:prevData, backgroundColor:hexA(color,.35), borderColor:color};
    var dsCurr = {key:metric, label:'–¢–µ–∫—É—â–∏–π',   data:currData, backgroundColor:hexA(color,.85), borderColor:color};
    dsCurr.__delta = deltas;

    makeBarChart('dashPrevCurr', labels, [dsPrev, dsCurr]);
  }

  /* ===== Readiness (Android + iOS) ===== */
  async function fetchReadinessLaunch(baseUrl, projectId, headers, platform, version){
    const nameCore = `[ALL][${platform}] –ì–æ—Ç–æ–≤–Ω–æ—Å—Ç—å –∫ —Ä–µ–ª–∏–∑—É`;
    const tryWith  = searchB64NameContains(`${nameCore} ${version}`);
    const tryPlain = searchB64NameContains(nameCore);

    async function findOne(searchB64){
      const list = await fetchPaginated(
        baseUrl,
        { projectId, preview:'true', sort:'createdDate,desc', search: searchB64 },
        headers,
        { size:100, maxPages:6, window:3 }
      );
      return (list && list[0]) || null;
    }

    let launch = version ? (await findOne(tryWith)) : null;
    if(!launch) launch = await findOne(tryPlain);
    return launch;
  }

  async function buildReleaseSection(baseUrl, projectId, version, headers){
    const headVer = document.getElementById('releaseHeadVer');
    if(headVer) headVer.textContent = '–í–µ—Ä—Å–∏—è: ' + (version || '‚Äî');

    const row = document.getElementById('releaseRow');
    if(!row) return;
    row.innerHTML = '<div class="nums">–ó–∞–≥—Ä—É–∑–∫–∞‚Ä¶</div>';

    const [andL, iosL] = await Promise.all([
      fetchReadinessLaunch(baseUrl, projectId, headers, 'Android', version),
      fetchReadinessLaunch(baseUrl, projectId, headers, 'iOS',      version)
    ]);

    async function oneCard(L){
      if(!L) return {
        html: '<div class="release-card"><div class="release-title"><span>‚Äî</span><span class="nums">–Ω–µ—Ç –ª–∞—É–Ω—á–∞</span></div></div>'
      };
      const stat = await fetchStat(baseUrl, L.id, headers);
      const c = computeCountsExact(stat);
      const total = Number(c.total||0);
      const finished = Number(c.finished||0);
      const pct = total>0 ? Math.round(finished*100/total) : 0;

      const link = `${baseUrl}/launch/${L.id}`;
      const safeName = escapeHtml(L.name||'[launch]');

      const html =
        `<div class="release-card">
          <div class="release-title">
            <span>${safeName}</span>
            <span class="nums">#${L.id}</span>
          </div>
          <div class="release-sub">
            <div class="release-chip">–ì–æ—Ç–æ–≤–Ω–æ—Å—Ç—å (–ø—Ä–æ–π–¥–µ–Ω–æ)</div>
            <div class="release-chip"><strong>${pct}%</strong></div>
            <div class="release-chip">–í—Å–µ–≥–æ / –ü—Ä–æ–π–¥–µ–Ω–æ&nbsp;<strong>${total.toLocaleString('ru-RU')} / ${finished.toLocaleString('ru-RU')}</strong></div>
          </div>
          <div class="release-bar"><div style="width:${pct}%"></div></div>
          <a class="release-link" href="${link}" target="_blank">–û—Ç–∫—Ä—ã—Ç—å launch</a>
        </div>`;
      return {html};
    }

    const [andCard, iosCard] = await Promise.all([oneCard(andL), oneCard(iosL)]);
    row.innerHTML = (andCard.html || '') + (iosCard.html || '');
  }

  /* ===== –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª–∏ –¥–ª—è –º–∏–Ω–∏-–¥–∏–∞–≥—Ä–∞–º–º ===== */
  function deptOf(name){
    var low=(name||'').toLowerCase();
    if(low.indexOf('–∫–æ—Ä–∑–∏–Ω')!==-1) return '–ö–æ—Ä–∑–∏–Ω–∞';
    if(low.indexOf('—Ñ–∏–Ω—Ç–µ—Ö')!==-1 || low.indexOf('wbpay')!==-1 || low.indexOf('–∫–æ—à–µ–ª–µ–∫')!==-1 || low.indexOf('–∫–æ—à–µ–ª—å–∫–∞')!==-1) return '–§–∏–Ω—Ç–µ—Ö';
    if(low.indexOf('—á–∞—Ç')!==-1) return '–ß–∞—Ç—ã';
    if(low.indexOf('bx')!==-1 || low.indexOf('–≤—Ö')!==-1) return '–í–•';
    return '–û—Å—Ç–∞–ª—å–Ω—ã–µ';
  }
  function platformOf(name){
    var s=(name||'').toLowerCase();
    if(s.includes('[android]')) return 'android';
    if(s.includes('[ios]')) return 'ios';
    return 'other';
  }

  /* ===== –º–∏–Ω–∏-–¥–∏–∞–≥—Ä–∞–º–º—ã –ø–æ –ª–∞—É–Ω—á–∞–º (—Å —Ñ–∏–ª—å—Ç—Ä–æ–º –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã) ===== */
  function buildMiniLaunchCharts(launches, perLaunchFinished, perLaunchTotal, opts){
    const grid = $('#miniGrid');
    const info = $('#miniInfo');
    if(!grid || !info){ return; }

    const MAX_HARD = 120;
    const {count, sortKey, sortDir, dept, platform} = opts || MINI_DEFAULTS;

    grid.innerHTML = '';
    if(!Array.isArray(launches) || !launches.length){
      info.textContent = '–õ–∞—É–Ω—á–µ–π –Ω–µ –Ω–∞–π–¥–µ–Ω–æ';
      return;
    }

    const items = launches.map(L=>{
      const total    = Number(perLaunchTotal[L.id]   ?? 0);
      const finished = Number(perLaunchFinished[L.id]?? 0);
      const pct      = total>0 ? (finished*100/total) : 0;
      const depName  = deptOf(L.name||'');
      const plt      = platformOf(L.name||'');
      const created  = Number(L.createdDate || L.startTime || 0);
      return { L, total, finished, pct, dept: depName, platform: plt, created };
    });

    let filtered = items;
    if(dept && dept!=='all') filtered = filtered.filter(x=>x.dept===dept);
    if(platform && platform!=='all') filtered = filtered.filter(x=>x.platform===platform);

    const dir = (sortDir==='asc') ? 1 : -1;
    filtered.sort((a,b)=>{
      if(sortKey==='total')    return dir*(a.total - b.total);
      if(sortKey==='finished') return dir*(a.finished - b.finished);
      if(sortKey==='created')  return dir*(a.created - b.created);
      return dir*(a.pct - b.pct);
    });

    const slice = filtered.slice(0, Math.min(MAX_HARD, count));

    slice.forEach((it, idx)=>{
      const {L, total, finished, pct} = it;
      const card = document.createElement('div');
      card.className = 'mini-card';
      const canId = 'mini_can_' + L.id + '_' + idx;

      card.innerHTML =
        `<div class="mini-title" title="${escapeHtml(L.name||'')}">
            <a href="${CURRENT_BASE_URL}/launch/${L.id}" target="_blank" rel="noopener">
              ${escapeHtml(L.name||'')}
            </a>
         </div>
         <div class="mini-fig"><canvas id="${canId}"></canvas></div>
         <div class="mini-remaining">–ü—Ä–æ–π–¥–µ–Ω–æ: ${finished.toLocaleString('ru-RU')} / ${total.toLocaleString('ru-RU')}</div>`;

      grid.appendChild(card);

      const canvas = document.getElementById(canId);
      const maker = () => {
        fitHiDPICanvas(canvas);
        if(window.__charts[canId]?.chart){ try{ window.__charts[canId].chart.destroy(); }catch(e){} }
        const ctx = makeCtx(canvas);
        const chart = new Chart(ctx, {
          type: 'doughnut',
          data: {
            labels: ['–ü—Ä–æ–π–¥–µ–Ω–æ','–û—Å—Ç–∞–ª–æ—Å—å'],
            datasets: [{
              data: [finished, Math.max(0, total - finished)],
              backgroundColor: [COLORS.finished, hexA(COLORS.remaining_total, .6)],
              borderColor:'#fff', borderWidth:2, spacing:2
            }]
          },
          options: {
            maintainAspectRatio:false,
            animation:false,
            cutout:'70%',
            plugins:{ legend:{display:false} }
          },
          plugins:[{
            id:'centerPct2',
            afterDraw(ch){
              const {ctx, chartArea:{left,right,top,bottom}} = ch;
              const x=(left+right)/2, y=(top+bottom)/2;
              ctx.save();
              ctx.textAlign='center'; ctx.textBaseline='middle';
              ctx.fillStyle=getCSS('--ink');
              ctx.font='700 14px ' + Chart.defaults.font.family;
              ctx.fillText(Math.round(pct) + '%', x, y);
              ctx.restore();
            }
          }]
        });
        window.__charts[canId] = { chart, maker };
      };
      maker();
    });

    info.textContent =
      `–ü–æ–∫–∞–∑–∞–Ω–æ: ${slice.length} –∏–∑ ${filtered.length} (–≤—Å–µ–≥–æ ${launches.length}) ‚Ä¢ `
      + `—Å–æ—Ä—Ç: ${({'pct':'% –ø—Ä–æ–π–¥–µ–Ω–æ','finished':'–ø—Ä–æ–π–¥–µ–Ω–æ','total':'–≤—Å–µ–≥–æ','created':'—Å–≤–µ–∂–µ—Å—Ç—å'})[sortKey]} ${sortDir.toUpperCase()}`
      + (dept && dept!=='all' ? ` ‚Ä¢ –æ—Ç–¥–µ–ª: ${dept}` : '')
      + (platform && platform!=='all' ? ` ‚Ä¢ –ø–ª–∞—Ç—Ñ–æ—Ä–º–∞: ${platform.toUpperCase()}` : '');
  }

  /* ===== –∞–ª–µ—Ä—Ç—ã ===== */
  var ALERT_ENTRIES = [];
  function renderAlerts(){
    var box = $('#alertLog'); if(!box) return;

    if(!ALERT_ENTRIES.length){
      box.textContent = '–ü–æ–∫–∞ –∞–ª–ª–µ—Ä—Ç–æ–≤ –Ω–µ—Ç.';
      return;
    }

    var filter = ($('#alertFilter')?.value) || 'all';
    box.innerHTML = '';

    ALERT_ENTRIES.forEach(function(e){
      var finished = Number(e.finished || 0);
      var total    = Number(e.total || 0);

      var hasPassed = finished > 0;
      var isEmpty   = total === 0;

      if(filter === 'passed' && !hasPassed) return;
      if(filter === 'none'   && (hasPassed || isEmpty)) return;
      if(filter === 'empty'  && !isEmpty) return;

      var colorCls = isEmpty ? 'warn' : (hasPassed ? 'ok' : 'bad');

      var href = (CURRENT_BASE_URL ? (CURRENT_BASE_URL + '/api/launch/' + e.id + '/statistic') : '#');

      var row = document.createElement('div');
      row.className = 'alert-row ' + colorCls;
      row.innerHTML =
        '<a href="'+href+'" target="_blank">#'+e.id+'</a> ‚Äî '
        + (e.name || '(no name)') + ' = '
        + '<span>'+finished+'</span>' + (isEmpty?' (–±–µ–∑ –∫–µ–π—Å–æ–≤)':'');
      box.appendChild(row);
    });

    box.scrollTop = box.scrollHeight;
  }
  $('#alertFilter')?.addEventListener('change', renderAlerts);

  /* ===== –∞–≤—Ç–æ ===== */
  var autoTimer=null;
  function setAutoState(running){
    $('#autoState').textContent = '–ê–≤—Ç–æ–∑–∞–ø—É—Å–∫: '+(running?'–≤–∫–ª—é—á—ë–Ω':'–≤—ã–∫–ª—é—á–µ–Ω');
    $('#autoStart').disabled = running;
    $('#autoStop').disabled = !running;
  }

  /* ===== –æ—Å–Ω–æ–≤–Ω–æ–π –∑–∞–ø—É—Å–∫ –¥–∞—à–±–æ—Ä–¥–∞ ===== */
  async function runDashboard(){
    try{ GET_CACHE.clear(); }catch(_){}
    var logEl=$('#log'); if(logEl) logEl.textContent='';
    $('#logInfo') && ($('#logInfo').textContent='‚Äî');
    $('#summaryInfo') && ($('#summaryInfo').textContent='‚Äî');
    $('#alertLog') && ($('#alertLog').textContent='–ü–æ–∫–∞ –∞–ª–ª–µ—Ä—Ç–æ–≤ –Ω–µ—Ç.');
    ALERT_ENTRIES = [];

    var baseUrl=($('#baseUrl')&&$('#baseUrl').value.trim().replace(/\/$/,''))||'';
    var projectId=($('#projectId')&&$('#projectId').value.trim())||'';
    var version=($('#version')&&$('#version').value.trim())||'';
    var token=($('#token')&&$('#token').value.trim())||'';
    if(!baseUrl||!projectId||!token){ toast('–ó–∞–ø–æ–ª–Ω–∏—Ç–µ Base URL, Project ID –∏ —Ç–æ–∫–µ–Ω'); return; }
    CURRENT_BASE_URL = baseUrl;

    var headers={Accept:'application/json', Authorization:'Api-Token '+token, 'User-Agent':'allure-summary-html/stable'};

    try{
      const t0=now();
      const launches = await fetchLaunches(baseUrl, projectId, version, true, true, headers, 8, 100, logDash);

      if($('#logInfo')) $('#logInfo').textContent='–ó–∞–ø—É—Å–∫–æ–≤: '+launches.length;

      launches.forEach(it => appendLogLine('[LAUNCH] #'+it.id+' | '+(it.name||'')));

      setLogProgress({loaded: 0, total: launches.length, step: 0, steps: launches.length});

      const res = await aggregateByGroups(launches, baseUrl, headers, logDash, function(e){ appendLogLine('[error] '+e); });

      var agg=res.agg, perLaunchFinished=res.perLaunchFinished, perLaunchTotal=res.perLaunchTotal;

      // –ú–∏–Ω–∏-–ø–æ–Ω—á–∏–∫–∏ –ø–æ –ª–∞—É–Ω—á–∞–º (—É—á—Ç—ë–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏)
      window.__mini_last = { launches, perLaunchFinished, perLaunchTotal };
      updateStreamNamesUI();
      buildMiniLaunchCharts(launches, perLaunchFinished, perLaunchTotal, readMiniOpts());

      window.lastAgg=agg;

      // NEW: –∞–≤—Ç–æ-—Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –ø–æ—Å—Ç—Ä–∏–º–æ–≤—ã—Ö —Å–Ω–µ–ø—à–æ—Ç–æ–≤ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ç–µ–∫—É—â–µ–π –≤—ã–±–æ—Ä–∫–∏ –ª–∞—É–Ω—á–µ–π
autoSaveAllStreamSnaps();

// NEW: –µ—Å–ª–∏ –æ—Ç–∫—Ä—ã—Ç –ø–æ–¥—Ç–∞–± ¬´–ü–æ —Å—Ç—Ä–∏–º—É¬ª ‚Äî —Å—Ä–∞–∑—É –æ–±–Ω–æ–≤–∏–º prev/curr –±–∞—Ä –∏ —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ
if(document.getElementById('snapStreamSection')?.style.display !== 'none'){
  renderStreamSnapList();
  renderDashPrevCurrentStream(window.lastAgg, $('#dashMetricStream')?.value||'finished');
  buildDashMultiCompareStream({silent:true});
}

      // –∞–ª–µ—Ä—Ç—ã
      var st=getStore();
      var last = st.lastPerLaunch || {};
      const launchNames = {};
      launches.forEach(it => { launchNames[String(it.id)] = it.name || ''; });

      ALERT_ENTRIES = [];
      for(var id in perLaunchFinished){
        var curr = Number(perLaunchFinished[id]||0);
        last[id] = curr;
        ALERT_ENTRIES.push({ id:id, name:launchNames[id]||'', finished:curr, total:Number(perLaunchTotal[id]||0) });
      }
      st.lastPerLaunch = last;
      setStore(st); saveStoreMaybe();

      renderAlerts();

      renderAgg(agg, 'cards', 'barAll', $('#summaryInfo'));
      var mtr=($('#dashMetric')?.value)||'finished';
      renderDashPrevCurrent(agg, mtr);

      
      // –ê–≤—Ç–æ—Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –æ–±—â–µ–≥–æ —Å—Ä–µ–∑–∞ (–∫–∞–∫ –≤ –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏)
      try{ takeSnapshot({ version:($('#version')?.value.trim())||'', timeISO:(new Date()).toISOString(), data: agg }); }catch(_){}
buildDashMultiCompare({ silent: true });

      await buildReleaseSection(baseUrl, projectId, version, headers);

      const t1=now();
      appendLogLine('–ì–æ—Ç–æ–≤–æ –∑–∞ '+Math.round(t1-t0)+' –º—Å');
    }catch(e){
      toast(e.message||String(e));
    } finally {
      flushLog();
    }
  }

  /* ===== –≠–∫—Å–ø–æ—Ä—Ç (–æ–±—â–∏–π) ===== */
  function exportAggCSV(){
    if(!window.lastAgg){ toast('–°–Ω–∞—á–∞–ª–∞ —Å–æ–±–µ—Ä–∏—Ç–µ –¥–∞—à–±–æ—Ä–¥'); return; }
    var rows=[['group','total','finished','remaining_total','remaining','in_progress']];
    ORDER.forEach(function(g){
      var o=window.lastAgg[g]||{total:0,finished:0,remaining_total:0,remaining:0,in_progress:0};
      rows.push([g,o.total,o.finished,o.remaining_total,o.remaining,o.in_progress]);
    });
    var csv = rows.map(r => r.map(v=>{
      var x=(v==null?'':String(v));
      if(/[",\n]/.test(x)) x='"'+x.replace(/"/g,'""')+'"';
      return x;
    }).join(',')).join('\n');
    var blob=new Blob([csv],{type:'text/csv;charset=utf-8'});
    var url=URL.createObjectURL(blob); var a=document.createElement('a'); a.href=url; a.download='agg.csv'; a.click(); URL.revokeObjectURL(url);
  }
  function exportAggJSON(){
    if(!window.lastAgg){ toast('–°–Ω–∞—á–∞–ª–∞ —Å–æ–±–µ—Ä–∏—Ç–µ –¥–∞—à–±–æ—Ä–¥'); return; }
    var blob=new Blob([JSON.stringify(window.lastAgg,null,2)],{type:'application/json'});
        var url=URL.createObjectURL(blob); var a=document.createElement('a'); a.href=url; a.download='agg.json'; a.click(); URL.revokeObjectURL(url);
  }
  // –†–∞–∑–±–æ—Ä –∏–º–µ–Ω–∏ –ª–∞—É–Ω—á–∞: [–°—Ç—Ä–∏–º][–ü–ª–∞—Ç—Ñ–æ—Ä–º–∞][Kind] ...
function parseStreamTriple(name){
  const m = String(name||'').match(/^\[([^\]]+)\]\[(Android|iOS)\]\[(Smoke|Selective)\]/i);
  if(!m) return null;
  return { stream: m[1], platform: m[2], kind: m[3] };
}

// –°–æ–±—Ä–∞—Ç—å —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ –Ω–∞–∑–≤–∞–Ω–∏—è —Å—Ç—Ä–∏–º–æ–≤ –¥–ª—è –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ kind (Smoke/Selective)
function collectStreamNames(kind){
  const L = (window.__mini_last && window.__mini_last.launches) || [];
  const set = new Set();
  L.forEach(x=>{
    const p = parseStreamTriple(x.name||'');
    if(p && p.kind.toLowerCase() === String(kind).toLowerCase()){
      set.add(p.stream);
    }
  });
  return Array.from(set).sort((a,b)=>a.localeCompare(b,'ru'));
}

// –û–±–Ω–æ–≤–∏—Ç—å UI —Å–µ–ª–µ–∫—Ç —Å–æ —Å—Ç—Ä–∏–º–∞–º–∏
function updateStreamNamesUI(){
  const kind = $('#streamKind')?.value || 'Smoke';
  const sel  = $('#streamName');
  if(!sel) return;
  const valPrev = sel.value;
  const names = collectStreamNames(kind);
  sel.innerHTML = '<option value="__all__">‚Äî –≤—ã–±–µ—Ä–∏—Ç–µ —Å—Ç—Ä–∏–º ‚Äî</option>' +
                  names.map(n=>`<option value="${escapeHtml(n)}">${escapeHtml(n)}</option>`).join('');
  // –µ—Å–ª–∏ —Ä–∞–Ω–µ–µ –≤—ã–±—Ä–∞–Ω–Ω—ã–π –µ—Å—Ç—å ‚Äî –≤–µ—Ä–Ω—ë–º
  if(names.includes(valPrev)) sel.value = valPrev;
}

// –ü–æ—Å—á–∏—Ç–∞—Ç—å –∞–≥—Ä–µ–≥–∞—Ç –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ —Å—Ç—Ä–∏–º–∞ (–ø–æ –¥–≤—É–º –ø–ª–∞—Ç—Ñ–æ—Ä–º–∞–º) –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ç–µ–∫—É—â–∏—Ö –ª–∞—É–Ω—á–µ–π
function aggForStream(kind, streamName){
  const labels = orderForKind(kind);
  const agg = {};
  labels.forEach(l=>{ agg[l] = { total:0, finished:0, remaining_total:0, remaining:0, in_progress:0 }; });

  const L = (window.__mini_last && window.__mini_last.launches) || [];
  const FIN = (window.__mini_last && window.__mini_last.perLaunchFinished) || {};
  const TOT = (window.__mini_last && window.__mini_last.perLaunchTotal) || {};

  L.forEach(x=>{
    const p = parseStreamTriple(x.name||'');
    if(!p) return;
    if(p.kind.toLowerCase() !== String(kind).toLowerCase()) return;
    if(streamName && streamName !== '__all__' && p.stream !== streamName) return;

    const key = `[${p.platform}][${p.kind}]`;   // —Å–æ–≤–ø–∞–¥–∞–µ—Ç —Å —Ñ–æ—Ä–º–æ–π –∏–∑ ORDER
    if(!(key in agg)) return;

    const finished = Number(FIN[x.id] || 0);
    const total    = Number(TOT[x.id] || 0);
    const remaining_total = Math.max(0, total - finished);

    agg[key].total           += total;
    agg[key].finished        += finished;
    agg[key].remaining_total += remaining_total;
    // –¥–µ—Ç–∞–ª—å–Ω–æ–≥–æ –¥–µ–ª–µ–Ω–∏—è –Ω–∞ assigned/unassigned –∑–¥–µ—Å—å –Ω–µ—Ç ‚Äî —Å—á–∏—Ç–∞–µ–º –≤—Å—ë –∫–∞–∫ in_progress
    agg[key].in_progress     += remaining_total;
  });

  return agg;
}

  /* ====== –°—Ä–µ–∑—ã –ø–æ —Å—Ç—Ä–∏–º—É (Smoke / Selective) ====== */

  function orderForKind(kind){
    if(String(kind).toLowerCase()==='smoke') return ["[iOS][Smoke]","[Android][Smoke]"];
    return ["[Android][Selective]","[iOS][Selective]"];
  }

  function makeStreamSnapTitle(o){
    var ver=o.version||'all';
    return `[${o.kind}] v=${ver} ${o.timeISO}`;
  }

function takeStreamSnapshot(ctx){
  // ctx: { kind:'Smoke'|'Selective', version, timeISO }
  const kind = ctx.kind;
  const streamName = ($('#streamName')?.value) || '__all__';
  if(!streamName || streamName === '__all__'){
    toast('–í—ã–±–µ—Ä–∏—Ç–µ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π —Å—Ç—Ä–∏–º –≤ —Å–ø–∏—Å–∫–µ');
    return;
  }

  // —Å—Ç—Ä–æ–∏–º –∞–≥—Ä–µ–≥–∞—Ç —Ä–æ–≤–Ω–æ –¥–ª—è –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ —Å—Ç—Ä–∏–º–∞ (–¥–≤–µ –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã –¥–ª—è kind)
  const data = aggForStream(kind, streamName);

  var st=getStore();
  var id=String(Date.now())+Math.random().toString(16).slice(2);
  var snap={
    id,
    ts: Date.now(),
    kind,
    stream: streamName,
    title: `[${kind}] ${streamName} v=${ctx.version||'all'} ${ctx.timeISO}`,
    data
  };
  st.streamSnaps=(st.streamSnaps||[]);
  st.streamSnaps.push(snap);
  setStore(st);
  renderStreamSnapList();
  saveStoreMaybe();
  toast('–°—Ä–µ–∑ –ø–æ —Å—Ç—Ä–∏–º—É —Å–æ—Ö—Ä–∞–Ω—ë–Ω');
}

function renderStreamSnapList(){
  var box=$('#snapListDashStream'); if(!box) return; box.innerHTML='';
  var kind = $('#streamKind')?.value || 'Smoke';
  var streamName = $('#streamName')?.value || '__all__';

  var store=getStore();
  var list=(store.streamSnaps||[]).filter(s=>
    String(s.kind||'').toLowerCase()===String(kind).toLowerCase()
    && (streamName==='__all__' || s.stream===streamName)
  );

  const labels = orderForKind(kind);

  for(var i=list.length-1;i>=0;i--){
    var s=list[i];
    var totalFinished = labels.reduce(function(sum,k){
      return sum + (((s.data||{})[k]||{}).finished||0);
    }, 0);

    var row=document.createElement('div');
    row.className='snap';
    row.innerHTML='<input type="checkbox" data-id="'+s.id+'" />'+
      '<label style="flex:1;display:flex;flex-direction:column;gap:2px;min-width:0">'+
      '<span class="title">'+escapeHtml(s.title)+'</span>'+
      '<span class="meta">'+(new Date(s.ts)).toLocaleString()
      +' ‚Ä¢ —Å—Ç—Ä–∏–º: '+escapeHtml(s.stream||'‚Äî')
      +' ‚Ä¢ –≤—Å–µ–≥–æ –ø—Ä–æ–π–¥–µ–Ω–æ: '+totalFinished.toLocaleString('ru-RU')+'</span></label>'+
      '<button class="del" data-id="'+s.id+'">–£–¥–∞–ª–∏—Ç—å</button>';
    box.appendChild(row);
  }
  var dels=box.querySelectorAll('.del');
  for(var d=0;d<dels.length;d++){
    dels[d].addEventListener('click', function(){
      var id=this.getAttribute('data-id'); var st=getStore();
      st.streamSnaps=(st.streamSnaps||[]).filter(function(x){return x.id!==id});
      setStore(st); renderStreamSnapList();
    });
  }
}

  function buildDashMultiCompareStream(opts){
  const silent = !!(opts && opts.silent);

  var metric=$('#dashMetricStream')?.value || 'finished';
  var kind = $('#streamKind')?.value || 'Smoke';
  var streamName = $('#streamName')?.value || '__all__';
  const labels=orderForKind(kind);

  var chosen=[].slice.call(document.querySelectorAll('#snapListDashStream input[type=checkbox]:checked'))
               .map(cb=>cb.getAttribute('data-id'));

  var snaps=(getStore().streamSnaps||[]).filter(s=>
    chosen.indexOf(s.id)!==-1
    && String(s.kind||'').toLowerCase()===String(kind).toLowerCase()
    && (streamName==='__all__' || s.stream===streamName)
  );

  if(!snaps.length){
    if(!silent) toast('–í—ã–±–µ—Ä–∏—Ç–µ —Å—Ä–µ–∑—ã (—Å—Ç—Ä–∏–º)');
    return;
  }

  const palette = ['#7a3af9','#00c48c','#ffb020','#ff5aad','#3b82f6','#10b981','#f59e0b','#ef4444','#8b5cf6','#14b8a6'];
  const datasets = snaps.map((s, i)=>{
    const col = palette[i % palette.length];
    return {
      key: metric,
      label: prettySnapTitle(s.title || ('–°—Ä–µ–∑ '+(i+1))),
      data: labels.map(k => ((s.data||{})[k]||{})[metric] || 0),
      backgroundColor: hexA(col,.85),
      borderColor: col
    };
  });

  var wrap = document.getElementById('dashMultiBarStream')?.parentElement;
  if(wrap){
    var extra = Math.max(0, datasets.length - 6);
    wrap.style.height = Math.min(900, 320 + extra*24) + 'px';
  }

  makeBarChart('dashMultiBarStream', labels, datasets);
}

// NEW: –∞–≤—Ç–æ—Å–±–æ—Ä –≤—Å–µ—Ö –ø–æ—Å—Ç—Ä–∏–º–æ–≤—ã—Ö —Å—Ä–µ–∑–æ–≤ (–¥–ª—è Smoke –∏ Selective)
function autoSaveAllStreamSnaps(){
  // –ù—É–∂–Ω—ã –∞–∫—Ç—É–∞–ª—å–Ω—ã–µ –ª–∞—É–Ω—á–∏/–ø–µ—Ä-–º–µ—Ç—Ä–∏–∫–∏ (–∑–∞–ø–æ–ª–Ω—è—é—Ç—Å—è –≤ runDashboard)
  const launchesOk = window.__mini_last && Array.isArray(window.__mini_last.launches) && window.__mini_last.launches.length;
  if(!launchesOk) return;

  const version = ($('#version')?.value.trim())||'';
  const timeISO = (new Date()).toISOString();

  const kinds = ['Smoke','Selective'];
  const newSnaps = [];

  kinds.forEach(kind=>{
    const names = collectStreamNames(kind); // —Å–æ–±–µ—Ä—ë–º —Å–ø–∏—Å–æ–∫ –Ω–∞–∑–≤–∞–Ω–∏–π —Å—Ç—Ä–∏–º–æ–≤ –ø–æ —Ç–µ–∫—É—â–∏–º –ª–∞—É–Ω—á–∞–º
    names.forEach(streamName=>{
      // –∞–≥—Ä–µ–≥–∞—Ç –í –°–ï–ö–¶–ò–ò ¬´–ü–æ —Å—Ç—Ä–∏–º—É¬ª –≤—Å–µ–≥–¥–∞ ¬´–¥–≤–µ –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã –¥–ª—è –æ–¥–Ω–æ–≥–æ kind¬ª ‚Äî –∏–∑ —Ç–µ–∫—É—â–∏—Ö –ª–∞—É–Ω—á–µ–π
      const data = aggForStream(kind, streamName);

      // —Å—Ñ–æ—Ä–º–∏—Ä—É–µ–º —Å–Ω–µ–ø—à–æ—Ç
      newSnaps.push({
        id: String(Date.now())+Math.random().toString(16).slice(2),
        ts: Date.now(),
        kind,
        stream: streamName,
        title: `[${kind}] ${streamName} v=${version} ${timeISO}`,
        data
      });
    });
  });

  if(!newSnaps.length) return;

  // –µ–¥–∏–Ω–æ—Ä–∞–∑–æ–≤–æ –ø–æ–ª–æ–∂–∏–º –≤ store –∏ –ø–µ—Ä–µ—Ä–∏—Å—É–µ–º —Å–ø–∏—Å–æ–∫ ¬´–ü–æ —Å—Ç—Ä–∏–º—É¬ª
  const st = getStore();
  st.streamSnaps = (st.streamSnaps||[]).concat(newSnaps);
  setStore(st);
  renderStreamSnapList();
  saveStoreMaybe();
  // –±–µ–∑ –Ω–∞–≤—è–∑—á–∏–≤–æ–≥–æ —Ç–æ—Å—Ç–∞ ‚Äî —Å–æ—Ö—Ä–∞–Ω—è–µ–º ¬´—Ç–∏—Ö–æ¬ª, –Ω–æ –º–æ–∂–Ω–æ –≤–∫–ª—é—á–∏—Ç—å –ø—Ä–∏ –∂–µ–ª–∞–Ω–∏–∏:
  // toast('–ê–≤—Ç–æ—Å—Ä–µ–∑—ã –ø–æ —Å—Ç—Ä–∏–º–∞–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã');
}

function renderDashPrevCurrentStream(currentAggAll, metric){
  var kind = $('#streamKind')?.value || 'Smoke';
  var streamName = $('#streamName')?.value || '__all__';
  const labels=orderForKind(kind);

  // –¢–µ–∫—É—â–∞—è ‚Äú–æ–Ω–ª–∞–π–Ω‚Äù –∫–∞—Ä—Ç–∏–Ω–∞ ‚Äî –ø–æ –¥–∞–Ω–Ω—ã–º –ª–∞—É–Ω—á–µ–π, –Ω–æ —Ç–æ–ª—å–∫–æ –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ —Å—Ç—Ä–∏–º–∞
  const currentAgg = aggForStream(kind, streamName);

  metric=metric||'finished'; var color=COLORS[metric]||COLORS.finished;

  // –ø—Ä–µ–¥—ã–¥—É—â–∏–π ‚Äî –∏–∑ —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã—Ö –ø–æ—Å—Ç—Ä–∏–º–æ–≤—ã—Ö —Å—Ä–µ–∑–æ–≤ –ø–æ –≤—ã–±—Ä–∞–Ω–Ω–æ–º—É —Å—Ç—Ä–∏–º—É
  var list=(getStore().streamSnaps||[]).filter(s=>
    String(s.kind||'').toLowerCase()===String(kind).toLowerCase()
    && (streamName==='__all__' || s.stream===streamName)
  );
  var prev=list.length>0?list[list.length-1]:null;

  var currData=labels.map(function(k){ return (currentAgg[k]&&currentAgg[k][metric])||0; });
  var prevData=labels.map(function(k){ return (prev&&prev.data&&prev.data[k]&&prev.data[k][metric])?prev.data[k][metric]:0; });
  var deltas = currData.map(function(v,i){ return v - (prevData[i]||0); });

  var box=$('#dashDeltaStream');
  if(box){
    box.innerHTML='';
    for(var i=0;i<labels.length;i++){
      var d=deltas[i]; var sign=d>0?'+':'';
      var item=document.createElement('div'); item.className='kpi';
      item.innerHTML='<span class="label">'+labels[i]+' ‚Äî Œî</span><span class="val">'+sign+d.toLocaleString('ru-RU')+'</span>';
      box.appendChild(item);
    }
  }

  var dsPrev = {key:metric, label:'–ü—Ä–µ–¥—ã–¥—É—â–∏–π', data:prevData, backgroundColor:hexA(color,.35), borderColor:color};
  var dsCurr = {key:metric, label:'–¢–µ–∫—É—â–∏–π',   data:currData, backgroundColor:hexA(color,.85), borderColor:color};
  dsCurr.__delta = deltas;

  makeBarChart('dashPrevCurrStream', labels, [dsPrev, dsCurr]);
}

  /* ===== –†–ê–ù-–æ—Ç—á—ë—Ç (API/Excel) ===== */
  let RUN_SWAT = new Set();
  function parseSwatFile(file){ return new Promise((resolve,reject)=>{ if(!file){ resolve(new Set()); return; } const fr=new FileReader(); fr.onload=()=>{ const text=(fr.result||'').toString(); const lines=text.split(/\r?\n/).map(s=>s.trim()).filter(Boolean); resolve(new Set(lines)); }; fr.onerror=()=>reject(fr.error||new Error('–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è SWAT.txt')); fr.readAsText(file); }); }
  function readExcel(file){ return new Promise((resolve,reject)=>{ if(!file){ resolve({rows:[], headers:[]}); return; } const fr=new FileReader(); fr.onload=()=>{ try{ const data=new Uint8Array(fr.result); const wb=XLSX.read(data,{type:'array'}); const ws=wb.Sheets[wb.SheetNames[0]]; const json=XLSX.utils.sheet_to_json(ws,{defval:''}); const headers=Object.keys(json[0]||{}); resolve({rows:json,headers}); }catch(e){ reject(e); } }; fr.onerror=()=>reject(fr.error||new Error('–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è Excel')); fr.readAsArrayBuffer(file); }); }
  function guessCol(headers, variants){ const lc=headers.map(h=>String(h).toLowerCase()); for(let i=0;i<lc.length;i++){ for(const v of variants){ if(lc[i].includes(v)) return headers[i]; } } return null; }

  function buildRunReportTableExcel(rows, opts){
    const headers = Object.keys(rows[0]||{});
    const colOwner = guessCol(headers, ['owner','assignee','–∏—Å–ø–æ–ª–Ω','–æ—Ç–≤–µ—Ç—Å—Ç–≤','login','–ª–æ–≥–∏–Ω','author']);
    const colType  = guessCol(headers, ['type','—Ç–∏–ø','auto','manual','–∞–≤—Ç–æ','—Ä—É—á–Ω']);
    const colCase  = guessCol(headers, ['case','id','–∫–ª—é—á','test','—Ç–µ—Å—Ç']);
    const colStatus= guessCol(headers, ['status','—Å—Ç–∞—Ç—É—Å','result','—Ä–µ–∑—É–ª—å—Ç']);
    const norm=(v)=>String(v||'').trim();
    function isAuto(v){ const s=norm(v).toLowerCase(); return s.includes('auto')||s.includes('–∞–≤—Ç–æ'); }
    function isManual(v){ const s=norm(v).toLowerCase(); return s.includes('manual')||s.includes('—Ä—É—á–Ω'); }
    let data=rows.map(r=>({ owner:colOwner?norm(r[colOwner]):'', type:colType?norm(r[colType]):'', id:colCase?norm(r[colCase]):'', status:colStatus?norm(r[colStatus]):'' }));
    data=data.filter(d=>{ if(opts.typeFilter==='auto') return isAuto(d.type); if(opts.typeFilter==='manual') return isManual(d.type); return true; });
    const agg={}; data.forEach(d=>{ const owner=d.owner||'(unknown)'; if(!agg[owner]) agg[owner]={total:0,passed:0,failed:0,cases:[]}; agg[owner].total++; const st=d.status.toLowerCase(); if(st.includes('pass')||st.includes('–ø—Ä–æ–π–¥–µ–Ω')) agg[owner].passed++; else if(st) agg[owner].failed++; agg[owner].cases.push(d); });
    if(RUN_SWAT.size){ const filtered={}; Object.keys(agg).forEach(owner=>{ if(RUN_SWAT.has(owner)) filtered[owner]=agg[owner]; }); if(Object.keys(filtered).length) Object.assign(agg, filtered); }
    const arr=Object.entries(agg).map(([owner,v])=>({owner,...v})); arr.sort((a,b)=>b.total-a.total);
    return {table:arr.slice(0,Math.min(opts.topN||50,150))};
  }

  function renderRunTableExcel(table){
    const el=$('#runTable'); if(!el){return;}
    if(!table.length){ el.innerHTML='<tr><td>–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è</td></tr>'; return; }
    el.innerHTML='';
    const thead=document.createElement('thead');
    thead.innerHTML='<tr><th>–ò—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å</th><th>–í—Å–µ–≥–æ</th><th>–ü—Ä–æ–π–¥–µ–Ω–æ</th><th>–ü—Ä–æ–≤–∞–ª–µ–Ω–æ</th></tr>';
    el.appendChild(thead);
    const tb=document.createElement('tbody');
    table.forEach(r=>{
      const ok=r.passed>0; const cls=ok?'pill-ok':'pill-bad'; const lineCls=ok?'line-ok':'line-bad';
      const tr=document.createElement('tr');
      tr.innerHTML =
        '<td class="'+lineCls+'">'+escapeHtml(r.owner)+'</td>'+
        '<td>'+r.total+'</td>'+
        '<td><span class="pill '+cls+'">'+r.passed+'</span></td>'+
        '<td>'+r.failed+'</td>';
      tb.appendChild(tr);
    });
    el.appendChild(tb);
  }

  function setRunProgress(pct, infoText){
    var pb=$('#runProgressBar'); if(pb){ pb.style.width=Math.max(0,Math.min(100,Math.round(pct)))+'%'; }
    if(infoText!=null){ $('#runInfo').textContent=infoText; }
  }
  function msToHmm(ms){ var m=Math.floor(ms/60000); return (Math.floor(m/60))+'.'+String(m%60).padStart(2,'0'); }
  function msToMss(ms){ var s=Math.floor(ms/1000); return (Math.floor(s/60))+':'+String(s%60).padStart(2,'0'); }

  const COMPLETED_STATUSES = COMPLETED;
  function sumCompletedFromStatisticList(list){ return sumByStatuses(list, COMPLETED_STATUSES); }

  async function fetchAutomatedTotal(baseUrl, id, headers){
    const search = b64Utf8(JSON.stringify([{ id:'automated', type:'boolean', value:true }]));
    const leafAuto = await fetchLeafCount(baseUrl, id, headers, search).catch(()=>0);
    if (leafAuto > 0) return leafAuto;

    const urlGroup = baseUrl + '/api/testresulttree/group';
    const size = 2000;
    let page = 0, autoTotal = 0;
    while (true){
      const params = { launchId:id, treeId:14, search, sort:'duration,asc', size, page };
      const data = await fetchJson(urlGroup, params, headers).catch(()=>null);
      const content = (data && data.content) || [];
      if (!content.length) break;
      for (const g of content){
        const st = g?.statistic || {};
        const t = (st.total != null)
          ? Number(st.total||0)
          : (Number(st.passed||0)+Number(st.failed||0)+Number(st.broken||0)+Number(st.skipped||0));
        autoTotal += t;
      }
      if (content.length < size) break;
      page += 1;
      if (page > 400) break;
    }
    return autoTotal;
  }

  let RUN_ALL_ROWS = [];
  let RUN_FILTERED = [];

  function updateRunTotals(rows){
    const totalAuto = rows.reduce((s,r)=>s+Number(r.auto||0),0);
    const totalManual = rows.reduce((s,r)=>s+Math.max(0, Number(r.total||0)-Number(r.auto||0)),0);
    const el=$('#runTotals');
    if(el) el.textContent = `–ò—Ç–æ–≥–æ –ø–æ —Ñ–∏–ª—å—Ç—Ä—É: —Ä—É—á–Ω—ã–µ = ${totalManual.toLocaleString('ru-RU')}, –∞–≤—Ç–æ = ${totalAuto.toLocaleString('ru-RU')}`;
  }

  function makeRunBarChart(rows){
    const canvas = $('#runChart');
    if(!canvas) return;

    const barH = 28;
    const pad  = 80;
    const desiredH = Math.max(320, rows.length * barH + pad);
    const wrap = $('#runChartWrap');
    if (wrap) wrap.style.height = desiredH + 'px';

    const labels     = rows.map(r=>r.name);
    const dataSwat   = rows.map(r=>r.swat_total||0);
    const dataStream = rows.map(r=>r.stream_total||0);
    const dataAuto   = rows.map(r=>r.auto||0);

    function maker(){
      fitHiDPICanvas(canvas);
      const ctx = makeCtx(canvas);
      if(window.__charts['runChart']?.chart){
        try{ window.__charts['runChart'].chart.destroy(); }catch(e){}
      }

      const chart = new Chart(ctx,{
        type:'bar',
        data:{
          labels,
          datasets:[
            {
              label:'–ü—Ä–æ–π–¥–µ–Ω–æ SWAT',
              data:dataSwat,
              backgroundColor: hexA(getCSS('--c2'), .85),
              borderColor: getCSS('--c2'),
              borderWidth:1.5, borderRadius:6, borderSkipped:false
            },
            {
              label:'–ü—Ä–æ–π–¥–µ–Ω–æ STREAM',
              data:dataStream,
              backgroundColor: hexA(getCSS('--c3'), .85),
              borderColor: getCSS('--c3'),
              borderWidth:1.5, borderRadius:6, borderSkipped:false
            },
            {
              type:'line',
              label:'–ê–≤—Ç–æ –∫–µ–π—Å—ã',
              data:dataAuto,
              borderColor:getCSS('--c1'),
              backgroundColor:hexA(getCSS('--c1'), .15),
              borderWidth:2,
              pointRadius:3,
              pointHoverRadius:4,
              tension:0.3
            }
          ]
        },
        options:{
          indexAxis:'y',
          maintainAspectRatio:false,
          responsive:true,
          animation:false,
          layout:{ padding:{top:8,right:8,bottom:8,left:8} },
          plugins:{
            legend:{ position:'bottom' },
            tooltip:{
              mode:'nearest',
              intersect:false,
              callbacks:{
                footer:(items)=>{
                  const i=items[0].dataIndex;
                  const sw=Number(dataSwat[i]||0), st=Number(dataStream[i]||0);
                  return '–í—Å–µ–≥–æ –ø—Ä–æ–π–¥–µ–Ω–æ: '+(sw+st);
                }
              }
            }
          },
          scales:{
            x:{ beginAtZero:true, grid:{ color:'rgba(148,163,184,.2)' } },
            y:{ grid:{display:false} }
          }
        }
      });

      window.__charts['runChart']={chart, maker};
    }

    maker();
  }

  function renderRunTableAPI(rows){
    const el=$('#runTable'); if(!el) return;
    if(!rows.length){ el.innerHTML='<tr><td>–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö</td></tr>'; return; }
    el.innerHTML='';
    const thead=document.createElement('thead');
    thead.innerHTML='<tr><th>–û—Ç–¥–µ–ª</th><th>–†–ê–ù</th><th>–∫-–≤–æ –∫–µ–π—Å–æ–≤</th><th>–∫-–≤–æ –ê–≤—Ç–æ</th><th>–ü—Ä–æ–π–¥–µ–Ω–æ SWAT</th><th>–ü—Ä–æ–π–¥–µ–Ω–æ STREAM</th><th>–°–æ—Ç—Ä.SWAT</th><th>–°–æ—Ç—Ä.STREAM</th><th>% –ø–æ–∫—Ä—ã—Ç–∏—è SWAT (—Ä—É—á–Ω.)</th><th>–ß–ß SWAT</th><th>–ß–ß STREAM</th><th>–í—Ä–µ–º—è/–∫–µ–π—Å SWAT</th><th>–í—Ä–µ–º—è/–∫–µ–π—Å STREAM</th></tr>';
    el.appendChild(thead);
    const tb=document.createElement('tbody');
    rows.forEach(r=>{
      const ok = r.swat_total>0;
      const cls = ok?'line-ok':'line-bad';
      const tr=document.createElement('tr');
      const ranCell = '<a href="'+r.link+'" target="_blank" class="'+cls+'" style="text-decoration:none">'+escapeHtml(r.name)+'</a>';
      tr.innerHTML =
        '<td>'+escapeHtml(r.dept)+'</td>'+
        '<td>'+ranCell+'</td>'+
        '<td>'+r.total+'</td>'+
        '<td>'+r.auto+'</td>'+
        '<td>'+r.swat_total+'</td>'+
        '<td>'+r.stream_total+'</td>'+
        '<td>'+r.swat_people+'</td>'+
        '<td>'+r.stream_people+'</td>'+
        '<td>'+r.swat_cover.toFixed(2)+'%</td>'+
        '<td>'+r.swat_hh+'</td>'+
        '<td>'+r.stream_hh+'</td>'+
        '<td>'+r.swat_per+'</td>'+
        '<td>'+r.stream_per+'</td>';
      tb.appendChild(tr);
    });
    el.appendChild(tb);
    window.__run_api_rows = rows;
  }

  function exportRunCsvFromApi(){
    const rows = window.__run_api_rows || [];
    if(!rows.length){ toast('–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —ç–∫—Å–ø–æ—Ä—Ç–∞'); return; }
    const headers = ['dept','name','link','total','auto','swat_total','stream_total','swat_people','stream_people','swat_cover','swat_hh','stream_hh','swat_per','stream_per'];
    const out = [headers.join(',')].concat(rows.map(r=>[
      JSON.stringify(r.dept), JSON.stringify(r.name), JSON.stringify(r.link),
      r.total, r.auto, r.swat_total, r.stream_total, r.swat_people, r.stream_people,
      r.swat_cover, JSON.stringify(r.swat_hh), JSON.stringify(r.stream_hh),
      JSON.stringify(r.swat_per), JSON.stringify(r.stream_per)
    ].join(',')));
    const blob=new Blob([out.join('\n')],{type:'text/csv;charset=utf-8;'});
    const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='run_report_api.csv'; a.click(); URL.revokeObjectURL(url);
  }

  async function buildRunReportAPI(){
    const baseUrl=($('#baseUrl')?.value||'').trim().replace(/\/$/,'');
    const projectId=($('#projectId')?.value||'').trim();
    const version=($('#version')?.value||'').trim();
    const token=($('#token')?.value||'').trim();
    if(!baseUrl||!projectId||!token||!version){
      toast('–î–ª—è –†–ê–ù-–æ—Ç—á—ë—Ç–∞ –ø–æ API –∑–∞–ø–æ–ª–Ω–∏—Ç–µ Base URL, Project ID, —Ç–æ–∫–µ–Ω –∏ –≤–µ—Ä—Å–∏—é');
      throw new Error('missing params');
    }
    const headers={Accept:'application/json', Authorization:'Api-Token '+token, 'User-Agent':'allure-run-report/web'};

    $('#runLog').textContent='';
    $('#runLogInfo').textContent='–ó–∞–ø—É—Å–∫–æ–≤ 0 –∏–∑ 0';
    setRunProgress(0,'–ó–∞–≥—Ä—É–∑–∫–∞ —Ä–∞–Ω–æ–≤‚Ä¶');

    const log=(s)=>{ const el=$('#runLog'); el.textContent+=s+'\n'; el.scrollTop=el.scrollHeight; };

    const [smoke, selective] = await Promise.all([
      fetchLaunches(baseUrl, projectId, version, true,  false, headers, 8, 1000, (m)=>log(m)),
      fetchLaunches(baseUrl, projectId, version, false, true,  headers, 8, 1000, (m)=>log(m))
    ]);
    const launches = smoke.concat(selective);
    $('#runLogInfo').textContent='–ó–∞–ø—É—Å–∫–æ–≤ 0 –∏–∑ '+launches.length;

    const rows = [];
    let done=0;

    await pMap(
      launches.sort((a,b)=> (deptOf(a.name)||'z').localeCompare(deptOf(b.name)||'z')),
      async (L)=>{
        const id=L.id, name=L.name||('#'+id);

        const [stat, mstats, autoTotal] = await Promise.all([
          fetchStat(baseUrl, id, headers),
          fetchMemberStats(baseUrl, id, headers),
          fetchAutomatedTotal(baseUrl, id, headers).catch(()=>0)
        ]);

        const counts = computeCountsExact(stat);
        const total0 = Number(counts.total||0);
        const auto   = Number(autoTotal||0);
        const total  = Math.max(total0, auto);

        let swat_total=0, stream_total=0, swat_people=new Set(), stream_people=new Set(), swat_ms=0, stream_ms=0;

        for (const m of (mstats||[])){
          const assignee=(m.assignee||'').trim();
          const dur=Number(m.durationSum||0);
          const cnt = sumCompletedFromStatisticList(m.statistic);
          if (cnt<=0 && dur<=0) continue;

          if (RUN_SWAT.has(assignee)){
            swat_total+=cnt; swat_people.add(assignee); swat_ms+=dur;
          } else {
            stream_total+=cnt; stream_people.add(assignee); stream_ms+=dur;
          }
        }

        const manual_total = Math.max(total - auto, 0);
        const swat_cover = manual_total > 0 ? +(swat_total/manual_total*100).toFixed(2) : 0;
        const swat_per   = swat_total   > 0 ? Math.floor(swat_ms   / swat_total)   : 0;
        const stream_per = stream_total > 0 ? Math.floor(stream_ms / stream_total) : 0;

        rows.push({
          dept: deptOf(name), name, link: baseUrl+'/launch/'+id,
          total, auto, swat_total, stream_total,
          swat_people: swat_people.size, stream_people: stream_people.size,
          swat_cover,
          swat_hh: msToHmm(swat_ms), stream_hh: msToHmm(stream_ms),
          swat_per: msToMss(swat_per), stream_per: msToMss(stream_per)
        });

        log(`[LAUNCH] #${id} total=${total} auto=${auto} manual=${manual_total} swat=${swat_total} (${swat_people.size}) ${msToHmm(swat_ms)}—á | stream=${stream_total} (${stream_people.size}) ${msToHmm(stream_ms)}—á | ${name}`);

        done++;
        if(done%2===0){
          setRunProgress(Math.round(done*100/Math.max(1,launches.length)), `–û–±—Ä–∞–±–æ—Ç–∫–∞: ${done} –∏–∑ ${launches.length}`);
          $('#runLogInfo').textContent='–ó–∞–ø—É—Å–∫–æ–≤ '+done+' –∏–∑ '+launches.length;
        }
      },
      {concurrency: 8}
    );

    RUN_ALL_ROWS = rows;
    applyRunFiltersAndRender();
    setRunProgress(100,'–ì–æ—Ç–æ–≤–æ');
  }

  function applyRunFiltersAndRender(){
    const nameQ = ($('#runFilterName')?.value||'').trim().toLowerCase();
    const dept = ($('#runFilterDept')?.value||'all');
    const minCnt = Math.max(0, parseInt($('#runFilterMin')?.value||'0',10)||0);
    const sort = ($('#runSort')?.value||'total_desc');
    const topN = Math.min(parseInt($('#runTopN').value||'50',10),150);

    let rows = RUN_ALL_ROWS.slice();
    if(nameQ) rows = rows.filter(r => (r.name||'').toLowerCase().includes(nameQ));
    if(dept !== 'all') rows = rows.filter(r => (r.dept||'') === dept);
    if(minCnt>0) rows = rows.filter(r => Number(r.total||0) >= minCnt);

    rows.sort((a,b)=>{
      if(sort==='name_asc') return (a.name||'').localeCompare(b.name||'');
      if(sort==='auto_desc') return (b.auto||0)-(a.auto||0) || (b.total||0)-(a.total||0);
      return (b.total||0)-(a.total||0) || (b.auto||0)-(a.auto||0);
    });

    rows = rows.slice(0, topN);

    RUN_FILTERED = rows;

    renderRunTableAPI(rows);
    makeRunBarChart(rows);
    updateRunTotals(rows);
  }

  /* ====== –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏/–∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è ====== */

  // –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π –ø–µ—Ä–µ–∫–ª—é—á–∞—Ç–µ–ª—å —Ç–∞–±–æ–≤
  function showTab(tab) {
    var all = ['Dash','Run','Swat','Vang','Create','Chp','Calc'];
    var key = String(tab || 'dash').toLowerCase();
    all.forEach(function (suffix) {
      var btn = document.getElementById('tab' + suffix + 'Btn');
      var sec = document.getElementById('tab' + suffix);
      var active = (suffix.toLowerCase() === key);
      if (btn) btn.classList.toggle('active', active);
      if (sec) sec.style.display = active ? 'block' : 'none';
    });
    var panel = document.querySelector('.panel.card');
    if (panel) {
      panel.style.display = (key === 'dash') ? '' : 'none';
    }
  }

  // –û—Å–Ω–æ–≤–Ω—ã–µ —Ç–∞–±—ã
  $('#tabDashBtn')?.addEventListener('click', () => showTab('dash'));
  $('#tabRunBtn')?.addEventListener('click', () => showTab('run'));

  // –ü–æ–¥—Ç–∞–±—ã —Å—Ä–µ–∑–æ–≤
  function setSubtab(which){
    const g = (which==='general');
    $('#subtabGeneral').classList.toggle('active', g);
    $('#subtabStream').classList.toggle('active', !g);
    $('#snapGeneralSection').style.display = g ? 'block' : 'none';
    $('#snapStreamSection').style.display  = g ? 'none' : 'block';
  }
  $('#subtabGeneral')?.addEventListener('click', ()=> setSubtab('general'));
  $('#subtabStream')?.addEventListener('click', ()=> { setSubtab('stream'); renderStreamSnapList(); buildDashMultiCompareStream({silent:true}); if(window.lastAgg){ renderDashPrevCurrentStream(window.lastAgg, $('#dashMetricStream')?.value||'finished'); } });

  // –ú–∏–Ω–∏-–¥–∏–∞–≥—Ä–∞–º–º—ã
  $('#miniToggleBtn')?.addEventListener('click', ()=>{
    const wrap = $('#miniWrap');
    const shown = wrap.style.display!=='none';
    wrap.style.display = shown ? 'none' : 'block';
    $('#miniToggleBtn').textContent = shown ? '–ü–æ–∫–∞–∑–∞—Ç—å' : '–°–∫—Ä—ã—Ç—å';
    if(!shown) rebuildMini();
  });
  $('#miniCount')?.addEventListener('change', rebuildMini);
  $('#miniSortKey')?.addEventListener('change', rebuildMini);
  $('#miniSortDir')?.addEventListener('change', rebuildMini);
  $('#miniDept')?.addEventListener('change', rebuildMini);
  $('#miniPlatform')?.addEventListener('change', rebuildMini);

  // –ê–≤—Ç–æ—Å—Ç–∞—Ä—Ç
  $('#autoStart')?.addEventListener('click', ()=>{
    const mins = Math.max(1, parseInt($('#autoMins')?.value||'20',10)||20);
    if(window.__autoTimer){ clearInterval(window.__autoTimer); }
    runDashboard();
    window.__autoTimer = setInterval(runDashboard, mins*60*1000);
    setAutoState(true);
  });
  $('#autoStop')?.addEventListener('click', ()=>{
    if(window.__autoTimer) clearInterval(window.__autoTimer);
    window.__autoTimer = null; setAutoState(false);
  });

  // –ö–Ω–æ–ø–∫–∏ –¥–∞–Ω–Ω—ã—Ö
  $('#dataPick')?.addEventListener('click', pickDataFile);
  $('#dataCreate')?.addEventListener('click', createDataFile);
  $('#dataSave')?.addEventListener('click', saveStoreMaybe);
  $('#dataImportBtn')?.addEventListener('click', ()=>$('#dataImport')?.click());
  $('#dataImport')?.addEventListener('change', async (e)=>{
    const file = e.target.files && e.target.files[0]; if(!file) return;
    try{
      const text = await file.text();
      const obj  = JSON.parse(text||'{}');
      setStore({ ...STORE_DEFAULT, ...obj });
      renderSnapList(); renderStreamSnapList();
      toast('–ò–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–æ');
    }catch(err){ toast('–û—à–∏–±–∫–∞ –∏–º–ø–æ—Ä—Ç–∞: '+(err.message||err)); }
  });
  $('#dataExportBtn')?.addEventListener('click', ()=>{
    const blob=new Blob([JSON.stringify(getStore(),null,2)],{type:'application/json'});
    const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='regress-data.json'; a.click(); URL.revokeObjectURL(url);
  });
  $('#dataExportCsv')?.addEventListener('click', exportSnapsCSV);

  // –≠–∫—Å–ø–æ—Ä—Ç –≥—Ä–∞—Ñ–∏–∫–æ–≤/–∞–≥–≥—Ä–µ–≥–∞—Ü–∏–π
  $('#expAggCsv')?.addEventListener('click', exportAggCSV);
  $('#expAggJson')?.addEventListener('click', exportAggJSON);

  // –°—Ä–µ–∑—ã (–æ–±—â–∏–µ)
  renderSnapList();
  $('#dashMetric')?.addEventListener('change', ()=>{ if(window.lastAgg) renderDashPrevCurrent(window.lastAgg, $('#dashMetric')?.value||'finished'); });
  // –°—Ä–µ–∑—ã (—Å—Ç—Ä–∏–º)
  renderStreamSnapList();
  $('#dashMetricStream')?.addEventListener('change', ()=>{ if(window.lastAgg) renderDashPrevCurrentStream(window.lastAgg, $('#dashMetricStream')?.value||'finished'); });
// –ü—Ä–∏ —Å–º–µ–Ω–µ –≤–∏–¥–∞ —Å—Ç—Ä–∏–º–∞ ‚Äî –æ–±–Ω–æ–≤–ª—è–µ–º —Å–ø–∏—Å–æ–∫ –Ω–∞–∑–≤–∞–Ω–∏–π –∏ –ø–µ—Ä–µ—Ä–∏—Å–æ–≤—ã–≤–∞–µ–º
$('#streamKind')?.addEventListener('change', ()=>{
  updateStreamNamesUI();
  renderStreamSnapList();
  buildDashMultiCompareStream({silent:true});
  if(window.lastAgg) renderDashPrevCurrentStream(window.lastAgg, $('#dashMetricStream')?.value||'finished');
});

// –ü—Ä–∏ –≤—ã–±–æ—Ä–µ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ —Å—Ç—Ä–∏–º–∞ ‚Äî —Ñ–∏–ª—å—Ç—Ä—É–µ–º –∏ –ø–µ—Ä–µ—Ä–∏—Å–æ–≤—ã–≤–∞–µ–º
$('#streamName')?.addEventListener('change', ()=>{
  renderStreamSnapList();
  buildDashMultiCompareStream({silent:true});
  if(window.lastAgg) renderDashPrevCurrentStream(window.lastAgg, $('#dashMetricStream')?.value||'finished');
});

// –ü—Ä–∏ —Å–±–æ—Ä–∫–µ –¥–∞—à–±–æ—Ä–¥–∞ ‚Äî –∫–æ–≥–¥–∞ –µ—Å—Ç—å —Å–ø–∏—Å–æ–∫ –ª–∞—É–Ω—á–µ–π ‚Äî –Ω–∞–ø–æ–ª–Ω–∏–º —Å–µ–ª–µ–∫—Ç —Å—Ç—Ä–∏–º–æ–≤
// (–¥–æ–±–∞–≤—å –≤ –∫–æ–Ω—Ü–µ runDashboard(), —Å—Ä–∞–∑—É –ø–æ—Å–ª–µ window.__mini_last = {...};)

  // –ö–Ω–æ–ø–∫–∏ —Å—Ä–µ–∑–æ–≤
  $('#dashSnapBuild')?.addEventListener('click', ()=>buildDashMultiCompare({silent:false}));
  $('#dashStreamSnapBuild')?.addEventListener('click', ()=>buildDashMultiCompareStream({silent:false}));
  $('#dashStreamSnapSave')?.addEventListener('click', ()=>{
    if(!window.lastAgg){ toast('–°–Ω–∞—á–∞–ª–∞ —Å–æ–±–µ—Ä–∏—Ç–µ –¥–∞—à–±–æ—Ä–¥'); return; }
    const kind = $('#streamKind')?.value || 'Smoke';
    takeStreamSnapshot({ kind, version:($('#version')?.value.trim())||'', timeISO:(new Date()).toISOString(), data: window.lastAgg });
  });
  $('#dashStreamSnapClear')?.addEventListener('click', ()=>{
    var st=getStore(); var kind=$('#streamKind')?.value||'Smoke';
    st.streamSnaps=(st.streamSnaps||[]).filter(s=> String(s.kind||'').toLowerCase()!==String(kind).toLowerCase());
    setStore(st); renderStreamSnapList(); toast('–°—Ä–µ–∑—ã —Å—Ç—Ä–∏–º–∞ –æ—á–∏—â–µ–Ω—ã');
  });

  // –ö–Ω–æ–ø–∫–∏ –†–ê–ù-–æ—Ç—á—ë—Ç–∞
  $('#runBuildBtn')?.addEventListener('click', async ()=>{
    try{
      RUN_SWAT = await parseSwatFile($('#runSwat')?.files?.[0]||null);
      const excelFile = $('#runExcel')?.files?.[0]||null;
      if(excelFile){
        const {rows} = await readExcel(excelFile);
        const typeF = $('#runType')?.value || 'all';
        const topN  = Number($('#runTopN')?.value||50);
        const t0 = performance.now();
        const {table} = buildRunReportTableExcel(rows, {typeFilter:typeF, topN});
        const dt = performance.now()-t0;
        $('#runInfo').textContent = `Excel: –∑–∞–ø–∏—Å–µ–π ${rows.length}, –ø–æ–∫–∞–∑–∞–Ω–æ ${table.length} (–∑–∞ ${Math.round(dt)} –º—Å)`;
        renderRunTableExcel(table);
        RUN_ALL_ROWS = []; RUN_FILTERED = [];
        makeRunBarChart([]); updateRunTotals([]);
      }else{
        await buildRunReportAPI();
      }
    }catch(err){
      toast(err.message||String(err));
    }
  });
// –ö–Ω–æ–ø–∫–∏ —ç–∫—Å–ø–æ—Ä—Ç–∞ –∏ —Ñ–∏–ª—å—Ç—Ä–æ–≤
$('#runExportCsvBtn')?.addEventListener('click', exportRunCsvFromApi);
$('#runExportXlsxBtn')?.addEventListener('click', ()=>buildRunXlsxExact().catch(e=>toast('–û—à–∏–±–∫–∞ —ç–∫—Å–ø–æ—Ä—Ç–∞ Excel: '+(e.message||e))));
$('#runFiltersApply')?.addEventListener('click', applyRunFilters);

// Add missing applyRunFilters function to avoid ReferenceError
function applyRunFilters() {
  // Use existing logic to filter and render the run report
  if (typeof applyRunFiltersAndRender === 'function') {
    applyRunFiltersAndRender();
  } else {
    toast('–§—É–Ω–∫—Ü–∏—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ –Ω–µ —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω–∞');
  }
}

// –ö–Ω–æ–ø–∫–∞ –∑–∞–ø—É—Å–∫–∞ –¥–∞—à–±–æ—Ä–¥–∞
$('#runBtn')?.addEventListener('click', runDashboard);

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è
showTab('dash');
setSubtab('general');
setAutoState(false);
})();
// ==== –î–û–ë–ê–í–õ–ï–ù–û ====
// –≠–∫—Å–ø–æ—Ä—Ç Excel –∏–∑ –†–ê–ù-–æ—Ç—á—ë—Ç–∞
async function buildRunXlsxExact(){
  const rowsObj = getRunRows();
  if(!rowsObj || !rowsObj.length){ toast('–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —ç–∫—Å–ø–æ—Ä—Ç–∞'); return; }

  const headers = ['–†–∞–Ω','–ù–æ–º–µ—Ä –∫–µ–π—Å–∞','–ò–º—è —Ç–µ—Å—Ç –∫–µ–π—Å–∞','testedBy(SWAT)','lastModifiedBy(product)',
                   '–í—Å–µ–≥–æ','–ê–≤—Ç–æ','–†—É—á–Ω—ã–µ','–ù–∞–∑–Ω–∞—á–µ–Ω–æ','–í –ø—Ä–æ—Ü–µ—Å—Å–µ','–û—Å—Ç–∞–ª–æ—Å—å'];

  // –ë—ã–ª–æ: const X = window.XlsxPopulate; if(!X) throw new Error('XlsxPopulate –Ω–µ –ø–æ–¥–∫–ª—é—á—ë–Ω');
  const dataRows = rowsObj.map(toOrderedArray);
  const aoa = [headers, ...dataRows];

  const ws = XLSX.utils.aoa_to_sheet(aoa);
  const wb = XLSX.utils.book_new();
  XLSX.utils.book_append_sheet(wb, ws, '–†–ê–ù');

  // –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ: –∞–≤—Ç–æ—Ñ–∏–ª—å—Ç—Ä –∏ —à–∏—Ä–∏–Ω—ã –∫–æ–ª–æ–Ω–æ–∫ –≤ SheetJS:
  ws['!autofilter'] = { ref: 'A1:K1' };
  ws['!cols'] = [28,14,40,22,28,12,12,12,12,12,12].map(w => ({wch:w}));

  const ver = (document.getElementById('version')?.value || '').trim();
  const now = new Date(); const pad = x => String(x).padStart(2,'0');
  const stamp = now.getFullYear()+''+pad(now.getMonth()+1)+''+pad(now.getDate())+'-'+pad(now.getHours())+''+pad(now.getMinutes());
  const fname = `–û—Ç—á–µ—Ç_–†–∞–Ω—ã_${ver || 'X.Y.Z'}_${stamp}.xlsx`;

  XLSX.writeFile(wb, fname);
  toast('Excel —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω');
}
</script>

<!-- ==== SWAT TAB (injected, non-invasive) ==== -->


<!-- ==== Additive SWAT API controls + logic (non-invasive) ==== -->










































<script>
// === SWAT: fast mode (parallel leaves + higher concurrency, throttled logs) ===
(function(){
  function ready(fn){ if(document.readyState!=='loading') fn(); else document.addEventListener('DOMContentLoaded', fn); }
  ready(function(){
    if(typeof sw_buildFromApi !== 'function') return;
    const original = sw_buildFromApi;

    function now(){ return (typeof performance!=='undefined' && performance.now) ? performance.now() : Date.now(); }

    // Override with fast version
    sw_buildFromApi = async function sw_buildFromApi_fast(){
      const baseUrl = (document.getElementById('swatBaseUrl').value||'').trim().replace(/\/+$/,'');
      const token   = (document.getElementById('swatApiToken').value||'').trim();
      const projectId = (document.getElementById('swatProjectId').value||'').trim();
      const release = (document.getElementById('swatRelease').value||'').trim();
      const kinds = []; if(document.getElementById('kindSmoke')?.checked) kinds.push('Smoke'); if(document.getElementById('kindSelective')?.checked) kinds.push('Selective'); if(document.getElementById('kindHB')?.checked) kinds.push('High/Blocker');
      if(!baseUrl || !token || !projectId || !release || kinds.length===0){ alert('–£–∫–∞–∂–∏—Ç–µ Base URL, Project ID, Token, –†–µ–ª–∏–∑ –∏ –≤—ã–±–µ—Ä–∏—Ç–µ Kind'); return; }

      // helpers
      async function safe(promiseFactory, ctx){
        try{ return await promiseFactory(); }
        catch(e){ log('API error'+(ctx?(' @ '+ctx):'')+': '+(e.message||e),'ERROR'); return null; }
      }
      const limit8  = (typeof sw_pLimit==='function') ? sw_pLimit(8)  : (fn=>fn());
      const limit32 = (typeof sw_pLimit==='function') ? sw_pLimit(32) : (fn=>fn());

      log(`(FAST) –ò—â—É –ª–∞—É–Ω—á–∏ –¥–ª—è —Ä–µ–ª–∏–∑–∞ ${release} –ø–æ –≤–∏–¥–∞–º: ${kinds.join(', ')}`);
      setProgress(2);
      const launches = await safe(()=>sw_findLaunchesByRelease(baseUrl, projectId, token, release, kinds), 'findLaunchesByRelease') || [];
      log(`–ù–∞–π–¥–µ–Ω–æ –ª–∞—É–Ω—á–µ–π: ${launches.length}`);
      if(!launches.length){ setProgress(100); sw_renderSummary([]); sw_renderDetailed([]); return; }

      // Collect leaves in parallel per launch
      let allLeafIds = [];
      const leavesArr = await Promise.all(launches.map(ln => limit8(()=> safe(()=>sw_listLeafResultsForLaunch(baseUrl, token, ln.id), 'listLeafResultsForLaunch('+ln.id+')') )));
      leavesArr.forEach(ids => { if(Array.isArray(ids)) allLeafIds.push(...ids); });
      log('(FAST) –í—Å–µ–≥–æ –ª–∏—Å—Ç–æ–≤—ã—Ö —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤: '+allLeafIds.length);
      if(!allLeafIds.length){ setProgress(100); sw_renderSummary([]); sw_renderDetailed([]); return; }

      // Analyze leaves with higher concurrency + throttled UI updates
      const swatSet = (typeof sw_parseSwatList==='function') ? sw_parseSwatList() : new Set();
      const records=[];
      let done=0, t0=now(), lastUi=0;
      await Promise.all(allLeafIds.map(id => limit32(async ()=>{
        const rec = await safe(()=>sw_analyzeLeaf(baseUrl, token, id, swatSet), 'analyzeLeaf('+id+')');
        if(rec) records.push(rec);
        done++;
        const t=now();
        if(t - lastUi > 500 || done===allLeafIds.length){
          const pct = Math.round( (done*100)/allLeafIds.length );
          setProgress(2 + 96*done/allLeafIds.length);
          // –∫–æ–º–ø–∞–∫—Ç–Ω—ã–π –ª–æ–≥ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞
          log(`(FAST) ${done}/${allLeafIds.length} ‚Ä¢ ${pct}%`, 'DEBUG');
          lastUi = t;
        }
      })));

      window.__swat_records_all = records.slice();
      sw_populateStreams(); sw_populateRuns(); sw_applyFiltersAndRender();
      setProgress(100);
      log('(FAST) –ì–æ—Ç–æ–≤–æ –∏–∑ API');
    };

    // –ò –Ω–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π: –µ—Å–ª–∏ —á—Ç–æ-—Ç–æ –ø–æ–π–¥—ë—Ç –Ω–µ —Ç–∞–∫ ‚Äî –≤–µ—Ä–Ω—ë–º –æ—Ä–∏–≥–∏–Ω–∞–ª –ø–æ Shift+–∫–ª–∏–∫—É
    const btn = document.getElementById('swatBuildApi');
    if(btn){
      btn.title = (btn.title?btn.title+'\n':'') + 'Shift+Click ‚Äî –∑–∞–ø—É—Å—Ç–∏—Ç—å –º–µ–¥–ª–µ–Ω–Ω—ã–π —Ä–µ–∂–∏–º';
      btn.addEventListener('click', function(e){
        if(e.shiftKey){
          sw_buildFromApi = original;
          setTimeout(()=>{ sw_buildFromApi = arguments.callee.fastApplied ? sw_buildFromApi : sw_buildFromApi; }, 0);
        }
      }, { once:true });
    }
  });
})();
</script>

<!-- Safe swap for Release and API Token fields -->
<script>
(function(){
  function ready(fn){ if(document.readyState!=='loading') fn(); else document.addEventListener('DOMContentLoaded', fn); }
  ready(function(){
    try{
      // –∏—â–µ–º –±–ª–æ–∫ SWAT –∏ –ø–æ–ª—è
      var api = document.getElementById('swatApiPanel') || document; // fallback
      var fldTokenEl   = document.getElementById('swatApiToken');
      var fldReleaseEl = document.getElementById('swatRelease');
      if(!fldTokenEl || !fldReleaseEl) return;

      // –±–µ—Ä—ë–º .field –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä—ã
      var fldToken   = fldTokenEl.closest('.field') || fldTokenEl;
      var fldRelease = fldReleaseEl.closest('.field') || fldReleaseEl;
      if(!fldToken.parentNode || !fldRelease.parentNode) return;

      // –µ—Å–ª–∏ —É–∂–µ —Å—Ç–æ–∏—Ç –≤ –Ω—É–∂–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ (Release –¥–æ Token) ‚Äî –≤—ã—Ö–æ–¥–∏–º
      var sibl = fldRelease.nextElementSibling;
      if(sibl === fldToken) return;

      // –±–µ–∑–æ–ø–∞—Å–Ω–∞—è –ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–∫–∞ —É–∑–ª–æ–≤
      var placeholder = document.createElement('div');
      fldToken.parentNode.insertBefore(placeholder, fldToken);
      fldRelease.replaceWith(fldToken);
      placeholder.replaceWith(fldRelease);
      // –ì–û–¢–û–í–û: –ø–æ–ª—è –ø–æ–º–µ–Ω—è–ª–∏—Å—å –º–µ—Å—Ç–∞–º–∏ –±–µ–∑ insertBefore –Ω–∞ —á—É–∂–æ–π –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä
    }catch(e){
      console.warn('SWAT swap fields failed:', e);
    }
  });
})();
</script>

<script>
(function(){
  function tableToXlsBlob(table, name){
    const html = `<!DOCTYPE html><html><head><meta charset="UTF-8">











</head>
<body>${table.outerHTML}

<script>
(function(){
  // Remove code-dump artifacts that sometimes appear at the very end
  function isDumpNode(node){
    if(!node) return false;
    if(node.nodeType===3){
      var t=node.textContent||"";
      return t.length>200 && (t.includes("function")||t.includes("var ")||t.includes("=>")) && (t.includes(";")||t.includes("{"));
    }
    if(node.nodeType===1){
      var txt=node.textContent||"";
      return txt.length>200 && (txt.includes("function(")||txt.includes("var ")||txt.includes("=>")) && (txt.includes(";")||txt.includes("{"));
    }
    return false;
  }
  function cleanDumps(){
    var body=document.body;
    // scan last 10 nodes
    for(let i=0;i<10;i++){
      var n=body.childNodes[body.childNodes.length-1-i];
      if(!n) break;
      if(isDumpNode(n)){
        if(n.nodeType===1) n.classList.add("__code-dump");
        else {
          // wrap text node so CSS can hide it
          var span=document.createElement("div");
          span.className="__code-dump";
          span.textContent=n.textContent;
          body.replaceChild(span,n);
        }
      }
    }
  }
  cleanDumps();
  // re-check shortly in case late scripts append text
  setTimeout(cleanDumps, 800);
  setTimeout(cleanDumps, 2000);

  // Tabs active state fix: ensure only current tab has .active-btn
  const tabBar=document.querySelector('[data-tabs="main"]');
  if(tabBar){
    tabBar.addEventListener('click', (e)=>{
      const btn=e.target.closest('[data-tab]');
      if(!btn) return;
      const all=tabBar.querySelectorAll('[data-tab]');
      all.forEach(b=>b.classList.remove('active-btn'));
      btn.classList.add('active-btn');
    });
  }

  // Soft guard: keep SWAT block visible only on its tab if such attributes exist
  const swatSec=document.getElementById('swatPanel')||document.querySelector('[data-block="swat"]');
  const dashSec=document.getElementById('dashboardWrap')||document.querySelector('[data-block="dashboard"]');
  const pahSec=document.getElementById('pahWrap')||document.querySelector('[data-block="pah"]');
  function showOnly(sec){
    [swatSec,dashSec,pahSec].forEach(s=>{ if(!s) return; s.style.display = (s===sec)?'block':'none'; });
  }
  // if we can detect selected by aria-selected or .active-btn
  const active=tabBar?tabBar.querySelector('.active-btn'):null;
  if(active){
    const tb=active.dataset.tab;
    if(tb==='swat') showOnly(swatSec);
    else if(tb==='dash') showOnly(dashSec);
    else if(tb==='pah') showOnly(pahSec);
  }

  // Restore "–ü–æ–∫–∞–∑–∞—Ç—å/–°–∫—Ä—ã—Ç—å" toggles if present headings with data-toggle-target
  document.querySelectorAll('[data-toggle-target]').forEach(btn=>{
    const targetSel = btn.getAttribute('data-toggle-target');
    const target = document.querySelector(targetSel);
    if(!target) return;
    btn.addEventListener('click', ()=>{
      const vis = getComputedStyle(target).display!=='none';
      target.style.display = vis ? 'none' : '';
      btn.textContent = vis ? '–ü–æ–∫–∞–∑–∞—Ç—å' : '–°–∫—Ä—ã—Ç—å';
    });
  });

  // Provide STOP for dashboard if a global controller exists
  if(!window.__runAbort){
    window.__runAbort = new AbortController();
  }
  const runBtn = document.getElementById('btnDashRun')||document.querySelector('[data-action="run-dashboard"]');
  const stopBtn = document.getElementById('btnDashStop')||document.querySelector('[data-action="stop-dashboard"]');
  if(runBtn){
    runBtn.addEventListener('click', ()=>{
      window.__runAbort.abort();
      window.__runAbort = new AbortController();
      runBtn.dataset.busy="1";
      setTimeout(()=>{ runBtn.dataset.busy=""; }, 120000);
    });
  }
  if(stopBtn){
    stopBtn.addEventListener('click', ()=>{
      try{ window.__runAbort.abort(); }catch(_){}
      runBtn && (runBtn.dataset.busy="");
    });
  }
})();
</script>

<!-- === PATCH: show/hide toggles + initial stream hide + footer tail cleanup + SWAT safe visibility === -->

<script>
(function(){
  const $ = (s, r=document)=>r.querySelector(s);
  const $$= (s, r=document)=>Array.from(r.querySelectorAll(s));

  // 1) Initial: on Dashboard show only "–û–±—â–∏–µ" (hide "–ü–æ —Å—Ç—Ä–∏–º—É")
  function hideStreamOnStart(){
    const gen = $('#snapListDash, #snapGeneralSection');
    const str = $('#snapListDashStream, #snapStreamSection');
    if(str){ str.style.display='none'; }
    if(gen){ gen.style.display=''; }
  }

  // 2) Re-bind subtabs "–û–±—â–∏–µ / –ü–æ —Å—Ç—Ä–∏–º—É" if present (UI only)
  function bindSubtabs(){
    const btnG = $('#subtabGeneral');
    const btnS = $('#subtabStream');
    const gen  = $('#snapGeneralSection, #snapListDash');
    const str  = $('#snapStreamSection, #snapListDashStream');
    if(!btnG || !btnS || !gen || !str) return;
    const showG = ()=>{ gen.style.display=''; str.style.display='none'; btnG.classList.add('active'); btnS.classList.remove('active'); };
    const showS = ()=>{ gen.style.display='none'; str.style.display=''; btnS.classList.add('active'); btnG.classList.remove('active'); };
    btnG.addEventListener('click', (e)=>{ e.preventDefault(); showG(); });
    btnS.addEventListener('click', (e)=>{ e.preventDefault(); showS(); });
    // default
    showG();
  }

  // 3) Add toggle buttons "–ü–æ–∫–∞–∑–∞—Ç—å/–°–∫—Ä—ã—Ç—å" for known sections by heading text
  function makeBtn(){ const b=document.createElement('button'); b.className='pill toggle-btn'; b.type='button'; b.textContent='–°–∫—Ä—ã—Ç—å'; return b; }
  function attachToggleByTitle(title){
    // find heading node that matches title
    const heads = $$('h2,h3,.head,.card .head,.card .title,.section-title');
    const hdr = heads.find(h=> (h.textContent||'').trim() === title);
    if(!hdr) return;
    const panel = hdr.closest('.card, section, .panel, .box, .wrap, .container, div');
    if(!panel || panel.__toggleBound) return;
    panel.__toggleBound = true;
    const btn = makeBtn();
    // place at header end
    hdr.appendChild(btn);
    const content = hdr.nextElementSibling || panel.children[1];
    if(!content) return;
    btn.addEventListener('click', ()=>{
      const vis = content.style.display !== 'none';
      content.style.display = vis ? 'none' : '';
      btn.textContent = vis ? '–ü–æ–∫–∞–∑–∞—Ç—å' : '–°–∫—Ä—ã—Ç—å';
      if(!vis && typeof window.rebuildMini==='function'){ try{ rebuildMini(); }catch(_){} }
    });
  }
  function attachToggles(){
    [
      '–°–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã–µ —Å—Ä–µ–∑—ã',
      '–õ–æ–≥',
      '–ê–ª–ª–µ—Ä—Ç –ø–æ –ª–∞—É–Ω—á–∞–º',
      '[iOS][Smoke]',
      '[Android][Smoke]',
      '[Android][Selective]',
      '[iOS][Selective]',
      '–°–≤–æ–¥–Ω—ã–π –±–∞—Ä—á–∞—Ä—Ç'
    ].forEach(attachToggleByTitle);
  }

  // 4) Footer "tail" cleanup: hide accidental printed JS
  function cleanFooterTail(){
    const body = document.body;
    const nodes = Array.from(body.childNodes).slice(-30);
    nodes.forEach(n=>{
      if(n.nodeType===3){
        const t = (n.textContent||'').trim();
        if(t.length>120 && /(return\s+new\s+Blob|function\s+downloadBlob|btnExportXls|sw_exportXls)/i.test(t)){
          const d=document.createElement('div'); d.className='__code-dump'; d.textContent=t; body.replaceChild(d,n);
        }
      } else if(n.nodeType===1){
        const txt = (n.textContent||'').trim();
        if(txt.length>300 && /(return\s+new\s+Blob|function\s+downloadBlob|btnExportXls|sw_exportXls)/i.test(txt)){
          n.classList.add('__code-dump');
        }
      }
    });
  }

  // 5) SWAT safe visibility: show only on its tab (if tabs exist)
  function bindTopTabs(){
    const bar = $('nav .tabs, .tabs, [data-tabs="main"]') || document;
    bar.addEventListener('click', (e)=>{
      const el = e.target.closest('button, a, [data-tab]');
      if(!el) return;
      const label = (el.textContent||'').trim();
      const dash = $('#tabDash, #dashboardWrap, [data-block="dashboard"]');
      const run  = $('#tabRun, #runWrap, [data-block="run"]');
      const isDa = /–¥–∞—à–±–æ—Ä–¥/i.test(label);
      const isRu = /(—Ä–∞–Ω|pah)/i.test(label);
      if(dash || run){
        if(dash) dash.style.display = isDa ? '' : 'none';
        if(run)  run.style.display  = isRu ? '' : 'none';
      }
      }
      // unstick active state if buttons have it
      const btns = $$('.tabs [data-tab], .tabs button, nav .tabs button');
      btns.forEach(b=> b.classList.remove('active','active-btn'));
      el.classList.add('active');
      setTimeout(cleanFooterTail, 50);
    }, {passive:true});
  }

  function init(){
    hideStreamOnStart();
    bindSubtabs();
    attachToggles();
    cleanFooterTail();
    bindTopTabs();
    setTimeout(cleanFooterTail, 400);
    setTimeout(cleanFooterTail, 1500);
  }
  if(document.readyState!=='loading') init();
  else document.addEventListener('DOMContentLoaded', init);
})();
</script>

<!-- PATCH: add STOP button next to '–ó–∞–ø—É—Å—Ç–∏—Ç—å' on dashboard -->
<script>
(function(){
  var runBtn = document.getElementById('runBtn');
  if(!runBtn) return;
  // create Stop button if not exists
  var stopBtn = document.getElementById('stopBtn');
  if(!stopBtn){
    stopBtn = document.createElement('button');
    stopBtn.id = 'stopBtn';
    stopBtn.className = runBtn.className;
    stopBtn.textContent = '–°—Ç–æ–ø';
    stopBtn.style.marginLeft = '8px';
    runBtn.parentNode.insertBefore(stopBtn, runBtn.nextSibling);
  }
  // global abort controller (opt-in for your fetches using window.__dashAbort.signal)
  if(!window.__dashAbort) window.__dashAbort = new AbortController();

  function setBusy(b){
    runBtn.disabled = !!b;
    stopBtn.disabled = !b;
    if(b){ runBtn.classList.add('busy'); } else { runBtn.classList.remove('busy'); }
  }
  setBusy(false); // initial

  runBtn.addEventListener('click', function(){
    // new controller for a new run
    try { window.__dashAbort.abort(); } catch(_){}
    window.__dashAbort = new AbortController();
    window.__shouldStop = false;
    setBusy(true);
  });

  stopBtn.addEventListener('click', function(){
    window.__shouldStop = true;
    try { window.__dashAbort.abort(); } catch(_){}
    setBusy(false);
  });
})();
</script>

<!-- STOP/ABORT shim injected -->
<script id="stop-abort-shim">
(function(){
  // prevent double inject
  if (window.__stopShimInstalled__) return;
  window.__stopShimInstalled__ = true;

  // Global abort session
  const abortState = (window.__abortState__ = {
    controller: null,
    active: false,
    stopRequested: false,
  });

  function beginAbortSession(){
    abortState.controller = new AbortController();
    abortState.active = true;
    abortState.stopRequested = false;
  }
  function requestStop(){
    abortState.stopRequested = true;
    try{ abortState.controller && abortState.controller.abort(); }catch(_){}
    abortState.active = false;
  }
  window.__beginAbortSession__ = beginAbortSession;
  window.__requestStop__ = requestStop;

  // Fetch shim: add signal automatically
  if (!window.__fetchPatchedForAbort__) {
    const _fetch = window.fetch;
    window.fetch = function(input, init){
      init = init || {};
      if (abortState.controller && !init.signal){
        init = Object.assign({}, init, { signal: abortState.controller.signal });
      }
      return _fetch(input, init);
    };
    window.__fetchPatchedForAbort__ = true;
  }

  // Global abort-aware promise helper
  window.abortable = function(promise){
    if (!abortState.controller) return promise;
    const s = abortState.controller.signal;
    if (!s) return promise;
    return new Promise((resolve,reject)=>{
      const onAbort = ()=>reject(Object.assign(new Error('ABORT'),{name:'AbortError'}));
      if (s.aborted) return onAbort();
      s.addEventListener('abort', onAbort, {once:true});
      promise.then(v=>{ s.removeEventListener('abort', onAbort); resolve(v); },
                   e=>{ s.removeEventListener('abort', onAbort); reject(e); });
    });
  };

  // UI: find buttons by id or text
  function byText(btns, txt){
    txt = String(txt).trim().toLowerCase();
    return Array.from(btns).find(b => (b.textContent||'').trim().toLowerCase() === txt);
  }

  function pickButtons(){
    const allBtns = document.querySelectorAll('button, .btn');
    let run = document.querySelector('#dashRunBtn') || byText(allBtns, '–∑–∞–ø—É—Å—Ç–∏—Ç—å');
    let stop = document.querySelector('#dashStopBtn') || byText(allBtns, '—Å—Ç–æ–ø');
    return {run, stop};
  }

  function ensureHandlers(){
    const {run, stop} = pickButtons();
    if (!run || !stop || run.__stopShimBound__) return;
    run.__stopShimBound__ = true;

    // RUN
    run.addEventListener('click', function(){
      // start session; UI lock
      try{ beginAbortSession(); }catch(_){}
      run.disabled = true;
      run.classList.add('is-busy');
      // When page code finishes (or error), re-enable. We can't hook internal,
      // so we re-enable on first microtask after settled promise queue.
      setTimeout(()=>{
        // the page code should re-enable itself; as a fallback re-enable after 30s
        setTimeout(()=>{ run.disabled=false; run.classList.remove('is-busy'); }, 30000);
      },0);
    }, {capture:true});

    // STOP
    stop.addEventListener('click', function(e){
      e.preventDefault();
      e.stopPropagation();
      requestStop();
      // re-enable run button immediately
      setTimeout(()=>{
        const {run} = pickButtons();
        if (run){ run.disabled = false; run.classList.remove('is-busy'); }
      }, 0);
    });
  }

  // try now and on dom changes
  ensureHandlers();
  const mo = new MutationObserver(ensureHandlers);
  mo.observe(document.documentElement, {subtree:true, childList:true});
  
  // silence AbortError red screens
  window.addEventListener('unhandledrejection', (ev)=>{
    const r = ev.reason;
    if (r && (r.name === 'AbortError' || String(r).includes('AbortError') || String(r).includes('ABORT'))) {
      ev.preventDefault();
    }
  });
})();
</script>


  <!-- ====================== –í–ê–ù–ì–û–í–ê–¢–û–† (4-—è –≤–∫–ª–∞–¥–∫–∞, iframe-–∏–∑–æ–ª—è—Ü–∏—è) ====================== -->
  












<script>
(function () {
  const iframe = document.getElementById('createRunFrame');
  if (!iframe) return;

  iframe.addEventListener('load', function () {
    try {
      // –ë–µ—Ä—ë–º –¥–æ–∫—É–º–µ–Ω—Ç –≤–Ω—É—Ç—Ä–∏ iframe
      const doc = iframe.contentDocument || iframe.contentWindow.document;
      if (!doc) return;

      // –ò—â–µ–º –∑–∞–≥–æ–ª–æ–≤–æ–∫ —Å —Ç–µ–∫—Å—Ç–æ–º "–û—Å—Ç–∞—Ç–æ–∫ –∫–µ–π—Å–æ–≤ –Ω–∞ —Ä–µ–≥—Ä–µ—Å—Å"
      const header = Array.from(doc.querySelectorAll('h1,h2,h3,div,span'))
        .find(el => el.textContent && el.textContent.includes('–û—Å—Ç–∞—Ç–æ–∫ –∫–µ–π—Å–æ–≤ –Ω–∞ —Ä–µ–≥—Ä–µ—Å—Å'));

      if (!header) return;

      // –ü–æ–¥–Ω–∏–º–∞–µ–º—Å—è –∫ –∫–∞—Ä—Ç–æ—á–∫–µ/–∫–æ–Ω—Ç–µ–π–Ω–µ—Ä—É –∏ —Å–∫—Ä—ã–≤–∞–µ–º –µ—ë
      const container = header.closest('.card, .wb-card, section, div');
      if (container) {
        container.style.display = 'none';
      }
    } catch (e) {
      console.error('–ù–µ —É–¥–∞–ª–æ—Å—å —Å–ø—Ä—è—Ç–∞—Ç—å –±–ª–æ–∫ –†–ê–ù-–æ—Ç—á—ë—Ç–∞ –≤–Ω—É—Ç—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏—è —Ä–∞–Ω–∞:', e);
    }
  });
})();
</script>




<script>
// === Platform/Type Filters (robust, DOM-level, with summary) ===
(function(){
  function normKey(s){ return String(s||'').replace(/\]\s*\[/g, '][').trim(); }
  function parseLabel(label){
    label = normKey(label);
    var plat = (label.indexOf('[iOS]')===0) ? 'iOS' : (label.indexOf('[Android]')===0 ? 'Android' : null);
    var type = label.includes('[High/Blocker]') ? 'High/Blocker' :
               (label.includes('[Selective]') ? 'Selective' :
               (label.includes('[Smoke]') ? 'Smoke' : null));
    return { platform: plat, type: type };
  }
  function isPlatformEnabled(p){
    if(p==='iOS') return document.getElementById('fltPlatIOS')?.checked === true;
    if(p==='Android') return document.getElementById('fltPlatAndroid')?.checked === true;
    return true; // unknown -> don't hide
  }
  function isTypeEnabled(t){
    if(t==='Smoke') return document.getElementById('fltTypeSmoke')?.checked === true;
    if(t==='Selective') return document.getElementById('fltTypeSelective')?.checked === true;
    if(t==='High/Blocker') return document.getElementById('fltTypeHB')?.checked === true;
    return true;
  }
  function isVisibleLabel(label){
    var p = parseLabel(label);
    return isPlatformEnabled(p.platform) && isTypeEnabled(p.type);
  }

  // For bars: filter labels/datasets by visibility
  if (typeof window.makeBarChart === 'function' && !window.__makeBarChartOrig){
    window.__makeBarChartOrig = window.makeBarChart;
    window.makeBarChart = function(barId, labels, datasets){
      try{
        var idx = labels.map(function(l,i){ return isVisibleLabel(l) ? i : -1; }).filter(function(x){return x!==-1;});
        var labels2 = idx.map(function(i){ return labels[i]; });
        var datasets2 = (datasets||[]).map(function(ds){
          var d = ds.data || [];
          return Object.assign({}, ds, { data: idx.map(function(i){ return d[i]; }) });
        });
        return window.__makeBarChartOrig(barId, labels2, datasets2);
      }catch(e){ console.warn('bar filter error', e); return window.__makeBarChartOrig(barId, labels, datasets); }
    };
  }

  // Donuts: show/hide by visibility
  function applyVisibilityFilter(){
    try{
      var cards = document.querySelectorAll('#cards .card');
      cards.forEach(function(card){
        var title = card.querySelector('.head > div:first-child');
        var label = title ? title.textContent : '';
        card.style.display = isVisibleLabel(label) ? '' : 'none';
      });
    }catch(e){ console.warn('applyVisibilityFilter error', e); }
  }
  window.__applyVisibilityFilter = applyVisibilityFilter;

  // Recompute summary ("–í—Å–µ–≥–æ –≥—Ä—É–ø–ø / –≤—Å–µ–≥–æ –∫–µ–π—Å–æ–≤") based on visible labels
  function updateSummaryFromFilters(){
    try{
      var sumEl = document.getElementById('summaryInfo');
      if(!sumEl || !window.__lastAgg) return;
      var labels = Object.keys(window.__lastAgg || {});
      var visible = labels.filter(isVisibleLabel);
      var totalCases = visible.reduce(function(acc, k){
        var a = window.__lastAgg[k] || {};
        var t = Number(a.total || 0);
        return acc + (isFinite(t) ? t : 0);
      }, 0);
      sumEl.textContent = '–í—Å–µ–≥–æ –≥—Ä—É–ø–ø: ' + visible.length + ', –≤—Å–µ–≥–æ –∫–µ–π—Å–æ–≤: ' + (totalCases.toLocaleString ? totalCases.toLocaleString('ru-RU') : totalCases);
    }catch(e){ console.warn('updateSummaryFromFilters error', e); }
  }
  window.__updateSummaryFromFilters = updateSummaryFromFilters;

  // Hook renderAgg to capture agg and apply filters after draw
  (function hookRender(){
    if (typeof window.renderAgg !== 'function' || window.__renderAggHooked) return;
    window.__renderAggHooked = true;
    var orig = window.renderAgg;
    window.renderAgg = function(a,b,c,d){
      window.__lastAgg = a; // remember
      var r = orig(a,b,c,d);
      try{ applyVisibilityFilter(); updateSummaryFromFilters(); }catch(_e){}
      return r;
    };
  })();

  function bindUI(){
    var ids = ['fltPlatIOS','fltPlatAndroid','fltTypeSmoke','fltTypeSelective','fltTypeHB'];
    ids.forEach(function(id){
      var el = document.getElementById(id);
      if(el && !el.__bind){
        el.__bind = true;
        el.addEventListener('change', function(){
          try{
            if (typeof window.renderAgg === 'function' && window.__lastAgg){
              window.renderAgg(window.__lastAgg, 'cards', 'barAll', document.getElementById('summaryInfo'));
            } else {
              applyVisibilityFilter();
              updateSummaryFromFilters();
              window.dispatchEvent(new Event('resize'));
            }
          }catch(e){ console.warn('repaint failed', e); }
        });
      }
    });
    document.getElementById('fltAll')?.addEventListener('click', function(){
      ['fltPlatIOS','fltPlatAndroid','fltTypeSmoke','fltTypeSelective','fltTypeHB'].forEach(function(id){ var el=document.getElementById(id); if(el) el.checked=true; });
      document.getElementById('fltPlatIOS')?.dispatchEvent(new Event('change'));
    });
    document.getElementById('fltNone')?.addEventListener('click', function(){
      ['fltPlatIOS','fltPlatAndroid','fltTypeSmoke','fltTypeSelective','fltTypeHB'].forEach(function(id){ var el=document.getElementById(id); if(el) el.checked=false; });
      document.getElementById('fltPlatIOS')?.dispatchEvent(new Event('change'));
    });
  }
  document.addEventListener('DOMContentLoaded', bindUI);
})();
</script>





<script>
// ========= Settings persistence + instant filters (patch v3: debounced + calls updateSummaryFromFilters) =========
(function(){
  const LS_KEYS = {
    version: 'rb__version',
    token: 'rb__token',
    baseUrl: 'rb__baseUrl',
    projectId: 'rb__projectId'
  };
  const $ = sel => document.querySelector(sel);

  const versionInput   = $('#version');
  const tokenInput     = $('#token');
  const baseUrlInput   = $('#baseUrl');
  const projectIdInput = $('#projectId');
  const saveBtn        = $('#saveSettingsBtn');
  const toast          = $('#toast');

  function showToast(msg){
    if(!toast) return;
    toast.textContent = msg;
    toast.classList.add('show');
    setTimeout(()=> toast.classList.remove('show'), 1500);
  }
  function setIfEmpty(el, val){
    if(el && (el.value === '' || el.value == null)) el.value = val;
  }

  // Load saved values
  try {
    const v   = localStorage.getItem(LS_KEYS.version);
    const t   = localStorage.getItem(LS_KEYS.token);
    const bu  = localStorage.getItem(LS_KEYS.baseUrl);
    const pid = localStorage.getItem(LS_KEYS.projectId);
    if(v)   setIfEmpty(versionInput, v);
    if(t)   setIfEmpty(tokenInput, t);
    if(bu)  setIfEmpty(baseUrlInput, bu);
    if(pid) setIfEmpty(projectIdInput, pid);
  } catch(e){}

  function saveSettings(){
    try{
      if(versionInput)   localStorage.setItem(LS_KEYS.version,   (versionInput.value||'').trim());
      if(tokenInput)     localStorage.setItem(LS_KEYS.token,     (tokenInput.value||'').trim());
      if(baseUrlInput)   localStorage.setItem(LS_KEYS.baseUrl,   (baseUrlInput.value||'').trim());
      if(projectIdInput) localStorage.setItem(LS_KEYS.projectId, (projectIdInput.value||'').trim());
      showToast('–ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã');
    }catch(e){
      console.error(e);
      showToast('–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å');
    }
  }
  if(saveBtn) saveBtn.addEventListener('click', saveSettings);
  [versionInput, tokenInput].forEach(el => { if(el) el.addEventListener('blur', saveSettings); });

  // ========== Instant filters ==========
  const fltSmoke    = $('#fltTypeSmoke');
  const fltSel      = $('#fltTypeSelective');
  const fltHB       = $('#fltTypeHB');
  const fltIOS      = $('#fltPlatIOS');
  const fltAndroid  = $('#fltPlatAndroid');
  const btnAll      = $('#fltAll');
  const btnNone     = $('#fltNone');

  let rafId = 0;
  function scheduleApply(){
    if(rafId) cancelAnimationFrame(rafId);
    rafId = requestAnimationFrame(()=>{
      if (typeof window.updateSummaryFromFilters === 'function') {
        try { window.updateSummaryFromFilters(); } catch(e){ console.debug(e); }
      }
      const fns = [
        'buildSummaryBar','rebuildSummaryBar','renderSummaryBar','updateSummaryBar',
        'buildMiniDonuts','renderMiniDonuts','updateMiniDonuts',
        'sw_renderSummary','renderAgg','renderDashPrevCurrent','renderDashPrevCurrentStream',
        'applyRunFiltersAndRender','renderStreamSnapList','renderSnapList'
      ];
      fns.forEach(name => { if (typeof window[name] === 'function') { try{ window[name](); }catch(e){ console.debug(name, e); } } });
    });
  }

  [fltSmoke, fltSel, fltHB, fltIOS, fltAndroid].forEach(el => {
    if(!el) return;
    el.addEventListener('change', scheduleApply);
    el.addEventListener('input',  scheduleApply);
    el.addEventListener('click',  scheduleApply);
  });

  if(btnAll){
    btnAll.addEventListener('click', () => {
      [fltSmoke, fltSel, fltHB, fltIOS, fltAndroid].forEach(el => { if(el) el.checked = true; });
      scheduleApply();
    });
  }
  if(btnNone){
    btnNone.addEventListener('click', () => {
      [fltSmoke, fltSel, fltHB, fltIOS, fltAndroid].forEach(el => { if(el) el.checked = false; });
      scheduleApply();
    });
  }

  scheduleApply();
})();
</script>


<script>window.__PY_SCRIPT__ = `#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Allure TestOps ‚Üí Excel –æ—Ç—á—ë—Ç –ø–æ —Ä–∞–Ω–∞–º (Smoke / Selective)

–í –≠–¢–û–ô –í–ï–†–°–ò–ò –ú–ò–ù–£–° –ò–ó–ú–ï–ù–ï–ù–ò–ô: –æ—Ç–∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–∞ –°–í–û–î–ù–ê–Ø —Å—Ç—Ä–æ–∫–∞
¬´–í—Å–µ–≥–æ —Ç–µ—Å—Ç –∫–µ–π—Å–æ–≤ Selective¬ª ‚Äî —Ç–µ–ø–µ—Ä—å –æ–Ω–∞ —Å—á–∏—Ç–∞–µ—Ç—Å—è –¢–û–õ–¨–ö–û –ø–æ —Ç–µ–≥—É
"[Selective]" (–±–µ–∑ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–≥–æ —Ñ–∏–ª—å—Ç—Ä–∞ –ø–æ "[Selective][DeployLab]"),
—á—Ç–æ–±—ã –Ω–µ –±—ã–ª–æ –¥–≤–æ–π–Ω–æ–≥–æ —É—á—ë—Ç–∞. –û—Å—Ç–∞–ª—å–Ω–æ–π –∫–æ–¥ –Ω–µ –º–µ–Ω—è–ª—Å—è.
"""

import os
import json
import base64
from datetime import datetime
from typing import Dict, List, Set, NamedTuple, Optional, Tuple

import requests
from openpyxl import Workbook
from openpyxl.styles import Font, Alignment, PatternFill, Border, Side
from openpyxl.utils import get_column_letter
from openpyxl.worksheet.worksheet import Worksheet

# ===== –ö–æ–Ω—Ñ–∏–≥ =====
BASE_URL   = "https://allure-testops.wb.ru"
PROJECT_ID = 7
API_TOKEN  = "c60f6235-440d-4657-983a-51dc71c53cf2"

THIN = Side(style="thin", color="BDBDBD")
BORDER = Border(left=THIN, right=THIN, top=THIN, bottom=THIN)

DEPT_FILL = {
    "–ö–æ—Ä–∑–∏–Ω–∞":   PatternFill("solid", fgColor="00BFFF"),
    "–§–∏–Ω—Ç–µ—Ö":    PatternFill("solid", fgColor="FF0000"),
    "–ß–∞—Ç—ã":      PatternFill("solid", fgColor="66FF99"),
    "–í–•":        PatternFill("solid", fgColor="A7A7A7"),
    "–û—Å—Ç–∞–ª—å–Ω—ã–µ": PatternFill("solid", fgColor="AFEEEE"),
}
DEPT_FONT_COLOR = {"–ö–æ—Ä–∑–∏–Ω–∞":"000000","–§–∏–Ω—Ç–µ—Ö":"FFFFFF","–ß–∞—Ç—ã":"000000","–í–•":"000000","–û—Å—Ç–∞–ª—å–Ω—ã–µ":"000000"}

FILL_IOS     = PatternFill("solid", fgColor="EEE6FF")
FILL_ANDROID = PatternFill("solid", fgColor="E6FFE6")

CENTER = Alignment(vertical="center", horizontal="center")
LEFT   = Alignment(vertical="center", horizontal="left")
VERT90 = Alignment(vertical="center", horizontal="center", textRotation=90)

# ===== –í—Ä–µ–º—è -> Excel time =====
DAY_MS = 24 * 60 * 60 * 1000
def ms_to_excel_time(ms: int) -> float:
    return (ms or 0) / DAY_MS

# ===== HTTP =====
def build_session() -> requests.Session:
    s = requests.Session()
    s.headers.update({
        "Accept": "application/json",
        "Authorization": f"Api-Token {API_TOKEN}",
        "User-Agent": "allure-excel-export/3.0",
    })
    return s

def b64_query(q: List[Dict]) -> str:
    raw = json.dumps(q, ensure_ascii=False).encode("utf-8")
    return base64.b64encode(raw).decode("utf-8")

def fetch_launches(session: requests.Session, version: str, kind: str) -> List[Dict]:
    """–ü–æ–∏—Å–∫ –ª–∞—É–Ω—á–µ–π. –ü–æ–¥–¥–µ—Ä–∂–∫–∞ –Ω–æ–≤—ã—Ö –∏–º—ë–Ω –¥–æ–±–∞–≤–ª–µ–Ω–∞ —Ä–∞–Ω–µ–µ –≤ –≤—ã–±–æ—Ä–∫–µ."""
    print(f"[INFO] –ò—â—É —Ä–∞–Ω—ã: kind={kind}, –≤–µ—Ä—Å–∏—è={version}")

    terms = [f"[{kind}] –†–µ–≥—Ä–µ—Å—Å {version}"]
    if kind == "Smoke":
        terms.append(f"[High/Blocker][DeployLab] –†–µ–≥—Ä–µ—Å—Å {version}")
    if kind == "Selective":
        terms.append(f"[Selective][DeployLab] –†–µ–≥—Ä–µ—Å—Å {version}")

    result_by_id: Dict[int, Dict] = {}
    size = 1000
    for term in terms:
        search_b64 = b64_query([{"id":"name","type":"string","value":term}])
        page = 0
        while True:
            params = {"page":page,"size":size,"search":search_b64,
                      "projectId":PROJECT_ID,"preview":"true","sort":"createdDate,desc"}
            r = session.get(f"{BASE_URL}/api/launch", params=params, timeout=60)
            r.raise_for_status()
            data = r.json() or {}
            content = data.get("content") or []
            if not content:
                break
            for it in content:
                try:
                    result_by_id[int(it.get("id"))] = it
                except Exception:
                    pass
            if len(content) < size:
                break
            page += 1

    result = list(result_by_id.values())
    print(f"[INFO] –ù–∞–π–¥–µ–Ω–æ {len(result)} —Ä–∞–Ω–æ–≤ ({kind})")
    return result

def fetch_total_cases(session: requests.Session, launch_id: int) -> int:
    r = session.get(f"{BASE_URL}/api/launch/{launch_id}/statistic", timeout=60)
    r.raise_for_status()
    return sum(int(d.get("count", 0) or 0) for d in (r.json() or []))

def fetch_automated_total_cases(session: requests.Session, launch_id: int, tree_id: int = 14) -> int:
    search = b64_query([{"id":"automated","type":"boolean","value":True}])
    params = {"launchId": launch_id, "treeId": tree_id, "search": search, "sort": "duration,asc", "size": 1000}
    r = session.get(f"{BASE_URL}/api/testresulttree/group", params=params, timeout=60)
    r.raise_for_status()
    data = r.json() or {}
    total = 0
    for item in data.get("content", []):
        stat = item.get("statistic") or {}
        total += int(stat.get("total", 0) or 0)
    return total

def fetch_member_stats(session: requests.Session, launch_id: int) -> List[Dict]:
    params = {"size": 1000, "page": 0}
    r = session.get(f"{BASE_URL}/api/launch/{launch_id}/memberstats", params=params, timeout=60)
    r.raise_for_status()
    data = r.json() or []
    if isinstance(data, dict):
        return data.get("content") or []
    if isinstance(data, list):
        return data
    return []

class SwatStreamAgg(NamedTuple):
    swat_total: int
    stream_total: int
    swat_people: int
    stream_people: int
    swat_users: Set[str]
    stream_users: Set[str]
    swat_ms: int
    stream_ms: int

def swat_stream_agg(memberstats: List[Dict], swat_set: Set[str]) -> SwatStreamAgg:
    swat_total = 0
    stream_total = 0
    swat_users: Set[str] = set()
    stream_users: Set[str] = set()
    swat_ms = 0
    stream_ms = 0
    for m in memberstats:
        if not isinstance(m, dict):
            continue
        assignee = (m.get("assignee") or "").strip().lower()
        stat = m.get("statistic") or []
        total = 0
        for s in stat:
            if isinstance(s, dict):
                try:
                    total += int(s.get("count") or 0)
                except Exception:
                    pass
        dur_ms = int(m.get("durationSum") or 0)
        if total <= 0 and dur_ms <= 0:
            continue
        if assignee in swat_set:
            swat_total += total
            swat_users.add(assignee)
            swat_ms += dur_ms
        else:
            stream_total += total
            stream_users.add(assignee)
            stream_ms += dur_ms
    return SwatStreamAgg(swat_total, stream_total, len(swat_users), len(stream_users),
                         swat_users, stream_users, swat_ms, stream_ms)

def dept_of(name: str) -> str:
    low = name.lower()
    if "–∫–æ—Ä–∑–∏–Ω" in low: return "–ö–æ—Ä–∑–∏–Ω–∞"
    if "—Ñ–∏–Ω—Ç–µ—Ö" in low or "wbpay" in low or "–∫–æ—à–µ–ª–µ–∫" in low or "–∫–æ—à–µ–ª—å–∫–∞" in low: return "–§–∏–Ω—Ç–µ—Ö"
    if "—á–∞—Ç" in low: return "–ß–∞—Ç—ã"
    if "bx" in low or "–≤—Ö" in low: return "–í–•"
    return "–û—Å—Ç–∞–ª—å–Ω—ã–µ"

def platform_fill(name: str) -> PatternFill:
    if "[iOS]" in name: return FILL_IOS
    if "[Android]" in name: return FILL_ANDROID
    return PatternFill()

def sort_key(name: str):
    order = {"–ö–æ—Ä–∑–∏–Ω–∞":0, "–§–∏–Ω—Ç–µ—Ö":1, "–ß–∞—Ç—ã":2, "–í–•":3, "–û—Å—Ç–∞–ª—å–Ω—ã–µ":4}
    return (order.get(dept_of(name), 9), name.lower())

def read_swat_logins(path: str) -> Set[str]:
    if not os.path.exists(path):
        print(f"[WARN] SWAT.txt –Ω–µ –Ω–∞–π–¥–µ–Ω –ø–æ –ø—É—Ç–∏ {path}. –°—á–∏—Ç–∞—é –≤—Å–µ—Ö STREAM.")
        return set()
    vals: Set[str] = set()
    with open(path, "r", encoding="utf-8") as f:
        for line in f:
            t = line.strip()
            if not t:
                continue
            vals.add(t.lstrip("-‚Ä¢").strip().lower())
    print(f"[INFO] –ó–∞–≥—Ä—É–∂–µ–Ω–æ SWAT –ª–æ–≥–∏–Ω–æ–≤: {len(vals)}")
    return vals

NUMERIC_COLS = {3,4,5,6,7,8,9,10,11,12,13}

def auto_fit_columns(ws: Worksheet):
    for r in range(1, ws.max_row + 1):
        for c in range(1, ws.max_column + 1):
            ws.cell(r, c).alignment = CENTER
    for r in range(2, ws.max_row + 1):
        ws.cell(r, 2).alignment = LEFT
    for col in range(1, ws.max_column + 1):
        max_len = 0
        for r in range(1, ws.max_row + 1):
            v = ws.cell(r, col).value
            if v is None:
                continue
            max_len = max(max_len, len(str(v)))
        if col == 1:
            width = 6
        elif col in NUMERIC_COLS:
            width = max(5, min(max_len, 9))
        else:
            width = min(max(max_len + 2, 18), 80)
        ws.column_dimensions[get_column_letter(col)].width = width

def merge_dept_tabs(ws: Worksheet, r_start: int, r_end: int):
    r = r_start
    while r <= r_end:
        dept = ws.cell(r,1).value
        r2 = r
        while r2 + 1 <= r_end and ws.cell(r2+1,1).value == dept:
            r2 += 1
        ws.merge_cells(start_row=r, start_column=1, end_row=r2, end_column=1)
        fill = DEPT_FILL.get(dept, DEPT_FILL["–û—Å—Ç–∞–ª—å–Ω—ã–µ"])
        for rr in range(r, r2+1):
            c = ws.cell(rr,1); c.fill = fill; c.border = BORDER
        c = ws.cell(r,1)
        c.font = Font(bold=True, color=DEPT_FONT_COLOR.get(dept, "000000"))
        c.alignment = VERT90
        r = r2 + 1

# ===== –±—ã—Å—Ç—Ä—ã–π –±–ª–æ–∫ –ø–µ—Ä–µ–ø—Ä–æ—Ö–æ–¥–æ–≤ (–±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π) =====
import time, math, threading
from concurrent.futures import ThreadPoolExecutor, as_completed
from requests.adapters import HTTPAdapter
try:
    from urllib3.util.retry import Retry
except Exception:
    Retry = None

KINDS      = ("Smoke", "Selective")
PAGE_SIZE  = 1000
CPU = os.cpu_count() or 8
MAX_WORKERS = min(64, max(16, CPU * 4))
POOL_SIZE   = MAX_WORKERS * 2
REQ_TIMEOUT = (5, 45)
PROGRESS_PERIOD_SEC = 5.0

def build_session_fast() -> requests.Session:
    s = requests.Session()
    s.headers.update({
        "Accept": "application/json",
        "Authorization": f"Api-Token {API_TOKEN}",
        "Connection": "keep-alive",
        "User-Agent": "swat-rerun-analyzer/2.0-fast",
    })
    adapter_kwargs = {"pool_connections": POOL_SIZE, "pool_maxsize": POOL_SIZE}
    if Retry is not None:
        retry = Retry(total=2, backoff_factor=0.1, status_forcelist=[429, 500, 502, 503, 504])
        adapter_kwargs["max_retries"] = retry
    adapter = HTTPAdapter(**adapter_kwargs)
    s.mount("https://", adapter)
    s.mount("http://", adapter)
    return s

def _b64(obj) -> str:
    raw = json.dumps(obj, ensure_ascii=False).encode("utf-8")
    return base64.b64encode(raw).decode("ascii")

def _find_launches_fast(session: requests.Session, version: str) -> List[Dict]:
    launches: List[Dict] = []
    for kind in KINDS:
        terms = [f"[{kind}] –†–µ–≥—Ä–µ—Å—Å {version}"]
        if kind == "Smoke":
            terms.append(f"[High/Blocker][DeployLab] –†–µ–≥—Ä–µ—Å—Å {version}")
        if kind == "Selective":
            terms.append(f"[Selective][DeployLab] –†–µ–≥—Ä–µ—Å—Å {version}")
        for term in terms:
            search = _b64([{"id":"name","type":"string","value": term}])
            page = 0
            while True:
                params = {"page":page,"size":PAGE_SIZE,"search":search,
                          "projectId":PROJECT_ID,"preview":"true","sort":"createdDate,desc"}
                r = session.get(f"{BASE_URL}/api/launch", params=params, timeout=REQ_TIMEOUT)
                if r.status_code == 404:
                    break
                r.raise_for_status()
                data = r.json() or {}
                content = data.get("content") or []
                if not content:
                    break
                launches.extend(content)
                if len(content) < PAGE_SIZE:
                    break
                page += 1
    uniq: Dict[int, Dict] = {}
    for it in launches:
        try:
            uniq[int(it.get("id"))] = it
        except Exception:
            pass
    return list(uniq.values())

def _list_leaf_fast(session: requests.Session, launch_id: int) -> List[int]:
    url = f"{BASE_URL}/api/testresulttree/leaf"
    params = {"launchId": launch_id, "sort": "duration,asc", "size": PAGE_SIZE}
    ids: List[int] = []
    page = 0
    while True:
        params["page"] = page
        r = session.get(url, params=params, timeout=REQ_TIMEOUT)
        if r.status_code in (400, 404):
            break
        r.raise_for_status()
        data = r.json() or {}
        content = data.get("content") or []
        for item in content:
            _id = item.get("id")
            if _id is not None:
                ids.append(int(_id))
        if len(content) < PAGE_SIZE:
            break
        page += 1
    return ids

_core_cache: Dict[int, Tuple[int,str]] = {}
_core_lock = threading.Lock()

def _core_cached(session: requests.Session, result_id: int) -> Optional[Tuple[int,str]]:
    with _core_lock:
        if result_id in _core_cache:
            return _core_cache[result_id]
    r = session.get(f"{BASE_URL}/api/testresult/{result_id}", timeout=REQ_TIMEOUT)
    if r.status_code == 404:
        return None
    r.raise_for_status()
    data = r.json() or {}
    tcid  = int(data.get("testCaseId") or 0)
    tname = data.get("name") or ""
    with _core_lock:
        _core_cache[result_id] = (tcid, tname)
    return (tcid, tname)

def _retries(session: requests.Session, result_id: int) -> List[Dict]:
    url = f"{BASE_URL}/api/testresult/{result_id}/retries"
    params = {"size": PAGE_SIZE, "sort": "createdDate,desc"}
    r = session.get(url, params=params, timeout=REQ_TIMEOUT)
    if r.status_code in (400, 404):
        return []
    r.raise_for_status()
    data = r.json() or {}
    return data.get("content") or []

def _analyze_leaf(session: requests.Session, leaf_result_id: int, swat_set: Set[str]) -> bool:
    retries = _retries(session, leaf_result_id)
    if not retries:
        return False
    for item in retries:
        tb  = (item.get("testedBy") or "").strip().lower()
        lmb = (item.get("lastModifiedBy") or "").strip().lower()
        if not tb or not lmb or tb == lmb:
            continue
        if tb in swat_set:
            _ = _core_cached(session, leaf_result_id)
            return True
    return False

def _print_progress(done: int, total: int, t0: float):
    now = time.time()
    elapsed = max(1e-6, now - t0)
    rate = done / elapsed
    eta = (total - done) / rate if rate > 0 else float("inf")
    def _fmt(x: float) -> str:
        if not math.isfinite(x): return "‚Äî"
        m, s = divmod(int(x), 60)
        h, m = divmod(m, 60)
        if h: return f"{h}—á {m}–º {s}—Å"
        if m: return f"{m}–º {s}—Å"
        return f"{s}—Å"
    print(f"[{time.strftime('%H:%M:%S')}] –ü—Ä–æ–≥—Ä–µ—Å—Å: {done}/{total} "
          f"({done*100/total:.1f}%), ~{rate:.1f}/—Å, ETA {_fmt(eta)}", flush=True)

def count_rerun_by_stream_after_swat(version: str, swat_set: Set[str]) -> int:
    session = build_session_fast()
    launches = _find_launches_fast(session, version)
    if not launches:
        print("[RERUN] –õ–∞—É–Ω—á–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã –¥–ª—è —Ä–µ–ª–∏–∑–∞", version)
        return 0

    per_launch_results: Dict[int, List[int]] = {}
    total = 0
    for L in launches:
        lid = int(L.get("id"))
        ids = _list_leaf_fast(session, lid)
        per_launch_results[lid] = ids
        total += len(ids)

    all_leaf_ids: List[int] = []
    for lst in per_launch_results.values():
        all_leaf_ids.extend(lst)

    if not all_leaf_ids:
        print("[RERUN] –ù–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ —Ç–µ—Å—Ç–æ–≤ –≤ –Ω–∞–π–¥–µ–Ω–Ω—ã—Ö –ª–∞—É–Ω—á–∞—Ö.")
        return 0

    from threading import Lock
    done = 0
    lock = Lock()
    t0 = time.time()
    next_report = t0 + PROGRESS_PERIOD_SEC
    rerun_total = 0

    def worker(leaf_id: int):
        nonlocal done, next_report, rerun_total
        try:
            if _analyze_leaf(session, leaf_id, swat_set):
                with lock:
                    rerun_total += 1
        finally:
            with lock:
                done += 1
                if time.time() >= next_report:
                    _print_progress(done, len(all_leaf_ids), t0)
                    next_report = time.time() + PROGRESS_PERIOD_SEC

    max_workers = MAX_WORKERS
    with ThreadPoolExecutor(max_workers=max_workers) as ex:
        futures = [ex.submit(worker, rid) for rid in all_leaf_ids]
        for _ in as_completed(futures):
            pass

    _print_progress(len(all_leaf_ids), len(all_leaf_ids), t0)
    return rerun_total

# =============================== MAIN ===============================

def main(): 
    print("[INFO] –°–∫—Ä–∏–ø—Ç –∑–∞–ø—É—â–µ–Ω")
    version = input("–í–µ—Ä—Å–∏—è —Ä–µ–ª–∏–∑–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä 7.2.5000): ").strip()
    s = build_session()
    swat_set = read_swat_logins(os.path.join(os.path.dirname(os.path.abspath(__file__)), "SWAT.txt"))

    smoke     = fetch_launches(s, version, "Smoke")
    selective = fetch_launches(s, version, "Selective")

    def to_rows(launches):
        rows = []
        for L in sorted(launches, key=lambda z: sort_key(z.get("name",""))):
            name = L.get("name",""); lid = L.get("id")
            if not lid:
                continue
            total = fetch_total_cases(s, lid)
            auto  = fetch_automated_total_cases(s, lid)
            mstats = fetch_member_stats(s, lid)
            agg = swat_stream_agg(mstats, swat_set)
            print(f"[LAUNCH] id={lid} | total={total} | auto={auto} | "
                  f"swat={agg.swat_total} ({agg.swat_people}) {agg.swat_ms/3600000:.2f}—á | "
                  f"stream={agg.stream_total} ({agg.stream_people}) {agg.stream_ms/3600000:.2f}—á | {name}")
            rows.append((name, lid, f"{BASE_URL}/launch/{lid}", total, auto, agg))
        return rows

    wb = Workbook()
    ws = wb.active
    ws.title = "–†–∞–Ω—ã"
    ws.freeze_panes = "A2"

    headers = [
        (2, "–†–ê–ù"),
        (3, "–∫-–≤–æ –∫–µ–π—Å–æ–≤"),
        (4, "–∫-–≤–æ –ê–≤—Ç–æ"),
        (5, "–ü—Ä–æ–π–¥–µ–Ω–æ SWAT"),
        (6, "–ü—Ä–æ–π–¥–µ–Ω–æ STREAM"),
        (7, "–°–æ—Ç—Ä.SWAT"),
        (8, "–°–æ—Ç—Ä.STREAM"),
        (9, "% –ø–æ–∫—Ä—ã—Ç–∏—è SWAT"),
        (10, "–ß–ß SWAT"),
        (11, "–ß–ß STREAM"),
        (12, "–í—Ä–µ–º—è/–∫–µ–π—Å SWAT"),
        (13, "–í—Ä–µ–º—è/–∫–µ–π—Å STREAM"),
    ]
    for col, text in headers:
        cell = ws.cell(1, col, text)
        cell.font = Font(bold=True); cell.border = BORDER; cell.alignment = CENTER

    cur = 2

    def write_block(title: str, launches: List[Dict]):
        nonlocal cur
        rows = to_rows(launches)
        if not rows:
            return
        block_start = cur

        uniq_swat: Set[str] = set()
        uniq_stream: Set[str] = set()
        sum_swat_ms = 0
        sum_stream_ms = 0
        sum_swat_cnt = 0
        sum_stream_cnt = 0

        for name, lid, url, total, auto, agg in rows:
            ws.cell(cur, 1, dept_of(name))
            c2 = ws.cell(cur, 2, name); c2.hyperlink = url; c2.style = "Hyperlink"

            for col_idx, val in zip(range(3, 9), [total, auto, agg.swat_total, agg.stream_total, agg.swat_people, agg.stream_people]):
                cc = ws.cell(cur, col_idx, int(val or 0))
                cc.number_format = "0"

            manual_total = max(total - auto, 0)
            perc = (agg.swat_total / manual_total * 100) if manual_total > 0 else 0
            pc = ws.cell(cur, 9, round(perc, 2)); pc.number_format = '0.00'

            ws.cell(cur, 10, ms_to_excel_time(agg.swat_ms)).number_format   = "[h]:mm"
            ws.cell(cur, 11, ms_to_excel_time(agg.stream_ms)).number_format = "[h]:mm"

            swat_den   = agg.swat_total if agg.swat_total > 0 else 0
            stream_den = agg.stream_total if agg.stream_total > 0 else 0
            swat_per_ms   = int(agg.swat_ms / swat_den) if swat_den else 0
            stream_per_ms = int(agg.stream_ms / stream_den) if stream_den else 0
            ws.cell(cur, 12, ms_to_excel_time(swat_per_ms)).number_format   = "m:ss"
            ws.cell(cur, 13, ms_to_excel_time(stream_per_ms)).number_format = "m:ss"

            fill = platform_fill(name)
            for col in range(2, 14):
                cc = ws.cell(cur, col); cc.fill = fill; cc.border = BORDER

            uniq_swat.update(agg.swat_users)
            uniq_stream.update(agg.stream_users)
            sum_swat_ms += agg.swat_ms
            sum_stream_ms += agg.stream_ms
            sum_swat_cnt += agg.swat_total
            sum_stream_cnt += agg.stream_total

            cur += 1

        ws.cell(cur, 2, f"–ò—Ç–æ–≥–æ {title}")
        ws.cell(cur, 3, f"=SUM(C{block_start}:C{cur-1})").number_format = "0"
        ws.cell(cur, 4, f"=SUM(D{block_start}:D{cur-1})").number_format = "0"
        ws.cell(cur, 5, f"=SUM(E{block_start}:E{cur-1})").number_format = "0"
        ws.cell(cur, 6, f"=SUM(F{block_start}:F{cur-1})").number_format = "0"

        ws.cell(cur, 7, len(uniq_swat)).number_format   = "0"
        ws.cell(cur, 8, len(uniq_stream)).number_format = "0"

        ws.cell(cur, 9, f"=IF((C{cur}-D{cur})>0, E{cur}/(C{cur}-D{cur})*100, 0)").number_format = '0.00'

        ws.cell(cur, 10, ms_to_excel_time(sum_swat_ms)).number_format   = "[h]:mm"
        ws.cell(cur, 11, ms_to_excel_time(sum_stream_ms)).number_format = "[h]:mm"

        swat_den_block   = sum_swat_cnt if sum_swat_cnt > 0 else 0
        stream_den_block = sum_stream_cnt if sum_stream_cnt > 0 else 0
        swat_per_block_ms   = int(sum_swat_ms / swat_den_block) if swat_den_block else 0
        stream_per_block_ms = int(sum_stream_ms / stream_den_block) if stream_den_block else 0
        ws.cell(cur, 12, ms_to_excel_time(swat_per_block_ms)).number_format   = "m:ss"
        ws.cell(cur, 13, ms_to_excel_time(stream_per_block_ms)).number_format = "m:ss"

        for col in range(2, 14):
            cc = ws.cell(cur, col); cc.font = Font(bold=True); cc.border = BORDER
        cur += 1

        merge_dept_tabs(ws, block_start, cur-2)
        cur += 1

    smoke_rows_ios     = [x for x in smoke if "[iOS]" in x.get("name","")]
    smoke_rows_android = [x for x in smoke if "[Android]" in x.get("name","")]
    write_block("Smoke iOS",     smoke_rows_ios)
    write_block("Smoke Android", smoke_rows_android)
    cur += 1

    sel_rows_ios     = [x for x in selective if "[iOS]" in x.get("name","")]
    sel_rows_android = [x for x in selective if "[Android]" in x.get("name","")]
    write_block("Selective iOS",     sel_rows_ios)
    write_block("Selective Android", sel_rows_android)

    # ===== –°–≤–æ–¥–∫–∞ (–∏–∑–º–µ–Ω—ë–Ω –¢–û–õ–¨–ö–û –≤—ã–∑–æ–≤ –¥–ª—è Selective) =====
    last = cur - 1
    summary = cur + 1

    ws.cell(summary,  2, "")
    ws.cell(summary,  3, "–∫-–≤–æ –∫–µ–π—Å–æ–≤")
    ws.cell(summary,  4, "–∫-–≤–æ –ê–≤—Ç–æ")
    ws.cell(summary,  5, "–ü—Ä–æ–π–¥–µ–Ω–æ SWAT")
    ws.cell(summary,  6, "–∫-–≤–æ –†—É—á–Ω—ã–µ")
    ws.cell(summary,  7, "% –ø–æ–∫—Ä—ã—Ç–∏—è –±–µ–∑ –∞–≤—Ç–æ")
    ws.cell(summary,  8, "% –ø–æ–∫—Ä—ã—Ç–∏—è —Å –∞–≤—Ç–æ")
    for c in range(2, 9):
        cc = ws.cell(summary, c); cc.font = Font(bold=True); cc.border = BORDER; cc.alignment = CENTER

    def _sum_col(col_letter: str, *filters: str) -> str:
        base = f"{col_letter}2:{col_letter}{last}"
        not_total = f'B2:B{last},"<>–ò—Ç–æ–≥–æ *"'
        if not filters:
            return f"SUMIFS({base},{not_total})"
        parts = [f'SUMIFS({base},B2:B{last},"*[{flt}]*",{not_total})' for flt in filters]
        return "(" + "+".join(parts) + ")"

    def write_summary_row(r: int, title: str, *filters: str):
        ws.cell(r, 2, title).font = Font(bold=True)
        tests = _sum_col("C", *filters)
        auto  = _sum_col("D", *filters)
        swat  = _sum_col("E", *filters)
        ws.cell(r, 3, f"={tests}").number_format = "0"
        ws.cell(r, 4, f"={auto}").number_format  = "0"
        ws.cell(r, 5, f"={swat}").number_format  = "0"
        ws.cell(r, 6, f"=({tests})-({auto})").number_format = "0"
        ws.cell(r, 7, f"=IF(({tests})-({auto})>0, ({swat})/(({tests})-({auto})), 0)").number_format = "0.00%"
        ws.cell(r, 8, f"=IF(({tests})>0, ({swat})/({tests}), 0)").number_format = "0.00%"
        for c in range(2, 9):
            ws.cell(r, c).border = BORDER
            ws.cell(r, c).alignment = CENTER
        ws.cell(r, 2).alignment = LEFT

    # –í—Å–µ–≥–æ —Ç–µ—Å—Ç–æ–≤ (–≤—Å—ë)
    write_summary_row(summary + 1, "–í—Å–µ–≥–æ —Ç–µ—Å—Ç –∫–µ–π—Å–æ–≤")
    # Selective ‚Äî –¢–û–õ–¨–ö–û –ø–æ [Selective] (–±–µ–∑ –¥–æ–±–∞–≤–æ—á–Ω–æ–≥–æ —Ñ–∏–ª—å—Ç—Ä–∞), —á—Ç–æ–±—ã –Ω–µ –±—ã–ª–æ –¥—É–±–ª–µ–π
    write_summary_row(summary + 2, "–í—Å–µ–≥–æ —Ç–µ—Å—Ç –∫–µ–π—Å–æ–≤ Selective", "Selective")
    # Smoke = Smoke + High/Blocker][DeployLab
    write_summary_row(summary + 3, "–í—Å–µ–≥–æ —Ç–µ—Å—Ç –∫–µ–π—Å–æ–≤ Smoke", "Smoke", "High/Blocker][DeployLab")

    # –•–ë –ø–æ–∫—Ä—ã—Ç–∏–µ: (Smoke + High/Blocker) —Ä—É—á–Ω—ã–µ
    ws.cell(summary + 4, 2, "–ü—Ä–æ—Ü–µ–Ω—Ç –ø–æ–∫—Ä—ã—Ç–∏—è –∫–µ–π—Å–æ–≤ SWAT (–•–ë)").font = Font(bold=True)
    numer_smoke_swat = "(" \\
        f"SUMIFS(E2:E{last},B2:B{last},\\"*[Smoke]*\\",B2:B{last},\\"<>–ò—Ç–æ–≥–æ *\\")+" \\
        f"SUMIFS(E2:E{last},B2:B{last},\\"*[High/Blocker][DeployLab]*\\",B2:B{last},\\"<>–ò—Ç–æ–≥–æ *\\")" \\
        ")"
    denom_smoke_manual = "(" \\
        f"(SUMIFS(C2:C{last},B2:B{last},\\"*[Smoke]*\\",B2:B{last},\\"<>–ò—Ç–æ–≥–æ *\\")+" \\
        f"SUMIFS(C2:C{last},B2:B{last},\\"*[High/Blocker][DeployLab]*\\",B2:B{last},\\"<>–ò—Ç–æ–≥–æ *\\"))-" \\
        f"(SUMIFS(D2:D{last},B2:B{last},\\"*[Smoke]*\\",B2:B{last},\\"<>–ò—Ç–æ–≥–æ *\\")+" \\
        f"SUMIFS(D2:D{last},B2:B{last},\\"*[High/Blocker][DeployLab]*\\",B2:B{last},\\"<>–ò—Ç–æ–≥–æ *\\"))" \\
        ")"
    ws.cell(summary + 4, 7, f"=IF({denom_smoke_manual}>0, {numer_smoke_swat}/{denom_smoke_manual}, 0)").number_format = "0.00%"
    for c in range(3, 9):
        ws.cell(summary + 4, c).border = BORDER
        ws.cell(summary + 4, c).alignment = CENTER

    # –•–ë + Selective (–≥–¥–µ SWAT>0)
    ws.cell(summary + 5, 2, "–ü—Ä–æ—Ü–µ–Ω—Ç –ø–æ–∫—Ä—ã—Ç–∏—è –∫–µ–π—Å–æ–≤ SWAT (–•–ë + Selective), –í—Å–µ –∑–∞–ø—É—Å–∫–∏ –≥–¥–µ —É—á–∞—Å—Ç–≤–æ–≤–∞–ª–∏ SWAT").font = Font(bold=True)
    numer, denom = 0, 0
    for r in range(2, last + 1):
        name = str(ws.cell(r, 2).value or "")
        if "–ò—Ç–æ–≥–æ " in name:
            continue
        is_smoke_or_hb = ("[Smoke]" in name) or ("[High/Blocker][DeployLab]" in name)
        is_selective   = ("[Selective]" in name)
        if not (is_smoke_or_hb or is_selective):
            continue
        swat  = int(ws.cell(r, 5).value or 0)
        total = int(ws.cell(r, 3).value or 0)
        auto  = int(ws.cell(r, 4).value or 0)
        if swat > 0:
            numer += swat
            manual = total - auto
            if manual > 0:
                denom += manual
    ws.cell(summary + 5, 7, (numer / denom) if denom > 0 else 0.0).number_format = "0.00%"
    for c in range(3, 9):
        ws.cell(summary + 5, c).border = BORDER
        ws.cell(summary + 5, c).alignment = CENTER

    # –° —É—á—ë—Ç–æ–º –ø–µ—Ä–µ–ø—Ä–æ—Ö–æ–¥–∞ STREAM
    ws.cell(summary + 6, 2, "–ü—Ä–æ—Ü–µ–Ω—Ç –ø–æ–∫—Ä—ã—Ç–∏—è –∫–µ–π—Å–æ–≤ SWAT —Å —É—á–µ—Ç–æ–º –ø–µ—Ä–µ–ø—Ä–æ—Ö–æ–¥–∞ STREAM").font = Font(bold=True)
    rerun_count = count_rerun_by_stream_after_swat(version, swat_set)
    ws.cell(summary + 6, 3, rerun_count).number_format = "0"
    ws.cell(summary + 6, 7, ((numer + rerun_count) / denom) if denom > 0 else 0.0).number_format = "0.00%"
    for c in range(2, 9):
        ws.cell(summary + 6, c).border = BORDER
        ws.cell(summary + 6, c).alignment = CENTER
    ws.cell(summary + 6, 2).alignment = LEFT

    auto_fit_columns(ws)
    fn = f"–û—Ç—á–µ—Ç_–†–∞–Ω—ã_{version}_{datetime.now().strftime('%Y%m%d-%H%M')}.xlsx"
    wb.save(fn)
    print(f"[OK] –§–∞–π–ª —Å–æ—Ö—Ä–∞–Ω—ë–Ω: {fn}")
    input("[–ì–û–¢–û–í–û] –ù–∞–∂–º–∏—Ç–µ Enter –¥–ª—è –≤—ã—Ö–æ–¥–∞...")

if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        import traceback
        print("[ERROR]", e)
        traceback.print_exc()
        input("\\n[–ì–û–¢–û–í–û] –ù–∞–∂–º–∏—Ç–µ Enter –¥–ª—è –≤—ã—Ö–æ–¥–∞...")
`;</script>







































<script id="rr-stream-select">
(function(){
  if (window.__rrStreamSelectInstalledDDv10) return;
  window.__rrStreamSelectInstalledDDv10 = true;

  function $ (sel,root=document){return root.querySelector(sel)}
  function $$ (sel,root=document){return Array.from(root.querySelectorAll(sel))}

  // ---------- Robust stream harvesting ----------
  function extractFromText(s){
    if (!s || typeof s!=='string') return [];
    const res = [];
    const re1 = /\[\s*Stream\s+([^\]|]+?)\]/gi;
    const re2 = /(?:^|\s)Stream\s+([A-Za-z–ê-–Ø–∞-—è0-9 _()\-\/]+?)(?=\s|,|$)/gi;
    let m;
    while ((m = re1.exec(s))) res.push(m[1].trim());
    while ((m = re2.exec(s))) res.push(m[1].trim());
    return res;
  }

  function harvestStreamsFromWindow(){
    const set = new Set();
    try{
      for (const k of Object.getOwnPropertyNames(window)){
        const v = window[k];
        if (Array.isArray(v)){
          for (const it of v){
            if (it && typeof it === 'object'){
              for (const val of Object.values(it)){
                if (typeof val === 'string'){
                  extractFromText(val).forEach(s => set.add(s));
                }
              }
            } else if (typeof it === 'string'){
              extractFromText(it).forEach(s => set.add(s));
            }
          }
        } else if (v && typeof v === 'object'){
          const vals = Object.values(v);
          for (const val of vals){
            if (typeof val === 'string'){
              extractFromText(val).forEach(s => set.add(s));
            }
          }
        }
      }
    }catch(e){/* sandbox objects may throw */}
    return Array.from(set);
  }

  function harvestStreamsFromJsonScripts(){
    const set = new Set();
    $$('script[type="application/json"], script[type="application/ld+json"]')
      .forEach(scr=>{
        try{
          const txt = scr.textContent || '';
          extractFromText(txt).forEach(s => set.add(s));
          const data = JSON.parse(txt);
          const walk = (x)=>{
            if (!x) return;
            if (typeof x === 'string'){ extractFromText(x).forEach(s=>set.add(s)); return; }
            if (Array.isArray(x)) x.forEach(walk);
            else if (typeof x === 'object') Object.values(x).forEach(walk);
          };
          walk(data);
        }catch(_){/* ignore */}
      });
    return Array.from(set);
  }

  function harvestStreamsFromDOM(){
    const set = new Set();
    const allText = document.body ? document.body.textContent || '' : '';
    extractFromText(allText).forEach(s=> set.add(s));
    return Array.from(set);
  }

  function getAllStreams(){
  // –ò—Å—Ç–æ—á–Ω–∏–∫ –∏—Å—Ç–∏–Ω—ã ‚Äî —Ç–µ–∫—É—â–∏–µ –º–∏–Ω–∏-–∫–∞—Ä—Ç–æ—á–∫–∏ –≤ miniGrid
  try{
    const {grid} = findMiniSection();
    const set = new Set();
    if (grid){
      const cards = collectCards(grid);
      cards.forEach(c=>{
        const s = (c.dataset && c.dataset.stream) ? c.dataset.stream : detectStreamFromCard(c);
        if (s) set.add(String(s).trim());
      });
    }
    if (set.size) return Array.from(set).sort((a,b)=> a.localeCompare(b,'ru'));
  }catch(_){}
  // –§–æ–ª–±—ç–∫ (–µ—Å–ª–∏ –µ—â—ë –Ω–µ –æ—Ç—Ä–∏—Å–æ–≤–∞–Ω–æ)
  const merged = new Set();
  try{ harvestStreamsFromWindow().forEach(s=> merged.add(s)); }catch(_){}
  try{ harvestStreamsFromJsonScripts().forEach(s=> merged.add(s)); }catch(_){}
  try{ harvestStreamsFromDOM().forEach(s=> merged.add(s)); }catch(_){}
  if (!merged.size) merged.add('–ü—Ä–æ—á–µ–µ');
  return Array.from(merged).sort((a,b)=> a.localeCompare(b,'ru'));
}
}

  // ---------- Show-count control helpers ----------
  function findShowControl(toolbar){
    // try to find the select responsible for "–ü–æ–∫–∞–∑–∞—Ç—å"
    // look for nearest select that has only numbers as options
    let selects = Array.from(toolbar.querySelectorAll('select'));
    // also scan whole mini section head
    const head = toolbar.closest('.head') || toolbar.parentElement;
    if (head) selects = selects.concat(Array.from(head.querySelectorAll('select')));
    let numericSelects = selects.filter(s=> {
      const opts = Array.from(s.options||[]).map(o=>o.textContent.trim());
      return opts.length>0 && opts.every(t=> /^\d+$/.test(t));
    });
    if (numericSelects.length) return numericSelects[0];
    return null;
  }

  function tryOpenShowDropdown(toolbar){
    // Heuristic: find label "–ü–æ–∫–∞–∑–∞—Ç—å" and click next control
    const labelNodes = Array.from(toolbar.querySelectorAll('*')).filter(n=>/–ü–æ–∫–∞–∑–∞—Ç—å/i.test(n.textContent||''));
    let control = null;
    for (const n of labelNodes){
      // look for next sibling or parent siblings that are controls
      const sibs = [n.nextElementSibling, n.parentElement && n.parentElement.nextElementSibling].filter(Boolean);
      for (const s of sibs){
        if (!s) continue;
        if (s.tagName === 'SELECT' || s.matches('input[type="number"], [role="listbox"], [data-state="closed"], .select, .dropdown')) {
          control = s; break;
        }
        const btn = s.querySelector('button, [role="button"]');
        if (btn){ control = btn; break; }
      }
      if (control) break;
    }
    if (!control){
      // last resort: any button near that looks like numeric selector
      control = Array.from(toolbar.querySelectorAll('button, [role="button"]')).find(b=>{
        const t = (b.textContent||'').trim();
        return /^\d+$/.test(t) || /–ü–æ–∫–∞–∑–∞—Ç—å/i.test(t);
      });
    }
    if (control){
      control.click();
      // try to pick biggest number from any open menu
      setTimeout(()=>{
        const menus = Array.from(document.querySelectorAll('[role="listbox"], [role="menu"], .dropdown-menu, .select__menu, .menu'));
        let best = null, bestN = -1;
        menus.forEach(m=>{
          const opts = Array.from(m.querySelectorAll('[role="option"], li, button, div')).filter(x=>{
            const t=(x.textContent||'').trim();
            return /^\d+$/.test(t);
          });
          opts.forEach(x=>{
            const n = parseInt(x.textContent.trim(),10);
            if (n>bestN){ bestN=n; best=x; }
          });
        });
        if (best){ best.click(); }
      }, 60);
      return true;
    }
    return false;
  }

  function ensureMaxShown(toolbar, active){
    const sel = findShowControl(toolbar);
    if (!sel) { tryOpenShowDropdown(toolbar); return false; }
    if (active){
      // set to the largest option
      const nums = Array.from(sel.options).map(o=>parseInt(o.textContent,10)).filter(n=>!isNaN(n));
      if (!nums.length) return false;
      const max = Math.max.apply(null, nums);
      const current = parseInt(sel.value || sel.selectedOptions?.[0]?.textContent || '0', 10);
      if (current !== max){
        // try set by value or by index
        const opt = Array.from(sel.options).find(o=>parseInt(o.textContent,10)===max);
        if (opt){ sel.value = opt.value; opt.selected = true; }
        sel.dispatchEvent(new Event('change', {bubbles:true}));
        sel.dispatchEvent(new Event('input', {bubbles:true}));
        // click any "–ü–æ–∫–∞–∑–∞—Ç—å" button if exists
        const btn = (toolbar.querySelector('button')||{});
        const btns = Array.from(toolbar.querySelectorAll('button')).filter(b=>/–ü–æ–∫–∞–∑–∞—Ç—å/i.test(b.textContent));
        if (btns.length) btns[0].click();
        return true;
      }
    }
    return false;
  }

  // ------------- Mini section locating & cards -------------
  function findMiniSection(){
    const root = document.getElementById('miniLaunchCard') || document;
    const toolbar = root.querySelector('.head .export') || root.querySelector('.mini-toolbar') || root.querySelector('.head');
    const grid = root.querySelector('#miniGrid') ||
                 root.querySelector('[data-mini-grid]') ||
                 root.querySelector('.mini-grid') ||
                 root.querySelector('.cards') ||
                 root.querySelector('.grid');
    return {root, toolbar, grid};
  }

  function collectCards(grid){
    if (!grid) return [];
    let cards = $$('[data-mini-card], .mini-card, .miniCard, .card', grid);
    cards = cards.filter(el => {
      const t = (el.textContent||'').trim();
      return el.querySelector('svg') || /%|–ü—Ä–æ–π–¥–µ–Ω–æ/i.test(t);
    });
    cards.forEach(el=> el.classList.add('miniCard'));
    return cards;
  }

  function detectStreamFromCard(el){
    const titleNode = el.querySelector('[data-title], .title, h4, h5, .card-title') || el;
    const txt = (titleNode.textContent || el.textContent || '').replace(/\s+/g,' ');
    const m = txt.match(/\[\s*Stream\s+([^\]|]+?)]/i) || txt.match(/Stream\s+([A-Za-z–ê-–Ø–∞-—è0-9 _()\-\/]+?)(?:\s|,|$)/i);
    return m ? m[1].trim() : '–ü—Ä–æ—á–µ–µ';
  }

  // ------------- Dropdown mount -------------
  function mount(){
    const {toolbar, grid} = findMiniSection();
    if (!toolbar || !grid) return false;
    if ($('#rrStreamDD', toolbar)) return true;

    const cards = collectCards(grid);
    // assign data-stream for current cards (if —É–∂–µ –µ—Å—Ç—å)
    cards.forEach(c=> c.dataset.stream = c.dataset.stream || detectStreamFromCard(c));

    // –ë–µ—Ä—ë–º —Å—Ç—Ä–∏–º—ã –∏–∑ —Ç–µ–∫—É—â–∏—Ö –º–∏–Ω–∏-–∫–∞—Ä—Ç–æ—á–µ–∫ (–º–æ–≥—É—Ç –ø–æ—è–≤–∏—Ç—å—Å—è –ø–æ–∑–∂–µ)
    const allStreams = getAllStreams();

    const dd = document.createElement('div');
    dd.className = 'rr-stream-dd';
    dd.id = 'rrStreamDD';
    dd.innerHTML = `
      <button type="button" class="rr-dd-trigger" aria-haspopup="listbox" aria-expanded="false">
        <span>–°—Ç—Ä–∏–º—ã</span>
        <span class="rr-badge" id="rrDDCount">–í—Å–µ</span>
        <svg width="16" height="16" viewBox="0 0 20 20" fill="none"><path d="M5 7l5 6 5-6" stroke="#6b15d6" stroke-width="1.6" stroke-linecap="round"/></svg>
      </button>
      <div class="rr-dd-menu" role="listbox" aria-label="–°—Ç—Ä–∏–º—ã">
        <div class="rr-dd-item"><input type="checkbox" value="__ALL__" id="rrAll"><label for="rrAll">–í—Å–µ</label></div>
        ${allStreams.map((s,i)=>`
          <div class="rr-dd-item">
            <input type="checkbox" value="${s}" id="rrS${i}">
            <label for="${s.replace(/"/g,'&quot;')}" for="rrS${i}">${s}</label>
          </div>`).join('')}
      </div>`;
    (function(){
      const plat = toolbar.querySelector('#miniPlatform');
      if (plat && plat.parentElement) {
        plat.parentElement.insertAdjacentElement('afterend', dd);
      } else {
        toolbar.appendChild(dd);
      }
    })();

    const btn   = $('.rr-dd-trigger', dd);
    const menu  = $('.rr-dd-menu', dd);
    const count = $('#rrDDCount', dd);
    const allCb = $('#rrAll', dd);
    const cbs   = $$('input[type="checkbox"]', menu).filter(x=>x!==allCb);

    const KEY = 'mini_streams_filter_v2';

    // build options list (idempotent)
    function refreshOptions(){
      const streams = getAllStreams();
      const saved = (localStorage.getItem(KEY)||'').split('|').filter(Boolean);
      const listHtml = streams.map((s,i)=>`
        <div class="rr-dd-item">
          <input type="checkbox" value="${s}" id="rrS${i}" ${saved.length ? (saved.includes(s)?'checked':'') : 'checked'}>
          <label for="rrS${i}">${s}</label>
        </div>`).join('');
      // keep "–í—Å–µ" on top; rebuild rest
      const items = menu.querySelectorAll('.rr-dd-item');
      items.forEach((it,idx)=>{ if (idx>0) it.remove(); });
      menu.insertAdjacentHTML('beforeend', listHtml);
    }

    refreshOptions(); // –ø–µ—Ä–≤–∏—á–Ω–∞—è –æ—Ç—Ä–∏—Å–æ–≤–∫–∞
    const cbsDyn = ()=> $$('input[type="checkbox"]', menu).filter(x=>x!==allCb);
    // Force default "–ü–æ–∫–∞–∑–∞—Ç—å" equal to number of streams
    ensureMaxShown(toolbar, true);

    const KEY = 'mini_streams_filter';
    const saved = (localStorage.getItem(KEY)||'').split('|').filter(Boolean);
    if (saved.length){
      // –æ—Ç–º–µ—Ç–∏–º –ø–æ–∑–∂–µ –≤ refreshOptions(); –∑–¥–µ—Å—å —Ç–æ–ª—å–∫–æ —Ñ–ª–∞–≥ '–í—Å–µ'
      allCb.checked = false;
    } else {
      allCb.checked = true;
    }

    function apply(){
      const cbs = cbsDyn();
      // –µ—Å–ª–∏ –≤—ã–±—Ä–∞–Ω —Ö–æ—Ç—è –±—ã –æ–¥–∏–Ω —Å—Ç—Ä–∏–º, —Å—Ç–∞–≤–∏–º –ü–æ–∫–∞–∑–∞—Ç—å=–º–∞–∫—Å–∏–º—É–º
      const hasSelection = !allCb.checked && cbs.some(cb=>cb.checked);
      ensureMaxShown(toolbar, hasSelection);
      const selected = cbs.filter(cb=>cb.checked).map(cb=>cb.value);
      const all = allCb.checked || selected.length===0;
      // ensure every current card has dataset.stream
      collectCards(grid).forEach(c=>{
        c.dataset.stream = c.dataset.stream || detectStreamFromCard(c);
        c.classList.toggle('hide', !all && !selected.includes(c.dataset.stream));
      });
      count.textContent = all ? '–í—Å–µ' : String(selected.length);
      localStorage.setItem(KEY, all ? '' : selected.join('|'));
    }

    btn.addEventListener('click', ()=>{
      const open = menu.classList.toggle('open');
      btn.setAttribute('aria-expanded', open ? 'true' : 'false');
    });

    menu.addEventListener('click', (e)=>{
      const t = e.target;
      if (t.tagName === 'INPUT'){
        const cbs = cbsDyn();
        if (t === allCb){
          if (allCb.checked){ cbs.forEach(cb=> cb.checked = false); }
        } else {
          if (t.checked){ allCb.checked = false; }
          else if (!cbs.some(cb=>cb.checked)){ allCb.checked = true; }
        }
        apply(); // –º–µ–Ω—é –Ω–µ –∑–∞–∫—Ä—ã–≤–∞–µ–º
      }
    });

    document.addEventListener('click', (e)=>{
      if (!dd.contains(e.target)) { menu.classList.remove('open'); btn.setAttribute('aria-expanded','false'); }
    });

    apply();

    // react to grid changes
    const mo = new MutationObserver(()=>{ refreshOptions(); apply(); });
    mo.observe(grid, {childList:true, subtree:true});
    return true;
  }

  function init(){
    mount();
  }

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', init);
  } else { init(); }
  // Watchdog: if dropdown disappears due to toolbar re-render, remount it
  setInterval(()=>{
    try{
      const {toolbar} = findMiniSection();
      if (!toolbar) return;
      if (!toolbar.querySelector('#rrStreamDD')) { mount(); }
    }catch(_){}
  }, 1500);


  const sec = document.getElementById('miniLaunchCard');
  if (sec){
    const mo2 = new MutationObserver(()=> mount());
    mo2.observe(sec, {childList:true, subtree:true});
  }
})();
</script>








<!-- START: Safe standalone "–°—Ç—Ä–∏–º—ã" multiselect (injected by assistant) -->


<script>
(function(){
  // Safe wrapper: errors inside will not break the page
  try{
    const LOCAL_KEY = 'mini_streams_selection_v1';
    const DROPDOWN_ID = 'rrStreamDD_safe_v1';
    const RETRY_INTERVAL_MS = 800;
    const MAX_RETRIES = 40;

    function safe$(sel, root=document){ try{ return root.querySelector(sel); }catch(_){ return null; } }
    function safe$all(sel, root=document){ try{ return Array.from(root.querySelectorAll(sel)); }catch(_){ return []; } }

    function findContext(){
      const root = document.getElementById('miniLaunchCard') || document;
      const toolbar = (root.querySelector('.head .export') || root.querySelector('.head') || root.querySelector('.mini-toolbar')) || null;
      const grid = (root.querySelector('#miniGrid') || root.querySelector('.mini-grid') || root.querySelector('[data-mini-grid]') || root.querySelector('.cards') || root.querySelector('.grid')) || null;
      return {root, toolbar, grid};
    }

    function collectCards(grid){
      if(!grid) return [];
      const candidates = safe$all('[data-mini-card], .mini-card, .miniCard, .card', grid);
      return candidates.filter(el=>{
        try{
          if(el.querySelector('svg, canvas')) return true;
          const txt = (el.textContent||'').trim();
          if(/%|–ü—Ä–æ–π–¥–µ–Ω–æ|–ü—Ä–æ–π—à–ª–æ|–ü—Ä–æ—à–ª–æ/i.test(txt)) return true;
          return false;
        }catch(_){ return false; }
      });
    }

    function detectStreamFromCard(el){
      try{
        if(!el) return '–ü—Ä–æ—á–µ–µ';
        if(el.dataset && el.dataset.stream) return el.dataset.stream.trim();
        const titleNode = el.querySelector('[data-title], .title, h4, h5, .card-title') || el.querySelector('div') || el;
        const txt = (titleNode.textContent || el.textContent || '').replace(/\s+/g,' ').trim();
        const m = txt.match(/\[\s*Stream\s+([^\]|]+?)]/i) || txt.match(/Stream\s+([A-Za-z–ê-–Ø–∞-—è0-9 _()\-\/]+?)(?:\s|,|$)/i);
        if(m && m[1]) return m[1].trim();
        return txt.split('\n')[0].slice(0,60).trim() || '–ü—Ä–æ—á–µ–µ';
      }catch(_){ return '–ü—Ä–æ—á–µ–µ'; }
    }

    function mountDropdown(toolbar, grid){
      if(!toolbar) return null;
      if(safe$('#'+DROPDOWN_ID, toolbar)) return safe$('#'+DROPDOWN_ID, toolbar);

      const dd = document.createElement('div');
      dd.id = DROPDOWN_ID;
      dd.className = 'rr-stream-dd';
      dd.innerHTML = ''
        + '<button class="rr-dd-trigger" aria-expanded="false">'
        + '  <span>–°—Ç—Ä–∏–º—ã</span>'
        + '  <span class="rr-badge" id="rrCount_safe">0</span>'
        + '</button>'
        + '<div class="rr-dd-menu" role="menu" aria-label="–°—Ç—Ä–∏–º—ã">'
        + '  <div class="rr-dd-actions"><button class="rr-small-btn" data-act="all">–í—Å–µ</button><button class="rr-small-btn" data-act="none">–°–±—Ä–æ—Å</button></div>'
        + '  <div class="rr-dd-list"></div>'
        + '</div>';

      try{
        const plat = toolbar.querySelector('#miniPlatform');
        if(plat && plat.parentElement) plat.parentElement.insertAdjacentElement('afterend', dd);
        else toolbar.appendChild(dd);
      }catch(_){
        toolbar.appendChild(dd);
      }

      attachHandlers(dd, grid);
      refreshOptions(dd, grid);
      return dd;
    }

    function refreshOptions(dd, grid){
      if(!dd) return;
      try{
        const list = dd.querySelector('.rr-dd-list');
        const cards = collectCards(grid || (document.getElementById('miniGrid') || document.querySelector('.mini-grid') || document.querySelector('[data-mini-grid]')));
        const set = new Set();
        cards.forEach(c=>{
          try{
            const name = detectStreamFromCard(c);
            if(name) set.add(name);
            if(!c.dataset.stream) c.dataset.stream = name;
          }catch(_){}
        });
        const streams = Array.from(set).sort((a,b)=> a.localeCompare(b,'ru'));
        const saved = (localStorage.getItem(LOCAL_KEY)||'').split('|').filter(Boolean);

        if(streams.length === 0){
          list.innerHTML = '<div style="padding:8px;color:#777">–ù–µ—Ç —Å—Ç—Ä–∏–º–æ–≤</div>';
          const cnt = dd.querySelector('#rrCount_safe'); if(cnt) cnt.textContent = '0';
          return;
        }

        const html = streams.map((s,i)=> {
          const safeId = 'rr_safe_cb_' + i;
          const checkedAttr = saved.length ? (saved.indexOf(s) !== -1 ? 'checked' : '') : 'checked';
          return '<div class="rr-dd-item" data-stream="'+escapeHtml(s)+'" style="display:flex;align-items:center">'
            + '<input type="checkbox" id="'+safeId+'" value="'+escapeHtml(s)+'" '+checkedAttr+'>'
            + '<label for="'+safeId+'">'+escapeHtml(s)+'</label>'
            + '</div>';
        }).join('');
        list.innerHTML = html;
        const cnt = dd.querySelector('#rrCount_safe'); if(cnt) cnt.textContent = String(streams.length);
      }catch(e){
        console.warn('rr-safe: refreshOptions error', e && e.message);
      }
    }

    function escapeHtml(s){
      return String(s).replace(/[&<>"']/g, m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
    }

    function attachHandlers(dd, grid){
      try{
        const btn = dd.querySelector('.rr-dd-trigger');
        const menu = dd.querySelector('.rr-dd-menu');
        const list = dd.querySelector('.rr-dd-list');
        if(!btn || !menu || !list) return;

        btn.addEventListener('click', function(e){
          try{
            const open = menu.classList.toggle('open');
            btn.setAttribute('aria-expanded', open ? 'true' : 'false');
            e.stopPropagation();
          }catch(_){}
        });

        document.addEventListener('click', function(e){
          try{
            if(!dd.contains(e.target)){
              menu.classList.remove('open');
              btn.setAttribute('aria-expanded','false');
            }
          }catch(_){}
        });

        dd.querySelectorAll('.rr-small-btn').forEach(function(b){
          b.addEventListener('click', function(e){
            try{
              const act = b.getAttribute('data-act');
              const cbs = Array.from(list.querySelectorAll('input[type=checkbox]'));
              if(act === 'all') cbs.forEach(cb=>cb.checked = true);
              else if(act === 'none') cbs.forEach(cb=>cb.checked = false);
              applyFilter(dd, grid);
              e.stopPropagation();
            }catch(_){}
          });
        });

        list.addEventListener('click', function(e){
          try{
            const t = e.target;
            if(t && t.matches && t.matches('input[type=checkbox]')){
              applyFilter(dd, grid);
            }
          }catch(_){}
        });

      }catch(e){
        console.warn('rr-safe: attachHandlers error', e && e.message);
      }
    }

    function applyFilter(dd, grid){
      try{
        const list = dd.querySelector('.rr-dd-list');
        if(!list) return;
        const cbs = Array.from(list.querySelectorAll('input[type=checkbox]'));
        const selected = cbs.filter(cb=>cb.checked).map(cb=>cb.value);
        const all = (selected.length === 0) || (selected.length === cbs.length);
        try{ localStorage.setItem(LOCAL_KEY, all ? '' : selected.join('|')); }catch(_){}
        const cards = collectCards(grid || (document.getElementById('miniGrid') || document.querySelector('.mini-grid') || document.querySelector('[data-mini-grid]')));
        cards.forEach(c=>{
          try{
            const s = c.dataset.stream || detectStreamFromCard(c);
            const ok = all || selected.indexOf(s) !== -1;
            c.classList.toggle('hide', !ok);
          }catch(_){}
        });
        const cnt = dd.querySelector('#rrCount_safe');
        if(cnt) cnt.textContent = all ? String(cbs.length) : String(selected.length);
      }catch(e){
        console.warn('rr-safe: applyFilter error', e && e.message);
      }
    }

    (function startMount(){
      let retries = 0;
      const root = document.getElementById('miniLaunchCard') || document;
      function tryOnce(){
        try{
          const {toolbar, grid} = findContext();
          if(toolbar){
            const dd = mountDropdown(toolbar, grid);
            const gridNode = grid || document.getElementById('miniGrid') || document.querySelector('.mini-grid') || document.querySelector('[data-mini-grid]');
            if(gridNode && !gridNode._rr_safe_observed){
              try{
                const mo = new MutationObserver(function(){ try{ refreshOptions(dd, gridNode); applyFilter(dd, gridNode); }catch(_){ } });
                mo.observe(gridNode, {childList:true, subtree:true});
                gridNode._rr_safe_observed = true;
              }catch(_){}
            }
            try{ applyFilter(dd, grid); }catch(_){}
            return true;
          }
        }catch(_){}
        return false;
      }

      if(tryOnce()) return;
      const iv = setInterval(function(){
        retries++;
        if(tryOnce() || retries > MAX_RETRIES){ clearInterval(iv); }
      }, RETRY_INTERVAL_MS);

      try{
        const container = document.getElementById('miniLaunchCard') || document.body;
        const mo2 = new MutationObserver(function(mutations){
          try{
            const {toolbar} = findContext();
            if(!toolbar) return;
            if(!safe$('#'+DROPDOWN_ID, toolbar)) {
              mountDropdown(toolbar, findContext().grid);
            } else {
              refreshOptions(safe$('#'+DROPDOWN_ID, toolbar), findContext().grid);
            }
          }catch(_){}
        });
        mo2.observe(container, {childList:true, subtree:true});
      }catch(_){}
    })();

  }catch(e){
    try{ console.warn('rr-safe: fatal initialization error', e && e.message); }catch(_){}
  }
})(); 
</script>
<!-- END: Safe standalone "–°—Ç—Ä–∏–º—ã" multiselect (injected by assistant) -->


<!-- START: remove duplicate empty "–°—Ç—Ä–∏–º—ã (0)" buttons (injected) -->


<script>
(function(){
  function ready(fn){ if(document.readyState!=='loading') fn(); else document.addEventListener('DOMContentLoaded', fn); }
  ready(function(){
    const rel = document.getElementById('swatRelease');
    const tok = document.getElementById('swatApiToken');
    try{
      if(rel){ rel.value = localStorage.getItem('swat_release') || rel.value || ''; rel.addEventListener('input', e=> localStorage.setItem('swat_release', e.target.value)); }
      if(tok){ tok.value = localStorage.getItem('swat_token') || tok.value || ''; tok.addEventListener('input', e=> localStorage.setItem('swat_token', e.target.value)); }
    }catch(_){}
  });
})();

</script>


<script>
(function(){
  // Remove code-dump artifacts that sometimes appear at the very end
  function isDumpNode(node){
    if(!node) return false;
    if(node.nodeType===3){
      var t=node.textContent||"";
      return t.length>200 && (t.includes("function")||t.includes("var ")||t.includes("=>")) && (t.includes(";")||t.includes("{"));
    }
    if(node.nodeType===1){
      var txt=node.textContent||"";
      return txt.length>200 && (txt.includes("function(")||txt.includes("var ")||txt.includes("=>")) && (txt.includes(";")||txt.includes("{"));
    }
    return false;
  }
  function cleanDumps(){
    var body=document.body;
    // scan last 10 nodes
    for(let i=0;i<10;i++){
      var n=body.childNodes[body.childNodes.length-1-i];
      if(!n) break;
      if(isDumpNode(n)){
        if(n.nodeType===1) n.classList.add("__code-dump");
        else {
          // wrap text node so CSS can hide it
          var span=document.createElement("div");
          span.className="__code-dump";
          span.textContent=n.textContent;
          body.replaceChild(span,n);
        }
      }
    }
  }
  cleanDumps();
  // re-check shortly in case late scripts append text
  setTimeout(cleanDumps, 800);
  setTimeout(cleanDumps, 2000);

  // Tabs active state fix: ensure only current tab has .active-btn
  const tabBar=document.querySelector('[data-tabs="main"]');
  if(tabBar){
    tabBar.addEventListener('click', (e)=>{
      const btn=e.target.closest('[data-tab]');
      if(!btn) return;
      const all=tabBar.querySelectorAll('[data-tab]');
      all.forEach(b=>b.classList.remove('active-btn'));
      btn.classList.add('active-btn');
    });
  }

  // Soft guard: keep SWAT block visible only on its tab if such attributes exist
  const swatSec=document.getElementById('swatPanel')||document.querySelector('[data-block="swat"]');
  const dashSec=document.getElementById('dashboardWrap')||document.querySelector('[data-block="dashboard"]');
  const pahSec=document.getElementById('pahWrap')||document.querySelector('[data-block="pah"]');
  function showOnly(sec){
    [swatSec,dashSec,pahSec].forEach(s=>{ if(!s) return; s.style.display = (s===sec)?'block':'none'; });
  }
  // if we can detect selected by aria-selected or .active-btn
  const active=tabBar?tabBar.querySelector('.active-btn'):null;
  if(active){
    const tb=active.dataset.tab;
    if(tb==='swat') showOnly(swatSec);
    else if(tb==='dash') showOnly(dashSec);
    else if(tb==='pah') showOnly(pahSec);
  }

  // Restore "–ü–æ–∫–∞–∑–∞—Ç—å/–°–∫—Ä—ã—Ç—å" toggles if present headings with data-toggle-target
  document.querySelectorAll('[data-toggle-target]').forEach(btn=>{
    const targetSel = btn.getAttribute('data-toggle-target');
    const target = document.querySelector(targetSel);
    if(!target) return;
    btn.addEventListener('click', ()=>{
      const vis = getComputedStyle(target).display!=='none';
      target.style.display = vis ? 'none' : '';
      btn.textContent = vis ? '–ü–æ–∫–∞–∑–∞—Ç—å' : '–°–∫—Ä—ã—Ç—å';
    });
  });

  // Provide STOP for dashboard if a global controller exists
  if(!window.__runAbort){
    window.__runAbort = new AbortController();
  }
  const runBtn = document.getElementById('btnDashRun')||document.querySelector('[data-action="run-dashboard"]');
  const stopBtn = document.getElementById('btnDashStop')||document.querySelector('[data-action="stop-dashboard"]');
  if(runBtn){
    runBtn.addEventListener('click', ()=>{
      window.__runAbort.abort();
      window.__runAbort = new AbortController();
      runBtn.dataset.busy="1";
      setTimeout(()=>{ runBtn.dataset.busy=""; }, 120000);
    });
  }
  if(stopBtn){
    stopBtn.addEventListener('click', ()=>{
      try{ window.__runAbort.abort(); }catch(_){}
      runBtn && (runBtn.dataset.busy="");
    });
  }
})();
</script>

</script>
<!-- === Toggle '–ü–æ–∫–∞–∑–∞—Ç—å/–°–∫—Ä—ã—Ç—å' –¥–ª—è –∫–ª—é—á–µ–≤—ã—Ö —Å–µ–∫—Ü–∏–π UI (–Ω–µ–Ω–∞–≤—è–∑—á–∏–≤–æ) === -->
<script>
(function () {
  // –∫–∞–∫–∏–µ –∑–∞–≥–æ–ª–æ–≤–∫–∏ –ª–æ–≤–∏–º
  const targets = [
    { key: 'summary_barchart',  re: /—Å–≤–æ–¥–Ω—ã–π\s*–±–∞—Ä—á–∞—Ä—Ç/i },
    { key: 'global_log',        re: /^–ª–æ–≥$/i },
    { key: 'launch_alerts',     re: /–∞–ª–ª–µ—Ä—Ç\s*–ø–æ\s*–ª–∞—É–Ω—á–∞–º/i },
    { key: 'saved_snaps',       re: /—Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã–µ\s*—Å—Ä–µ–∑—ã/i },
    // –¥–∞—à–±–æ—Ä–¥-–∫–∞—Ä—Ç–æ—á–∫–∏ –ø–æ –≥—Ä—É–ø–ø–∞–º (—Å–æ–∑–¥–∞—é—Ç—Å—è –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏)
    //{ key: 'ios_smoke',         re: /^\[iOS]\[Smoke]/i },
    //{ key: 'android_smoke',     re: /^\[Android]\[Smoke]/i },
    //{ key: 'android_selective', re: /^\[Android]\[Selective]/i },
    //{ key: 'ios_selective',     re: /^\[iOS]\[Selective]/i },
  ];

  // –∏—â–µ–º ¬´–∫–∞—Ä—Ç–æ—á–Ω—ã–π¬ª –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –ø–æ –∑–∞–≥–æ–ª–æ–≤–∫—É
  function findBoxByHeader(re) {
    const head = Array.from(document.querySelectorAll(
      'h1,h2,h3,h4,.title,.section-title,.card .head>*:first-child'
    )).find(n => re.test((n.textContent || '').trim()));
    if (!head) return null;
    return head.closest('.card, .panel, .box, .section, .block, .widget, .table-wrap') || head.parentElement;
  }

  // —Å—Ç–∞–≤–∏–º –∫–Ω–æ–ø–∫—É –∏ —Å–∞–º —Ç–æ–≥–≥–ª–∏–Ω–≥ (—Å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ–º –∏—Å—Ö–æ–¥–Ω–æ–≥–æ display)
  function injectToggle(box, key) {
    if (!box || box.dataset.collapsibleInit) return;
    box.dataset.collapsibleInit = '1';

    const head =
      box.querySelector('.head') ||
      box.querySelector('h1,h2,h3,h4,.title,.section-title,.card .head>*:first-child') ||
      box;

    // –¥–æ—á–µ—Ä–Ω–∏–µ —á–∞—Å—Ç–∏ –∫–æ–Ω—Ç–µ–Ω—Ç–∞ (–≤—Å—ë –∫—Ä–æ–º–µ —à–∞–ø–∫–∏)
    const parts = Array.from(box.children).filter(n => n !== head);

    // —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –∏—Å—Ö–æ–¥–Ω—ã–π display, —á—Ç–æ–±—ã –ø–æ—Ç–æ–º –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å
    parts.forEach(el => {
      if (!el.dataset.prevDisplay) {
        const inline = el.style && el.style.display ? el.style.display : '';
        const comp = getComputedStyle(el).display || '';
        // –µ—Å–ª–∏ —ç–ª–µ–º–µ–Ω—Ç —É–∂–µ —Å–∫—Ä—ã—Ç (–Ω–∞–ø—Ä–∏–º–µ—Ä, "–ü–æ —Å—Ç—Ä–∏–º—É"), –Ω—É–∂–Ω–æ –∑–∞–ø–æ–º–Ω–∏—Ç—å 'none'
        el.dataset.prevDisplay = inline || comp || '';
      }
    });

    const btn = document.createElement('button');
    btn.className = 'mini';
    btn.style.marginLeft = '8px';

    const lsKey = 'ui_collapsed_' + key;

    function setOpen(open) {
      if (open) {
        // –í–ê–ñ–ù–û: –ø—Ä–∏ "–ü–æ–∫–∞–∑–∞—Ç—å" –Ω–µ –¥–µ–ª–∞–µ–º display:"",
        // –∞ –≤–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –†–ê–ù–ï–ï –°–û–•–†–ê–ù–Å–ù–ù–´–ï –∑–Ω–∞—á–µ–Ω–∏—è ‚Äî —Ç–∞–∫ "–ü–æ —Å—Ç—Ä–∏–º—É" –æ—Å—Ç–∞–Ω–µ—Ç—Å—è —Å–∫—Ä—ã—Ç—ã–º, –µ—Å–ª–∏ –±—ã–ª —Å–∫—Ä—ã—Ç
        parts.forEach(el => {
          el.style.display = el.dataset.prevDisplay || '';
        });
      } else {
        // –ø—Ä–∏ "–°–∫—Ä—ã—Ç—å" ‚Äî –ø—Ä—è—á–µ–º –≤—Å—ë –∏ –Ω–∏—á–µ–≥–æ –Ω–µ –∑–∞—Ç–∏—Ä–∞–µ–º
        parts.forEach(el => {
          if (!el.dataset.prevDisplay) {
            const inline = el.style && el.style.display ? el.style.display : '';
            const comp = getComputedStyle(el).display || '';
            el.dataset.prevDisplay = inline || comp || '';
          }
          el.style.display = 'none';
        });
      }
      btn.textContent = open ? '–°–∫—Ä—ã—Ç—å' : '–ü–æ–∫–∞–∑–∞—Ç—å';
      try { localStorage.setItem(lsKey, open ? '1' : '0'); } catch (_) {}
    }

    btn.addEventListener('click', () => setOpen(btn.textContent !== '–°–∫—Ä—ã—Ç—å'));

    // –≤—Å—Ç–∞–≤–ª—è–µ–º –∫–Ω–æ–ø–∫—É –≤ –ø—Ä–∞–≤—É—é —á–∞—Å—Ç—å ¬´—à–∞–ø–∫–∏¬ª
    (head.lastElementChild && head.classList.contains('head'))
      ? head.lastElementChild.appendChild(btn)
      : head.appendChild(btn);

    const isOpen = (localStorage.getItem(lsKey) ?? '1') === '1';
    setOpen(isOpen);
  }

  // –ø–µ—Ä–≤–∏—á–Ω–æ–µ –≤–Ω–µ–¥—Ä–µ–Ω–∏–µ –Ω–∞ —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏–µ –±–ª–æ–∫–∏
  function initStatic() {
    for (const t of targets.slice(0, 4)) { // –ø–µ—Ä–≤—ã–µ —á–µ—Ç—ã—Ä–µ ‚Äî —Å—Ç–∞—Ç–∏—á–Ω—ã–µ —Å–µ–∫—Ü–∏–∏
      const box = findBoxByHeader(t.re);
      injectToggle(box, t.key);
    }
  }

  // –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–µ –∫–∞—Ä—Ç–æ—á–∫–∏ (iOS/Android ‚Ä¶) ‚Äî –ø–æ—è–≤–ª—è—é—Ç—Å—è –ø—Ä–∏ —Ä–µ–Ω–¥–µ—Ä–µ
  function watchDynamic() {
    const grid = document.getElementById('cards');
    if (!grid) return;

    const applyForGrid = () => {
      // –ø—Ä–æ—Å—Ç–∞–≤–ª—è–µ–º –Ω–∞ –∫–∞—Ä—Ç–æ—á–∫–∏ –≥—Ä—É–ø–ø
      Array.from(grid.querySelectorAll('.card .head>*:first-child')).forEach(h => {
        const title = (h.textContent || '').trim();
        const match = targets.slice(4).find(t => t.re.test(title));
        if (match) injectToggle(h.closest('.card'), match.key);
      });
    };

    // —Å—Ä–∞–∑—É + –ø—Ä–∏ –∫–∞–∂–¥–æ–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –≥—Ä–∏–¥–∞
    applyForGrid();
    const mo = new MutationObserver(applyForGrid);
    mo.observe(grid, { childList: true, subtree: true });
  }

  // –¥–µ–ª–∞–µ–º –ø–æ—Å–ª–µ –æ—Ç—Ä–∏—Å–æ–≤–∫–∏ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
  if (document.readyState !== 'loading') { initStatic(); watchDynamic(); }
  else document.addEventListener('DOMContentLoaded', () => { initStatic(); watchDynamic(); });

})();
</script>
<script>
(function(){
  const input = document.getElementById('baseUrl');
  if (!input) return;

  const key = 'base_url';
  const saved = localStorage.getItem(key);

  if (saved) {
    input.value = saved;
  } else {
    input.value = 'https://allure-testops.wb.ru';
    try { localStorage.setItem(key, input.value); } catch(_) {}
  }

  input.addEventListener('change', ()=>{
    try { localStorage.setItem(key, input.value); } catch(_) {}
  });
})();
</script>
<script>
(function(){
  const input = document.getElementById('projectId');
  if (!input) return;

  const key = 'project_id';
  const saved = localStorage.getItem(key);

  if (saved) {
    input.value = saved;
  } else {
    input.value = '7';
    try { localStorage.setItem(key, input.value); } catch(_) {}
  }

  input.addEventListener('change', ()=>{
    try { localStorage.setItem(key, input.value); } catch(_) {}
  });
})();
</script>

<!-- STOP/ABORT shim injected -->





<script>
/* === Toggle "–ü–æ–∫–∞–∑–∞—Ç—å/–°–∫—Ä—ã—Ç—å –ª–æ–≥" –¥–ª—è –†–ê–ù-–æ—Ç—á—ë—Ç–∞ (–∫–∞–∫ –≤ SWAT) === */
(function () {
  const LS_KEY = 'run_log_open_v1';

  // –ê–∫–∫—É—Ä–∞—Ç–Ω–æ –∏—â–µ–º —ç–ª–µ–º–µ–Ω—Ç—ã –≤ –†–ê–ù-–æ—Ç—á—ë—Ç–µ
  function getRunTab() {
    return document.getElementById('tabRun') || document.querySelector('#tabRun');
  }
  function getRunToolbar() {
    // –ø–∞–Ω–µ–ª—å —Å –∫–Ω–æ–ø–∫–∞–º–∏ "–ü–æ—Å—Ç—Ä–æ–∏—Ç—å / –≠–∫—Å–ø–æ—Ä—Ç ..." –≤ –†–ê–ù-–æ—Ç—á—ë—Ç–µ
    return document.getElementById('runApiToolbar')
        || (getRunTab() && getRunTab().querySelector('.head .right'))
        || (getRunTab() && getRunTab().querySelector('.head'))   // fallback
        || null;
  }
  function getRunLogEl() {
    const tab = getRunTab();
    if (!tab) return null;
    // —á–∞—â–µ –≤—Å–µ–≥–æ –ª–æ–≥ ‚Äî —ç—Ç–æ textarea/pre/div –≤–Ω—É—Ç—Ä–∏ —Ç–∞–±–∞ –†–ê–ù-–æ—Ç—á—ë—Ç–∞
    return tab.querySelector('.log, .logs, .run-log, .log-panel, textarea, pre');
  }

  function setLogVisible(el, btn, open) {
    if (!el || !btn) return;
    el.style.display = open ? '' : 'none';
    btn.textContent  = open ? '–°–∫—Ä—ã—Ç—å –ª–æ–≥' : '–ü–æ–∫–∞–∑–∞—Ç—å –ª–æ–≥';
    try { localStorage.setItem(LS_KEY, open ? '1' : '0'); } catch (e) {}
  }

  function ensureButton() {
    const tab      = getRunTab();
    const toolbar  = getRunToolbar();
    const logEl    = getRunLogEl();
    if (!tab || !toolbar || !logEl) return;

    // —É–∂–µ –¥–æ–±–∞–≤–ª—è–ª–∏?
    if (toolbar.querySelector('#btnRunToggleLog')) return;

    // —Å–æ–∑–¥–∞—ë–º –∫–Ω–æ–ø–∫—É –≤ —Ç–æ–º –∂–µ —Å—Ç–∏–ª–µ, —á—Ç–æ –∏ —É SWAT
    const btn = document.createElement('button');
    btn.id = 'btnRunToggleLog';
    btn.className = 'pill';            // —Ç–æ—Ç –∂–µ –∫–ª–∞—Å—Å, —á—Ç–æ –∏ —É ¬´–ü–æ–∫–∞–∑–∞—Ç—å –ª–æ–≥¬ª –≤ SWAT
    btn.style.marginLeft = '8px';

    // –ø–æ–≤–µ–¥–µ–Ω–∏–µ
    const initialOpen = (localStorage.getItem(LS_KEY) ?? '1') === '1';
    setLogVisible(logEl, btn, initialOpen);

    btn.addEventListener('click', () => {
      const nowOpen = btn.textContent !== '–ü–æ–∫–∞–∑–∞—Ç—å –ª–æ–≥';
      setLogVisible(logEl, btn, !nowOpen);
    });

    // –≤—Å—Ç–∞–≤–ª—è–µ–º –≤ –ø—Ä–∞–≤—É—é —á–∞—Å—Ç—å —Ç—É–ª–±–∞—Ä–∞ (—Ä—è–¥–æ–º —Å ¬´–ü–æ—Å—Ç—Ä–æ–∏—Ç—å/–≠–∫—Å–ø–æ—Ä—Ç¬ª)
    toolbar.appendChild(btn);
  }

  // –ü–µ—Ä–≤–∏—á–Ω–∞—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
  function init() { ensureButton(); }

  if (document.readyState !== 'loading') init();
  else document.addEventListener('DOMContentLoaded', init);

  // –ù–∞ —Å–ª—É—á–∞–π, –µ—Å–ª–∏ –†–ê–ù-–æ—Ç—á—ë—Ç –ø–µ—Ä–µ—Ä–∏—Å–æ–≤—ã–≤–∞–µ—Ç—Å—è –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏ ‚Äî —Å–ª–µ–¥–∏–º –∏ –ø–µ—Ä–µ–≤—Å—Ç–∞–≤–ª—è–µ–º –∫–Ω–æ–ø–∫—É
  const mo = new MutationObserver(() => ensureButton());
  mo.observe(document.documentElement, { childList: true, subtree: true });
})();
</script>
<!-- === PATCH: RUN report Log show/hide toggle + skin (drop-in) === -->


<script id="run-log-toggle-script">
(function(){
  const LS_KEY = 'run_log_open_v1';

  function $(sel, root=document){ return root.querySelector(sel); }
  function el(tag, cls){ const n=document.createElement(tag); if(cls) n.className=cls; return n; }

  function findRunToolbar(){
    // —Ä—è–¥–æ–º —Å ¬´–ü–æ—Å—Ç—Ä–æ–∏—Ç—å / –≠–∫—Å–ø–æ—Ä—Ç‚Ä¶ / –¢–∏–ø –∫–µ–π—Å–æ–≤¬ª
    return document.querySelector('#tabRun .panel.card .head, #tabRun .panel.card .wrap, #tabRun .panel.card .toolbar, #tabRun .run-toolbar') 
           || document.querySelector('#tabRun');
  }
  function findRunLogBox(){
    // –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä —Å –ª–æ–≥–∞–º–∏ –†–ê–ù-–æ—Ç—á—ë—Ç–∞
    const candidates = Array.from(document.querySelectorAll('#tabRun .log, #tabRun .logs, #tabRun .run-log, #tabRun .log-panel, #tabRun pre, #tabRun textarea'));
    // –±–µ—Ä—ë–º —Å–∞–º—ã–π –∫—Ä—É–ø–Ω—ã–π –≤–∏–¥–∏–º—ã–π
    let best=null, area=0;
    for(const n of candidates){
      const r=n.getBoundingClientRect();
      const a=r.width*r.height;
      if(a>area) { area=a; best=n; }
    }
    return best;
  }

  function ensureButton(){
    const toolbar = findRunToolbar();
    const logBox  = findRunLogBox();
    if(!toolbar || !logBox) return; // –µ—â—ë –Ω–µ –æ—Ç—Ä–∏—Å–æ–≤–∞–ª–∏

    // –Ω–µ –¥—É–±–ª–∏—Ä–æ–≤–∞—Ç—å
    if(toolbar.querySelector('[data-run-log-toggle]')) return;

    const btn = el('button','btn-mini'); btn.dataset.runLogToggle='1';
    // –ó–∞–≥—Ä—É–∑–∫–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è
    let open = (localStorage.getItem(LS_KEY) ?? '1') === '1';
    function apply(){
      // if there is an active stream selection, force show-count to max
      const hasSelection = !allCb.checked && cbs.some(cb=>cb.checked);
      ensureMaxShown(toolbar, hasSelection);
      logBox.style.display = open ? '' : 'none';
      btn.textContent = open ? '–°–∫—Ä—ã—Ç—å –ª–æ–≥' : '–ü–æ–∫–∞–∑–∞—Ç—å –ª–æ–≥';
      try{ localStorage.setItem(LS_KEY, open?'1':'0'); }catch(e){}
    }
    btn.addEventListener('click', ()=>{ open=!open; apply(); });

    // –í—Å—Ç–∞–≤–ª—è–µ–º —Å–ø—Ä–∞–≤–∞
    const anchor = toolbar.lastElementChild || toolbar;
    anchor.appendChild(btn);
    apply();
  }

  // –ü–µ—Ä–≤–∏—á–Ω—ã–π –ø—Ä–æ–≥–æ–Ω
  if(document.readyState !== 'loading') ensureButton();
  else document.addEventListener('DOMContentLoaded', ensureButton);

  // –°–ª–µ–¥–∏–º –∑–∞ –ø–µ—Ä–µ—Ä–∏—Å–æ–≤–∫–∞–º–∏ –†–ê–ù-–æ—Ç—á—ë—Ç–∞
  const mo = new MutationObserver(()=> ensureButton());
  mo.observe(document.documentElement, {subtree:true, childList:true});
})();
</script>
<!-- === /PATCH === -->


  <!-- ====================== –í–ê–ù–ì–û–í–ê–¢–û–† (4-—è –≤–∫–ª–∞–¥–∫–∞, iframe-–∏–∑–æ–ª—è—Ü–∏—è) ====================== -->
  
  </div>










<!-- ===== RUN Export glue (added) ===== -->
<script>
window.getRunRows = function () {
  if (Array.isArray(window.__run_rows) && window.__run_rows.length) {
    return window.__run_rows;
  }
  const tbl = document.getElementById('runTable');
  if (!tbl) return [];
  const rows = [];
  // try to read header from THEAD or first TR
  const thead = tbl.querySelector('thead');
  if (thead) {
    const hdr = Array.from(thead.querySelectorAll('th')).map(th => th.textContent.trim());
    if (hdr.length) rows.push(hdr);
  } else {
    const first = tbl.querySelector('tbody tr');
    if (first) {
      const hdrCells = Array.from(first.children);
      if (hdrCells.length && hdrCells[0].tagName === 'TH') {
        rows.push(hdrCells.map(th => th.textContent.trim()));
      }
    }
  }
  // gather body rows
  const bodyRows = tbl.querySelectorAll('tbody tr');
  bodyRows.forEach((tr, idx) => {
    const cells = Array.from(tr.children).filter(td => td.tagName !== 'TH');
    const arr = cells.map(td => td.textContent.trim());
    if (arr.length) rows.push(arr);
  });
  return rows;
};
</script>

<script>
(function hookRunExportXlsx(){
  const btn = document.getElementById('runExportXlsxBtn');
  if (!btn) return;
  btn.addEventListener('click', async () => {
    try {
      const rows = window.getRunRows();
      if (!rows.length) { (typeof toast==='function'?toast:alert)('–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —ç–∫—Å–ø–æ—Ä—Ç–∞'); return; }
      await window.buildRunXlsxExact(rows);
    } catch (e) {
      (typeof toast==='function'?toast:alert)('–û—à–∏–±–∫–∞ —ç–∫—Å–ø–æ—Ä—Ç–∞ Excel: ' + (e && (e.message||e)));
    }
  });
})();
</script>

<script>
window.buildRunXlsxExact = async function (rows) {
  const X = window.XlsxPopulate;
  if (!X) { (typeof toast==='function'?toast:alert)('XlsxPopulate –Ω–µ –ø–æ–¥–∫–ª—é—á—ë–Ω'); return; }

  let aoa = [];
  if (Array.isArray(rows) && rows.length) {
    if (Array.isArray(rows[0])) {
      aoa = rows;
    } else if (typeof rows[0] === 'object') {
      const keys = Object.keys(rows[0]);
      aoa = [keys, ...rows.map(o => keys.map(k => (o && o[k]) ?? ''))];
    }
  }
  if (!aoa.length) { (typeof toast==='function'?toast:alert)('–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —ç–∫—Å–ø–æ—Ä—Ç–∞'); return; }

  const wb = await X.fromBlankAsync();
  const sheet = wb.sheet(0).name('–†–ê–ù');
  sheet.cell('A1').value(aoa);

  
  // ---- normalize numeric/time cells for 4 columns (–ß–ß/–í—Ä–µ–º—è –Ω–∞ –∫–µ–π—Å) ----
  try{
    const headerRow = aoa[0].map(v => String(v || '').trim());
    const findCol = (name) => {
      const i = headerRow.findIndex(h => h.toLowerCase() === name.toLowerCase());
      return i >= 0 ? (i + 1) : -1; // 1-based index for XlsxPopulate
    };
    const idxHHSwat   = findCol('–ß–ß SWAT');
    const idxHHStream = findCol('–ß–ß STREAM');
    const idxTCSwat   = findCol('–í—Ä–µ–º—è/–∫–µ–π—Å SWAT');
    const idxTCStream = findCol('–í—Ä–µ–º—è/–∫–µ–π—Å STREAM');

    const rowsCount = aoa.length;

    const toNumber = (s) => {
      if (typeof s === 'number') return s;
      if (s == null) return null;
      s = String(s).trim().replace(',', '.');
      if (!s) return null;
      const n = Number(s);
      return Number.isFinite(n) ? n : null;
    };
    const parseTimeToExcel = (s) => {
      // accepts "mm:ss", "h:mm", or "h:mm:ss" -> Excel time (fraction of a day)
      if (typeof s === 'number') return s;
      s = String(s||'').trim();
      if (!s) return null;
      const parts = s.split(':').map(x => x.trim());
      if (parts.some(p => p === '' || isNaN(+p))) return null;
      let h = 0, m = 0, sec = 0;
      if (parts.length === 2){
        const [a,b] = parts.map(Number);
        if (b < 60 && a >= 0 && a <= 59){ m = a; sec = b; } // mm:ss
        else { h = a; m = b; } // h:mm
      }else if (parts.length === 3){
        [h,m,sec] = parts.map(Number);
      }else return null;
      return (h*3600 + m*60 + sec) / 86400;
    };

    for (let r = 2; r <= rowsCount; r++) {
      if (idxHHSwat > 0){
        const v = aoa[r-1][idxHHSwat-1];
        const n = toNumber(v);
        if (n != null) sheet.cell(r, idxHHSwat).value(n);
      }
      if (idxHHStream > 0){
        const v = aoa[r-1][idxHHStream-1];
        const n = toNumber(v);
        if (n != null) sheet.cell(r, idxHHStream).value(n);
      }
      if (idxTCSwat > 0){
        const raw = aoa[r-1][idxTCSwat-1];
        const t = parseTimeToExcel(raw);
        if (t != null) sheet.cell(r, idxTCSwat).value(t);
      }
      if (idxTCStream > 0){
        const raw = aoa[r-1][idxTCStream-1];
        const t = parseTimeToExcel(raw);
        if (t != null) sheet.cell(r, idxTCStream).value(t);
      }
    }

    if (idxTCSwat > 0)   sheet.range(2, idxTCSwat, rowsCount, idxTCSwat).style({ numberFormat: "[m]:ss" });
    if (idxTCStream > 0) sheet.range(2, idxTCStream, rowsCount, idxTCStream).style({ numberFormat: "[m]:ss" });
    if (idxHHSwat > 0)   sheet.range(2, idxHHSwat, rowsCount, idxHHSwat).style({ numberFormat: "0.00" });
    if (idxHHStream > 0) sheet.range(2, idxHHStream, rowsCount, idxHHStream).style({ numberFormat: "0.00" });
  }catch(e){ console && console.warn && console.warn('Excel time patch skipped:', e); }
  // ---- /normalize ----
const colCount = aoa[0] ? aoa[0].length : 0;
  if (colCount) {
    const header = sheet.range(1,1,1,colCount);
    header.style({ bold: true, fill: 'EFEAF7', border: true });
    const all = sheet.range(1,1,aoa.length,colCount);
    all.style({ border: true });
    for (let c=1; c<=colCount; c++){
      const width = Math.max(12, *[len if (len:=0) else 0])
    }
  }

  // simple auto-width without Python expression (JS only)
  try {
    const colCount2 = aoa[0] ? aoa[0].length : 0;
    for (let c=1; c<=colCount2; c++) {
      const sample = aoa.slice(0, 500).map(r => String(r[c-1] ?? ''));
      const maxLen = Math.max(12, ...sample.map(s => s.length + 2));
      sheet.column(c).width(maxLen);
    }
  } catch (_) {}

  const verEl = document.getElementById('version');
  const ver = (verEl && verEl.value || '').trim();
  const fileName = '–û—Ç—á—ë—Ç_–†–ê–ù_' + (ver || 'X.Y.Z') + '.xlsx';

  const blob = await wb.outputAsync();
  const url = URL.createObjectURL(new Blob([blob], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' }));
  const a = document.createElement('a');
  a.href = url; a.download = fileName; a.click();
  URL.revokeObjectURL(url);
  (typeof toast==='function'?toast:console.log)('Excel —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω: ' + fileName);
};
</script>
<!-- ===== /RUN Export glue (added) ===== -->


<script>
// ==== Safety stubs & handler reset (added) ====
window.toOrderedArray = window.toOrderedArray || function(row){
  if (Array.isArray(row)) return row;
  if (row && typeof row === 'object') return Object.keys(row).map(k => row[k]);
  return [row];
};

(function fixRunExportHandlers(){
  const btn = document.getElementById('runExportXlsxBtn');
  if (!btn) return;
  // remove any existing listeners by cloning
  const clone = btn.cloneNode(true);
  btn.parentNode.replaceChild(clone, btn);
  clone.addEventListener('click', async () => {
    try {
      const rows = (typeof getRunRows === 'function') ? getRunRows() : [];
      if (!rows.length) { (typeof toast==='function'?toast:alert)('–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —ç–∫—Å–ø–æ—Ä—Ç–∞'); return; }
      await (window.buildRunXlsxExact ? window.buildRunXlsxExact(rows) : Promise.reject('buildRunXlsxExact missing'));
    } catch (e) {
      (typeof toast==='function'?toast:alert)('–û—à–∏–±–∫–∞ —ç–∫—Å–ø–æ—Ä—Ç–∞ Excel: ' + (e && (e.message||e)));
    }
  });
})();
</script>



<!-- ====== /Excel Export injected ====== -->

<!-- RUN-EXPORT v6 START -->

<!-- RUN-EXPORT v6 END -->

<!-- RUN-RERUN-COUNTER START -->
<script>
/* JS-–ø–æ—Ä—Ç count_rerun_by_stream_after_swat –∏–∑ Python.
   –í—Å—Ç—Ä–∞–∏–≤–∞–µ—Ç—Å—è –æ–¥–∏–Ω —Ä–∞–∑, —Å–æ–∑–¥–∞—ë—Ç window.countRerunByStreamAfterSwat(version, swatSet).
   –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –ø—Ä—è–º–æ–π Allure API (—á–µ—Ä–µ–∑ window.ALLURE_*), –ª–∏–±–æ –ø–µ—Ä–µ–ø–∏—à–∏—Ç–µ fetchJson() –ø–æ–¥ –≤–∞—à –ø—Ä–æ–∫—Å–∏. */
(function attachRerunCounter(){
  if (typeof window.countRerunByStreamAfterSwat === 'function') return;
  const KINDS = ['Smoke','Selective'];
  const PAGE_SIZE = 1000;
  const REQ_TIMEOUT_MS = 45000;
  const MAX_WORKERS = 24;

  const BASE_URL   = window.ALLURE_BASE_URL   || '';
  const PROJECT_ID = window.ALLURE_PROJECT_ID ?? '';
  const API_TOKEN  = window.ALLURE_API_TOKEN  || '';

  const b64 = (obj)=> btoa(unescape(encodeURIComponent(JSON.stringify(obj))));

  async function fetchJson(url, params={}){
    // Option A: Server proxy (preferred for prod)
    if (window.ALLURE_PROXY){
      const resp = await fetch(window.ALLURE_PROXY, {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({url, params})});
      if (!resp.ok) throw new Error('proxy '+resp.status);
      return await resp.json();
    }
    // Option B: Direct Allure API for local testing
    if (BASE_URL && API_TOKEN){
      const ctrl = new AbortController(); const to=setTimeout(()=>ctrl.abort(), REQ_TIMEOUT_MS);
      try{
        const resp = await fetch(url, { ...params, signal: ctrl.signal, headers: {'Accept':'application/json','Authorization': `Api-Token ${String(API_TOKEN).replace(/^Api-Token\s*/i,'')}`,...(params.headers||{})} });
        if (!resp.ok) throw new Error('http '+resp.status);
        return await resp.json();
      } finally { clearTimeout(to); }
    }
    // No config: behave as "0"
    return null;
  }

  async function findLaunches(version){
    if (!BASE_URL) return [];
    const result = [];
    for (const kind of KINDS){
      const search = b64([{ id:'name', type:'string', value:`[${kind}] –†–µ–≥—Ä–µ—Å—Å ${version}` }]);
      let page = 0;
      while (true){
        const qs = new URLSearchParams({
          page:String(page), size:String(PAGE_SIZE), search,
          projectId:String(PROJECT_ID||''), preview:'true', sort:'createdDate,desc'
        });
        const data = await fetchJson(`${BASE_URL}/api/launch?${qs}`);
        const content = data?.content || [];
        if (!content.length) break;
        result.push(...content);
        if (content.length < PAGE_SIZE) break;
        page += 1;
      }
    }
    const map = new Map();
    for (const it of result) map.set(Number(it.id), it);
    return Array.from(map.values());
  }

  async function listLeaf(launchId){
    if (!BASE_URL) return [];
    const url = `${BASE_URL}/api/testresulttree/leaf`;
    const ids = [];
    let page = 0;
    while (true){
      const qs = new URLSearchParams({ launchId:String(launchId), sort:'duration,asc', size:String(PAGE_SIZE), page:String(page) });
      const data = await fetchJson(`${url}?${qs}`);
      const content = data?.content || [];
      for (const it of content){
        if (it?.id != null) ids.push(Number(it.id));
      }
      if (content.length < PAGE_SIZE) break;
      page += 1;
    }
    return ids;
  }

  const coreCache = new Map();
  async function coreCached(resultId){
    if (coreCache.has(resultId)) return coreCache.get(resultId);
    const data = await fetchJson(`${BASE_URL}/api/testresult/${resultId}`);
    if (!data) return null;
    const tuple = [Number(data.testCaseId||0), String(data.name||'')];
    coreCache.set(resultId, tuple);
    return tuple;
  }

  async function retries(resultId){
    const url = `${BASE_URL}/api/testresult/${resultId}/retries`;
    const qs = new URLSearchParams({ size:String(PAGE_SIZE), sort:'createdDate,desc' });
    const data = await fetchJson(`${url}?${qs}`);
    return data?.content || [];
  }

  async function isStreamRerunAfterSwat(leafResultId, swatSet){
    const list = await retries(leafResultId);
    if (!list || !list.length) return false;
    for (const item of list){
      const tb  = String(item?.testedBy || '').trim().toLowerCase();
      const lmb = String(item?.lastModifiedBy || '').trim().toLowerCase();
      if (!tb || !lmb || tb === lmb) continue;
      if (swatSet.has(tb)){
        await coreCached(leafResultId).catch(()=>{});
        return true;
      }
    }
    return false;
  }

  async function mapWithPool(items, limit, worker){
    const q = items.slice();
    let inflight = 0, result = 0;
    return await new Promise((resolve)=>{
      const pump = ()=>{
        while (inflight < limit && q.length){
          const id = q.shift();
          inflight++;
          Promise.resolve(worker(id)).then(ok=>{ if (ok) result++; }).finally(()=>{
            inflight--;
            if (q.length) pump(); else if (inflight===0) resolve(result);
          });
        }
        if (!q.length && inflight===0) resolve(result);
      };
      pump();
    });
  }

  window.countRerunByStreamAfterSwat = async function(version, swatSetInput){
    try{
      const swatSet = (swatSetInput instanceof Set) ? swatSetInput : new Set([...(swatSetInput||[])].map(x=>String(x).toLowerCase()));
      if (!BASE_URL) return 0; // –Ω–µ—Ç –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ ‚Äî –±–µ–∑–æ–ø–∞—Å–Ω–æ 0
      const launches = await findLaunches(version);
      if (!launches.length) return 0;

      const allLeaf = [];
      for (const L of launches){
        const lid = Number(L.id);
        const ids = await listLeaf(lid);
        allLeaf.push(...ids);
      }
      if (!allLeaf.length) return 0;

      const rerunCount = await mapWithPool(allLeaf, MAX_WORKERS, (leaf)=>isStreamRerunAfterSwat(leaf, swatSet));
      return rerunCount|0;
    }catch(e){
      return 0;
    }
  };
})();
</script>
<!-- RUN-RERUN-COUNTER END -->




<script>
(function(){
  function injectKindKeyInputs(){
    const versionInput = document.querySelector('input[name="version"], #version, input[placeholder*="–í–µ—Ä—Å–∏"], input[placeholder*="–≤–µ—Ä—Å–∏"]');
    const host = (versionInput && (versionInput.closest('.controls, .toolbar, form, .panel, .row') || versionInput.parentElement)) || document.body;

    const box = document.createElement('div');
    box.id = 'kindKeyBox';
    box.style.cssText = 'display:flex;flex-wrap:wrap;gap:12px;align-items:center;margin-top:6px;font:12px/1.4 system-ui;';
    box.innerHTML = `
      <label style="display:inline-flex;gap:6px;align-items:center;">
        <span>–ö–ª—é—á –¥–ª—è <b>Smoke</b>:</span>
        <input id="smokeKey" type="text" placeholder="Smoke" style="padding:6px 8px;border:1px solid #e5e7eb;border-radius:8px;min-width:140px" />
      </label>
      <label style="display:inline-flex;gap:6px;align-items:center;">
        <span>–ö–ª—é—á –¥–ª—è <b>Selective</b>:</span>
        <input id="selectiveKey" type="text" placeholder="Selective" style="padding:6px 8px;border:1px solid #e5e7eb;border-radius:8px;min-width:140px" />
      </label>
    `;
    host && host.appendChild(box);

    try{
      const s = localStorage.getItem('rb_smoke_key'); if(s) document.querySelector('#smokeKey').value = s;
      const l = localStorage.getItem('rb_selective_key'); if(l) document.querySelector('#selectiveKey').value = l;
    }catch(e){}

    const sk = document.querySelector('#smokeKey');
    const sl = document.querySelector('#selectiveKey');
    sk && sk.addEventListener('input', ()=>{ try{ localStorage.setItem('rb_smoke_key', sk.value.trim()); }catch(e){} });
    sl && sl.addEventListener('input', ()=>{ try{ localStorage.setItem('rb_selective_key', sl.value.trim()); }catch(e){} });
  }
  window.getSmokeKey = ()=> (document.querySelector('#smokeKey')?.value || '').trim() || 'Smoke';
  window.getSelectiveKey = ()=> (document.querySelector('#selectiveKey')?.value || '').trim() || 'Selective';
  document.addEventListener('DOMContentLoaded', injectKindKeyInputs);
})();
</script>



<script>
// === Platform/Type Filters (robust, DOM-level, with summary) ===
(function(){
  function normKey(s){ return String(s||'').replace(/\]\s*\[/g, '][').trim(); }
  function parseLabel(label){
    label = normKey(label);
    var plat = (label.indexOf('[iOS]')===0) ? 'iOS' : (label.indexOf('[Android]')===0 ? 'Android' : null);
    var type = label.includes('[High/Blocker]') ? 'High/Blocker' :
               (label.includes('[Selective]') ? 'Selective' :
               (label.includes('[Smoke]') ? 'Smoke' : null));
    return { platform: plat, type: type };
  }
  function isPlatformEnabled(p){
    if(p==='iOS') return document.getElementById('fltPlatIOS')?.checked === true;
    if(p==='Android') return document.getElementById('fltPlatAndroid')?.checked === true;
    return true; // unknown -> don't hide
  }
  function isTypeEnabled(t){
    if(t==='Smoke') return document.getElementById('fltTypeSmoke')?.checked === true;
    if(t==='Selective') return document.getElementById('fltTypeSelective')?.checked === true;
    if(t==='High/Blocker') return document.getElementById('fltTypeHB')?.checked === true;
    return true;
  }
  function isVisibleLabel(label){
    var p = parseLabel(label);
    return isPlatformEnabled(p.platform) && isTypeEnabled(p.type);
  }

  // For bars: filter labels/datasets by visibility
  if (typeof window.makeBarChart === 'function' && !window.__makeBarChartOrig){
    window.__makeBarChartOrig = window.makeBarChart;
    window.makeBarChart = function(barId, labels, datasets){
      try{
        var idx = labels.map(function(l,i){ return isVisibleLabel(l) ? i : -1; }).filter(function(x){return x!==-1;});
        var labels2 = idx.map(function(i){ return labels[i]; });
        var datasets2 = (datasets||[]).map(function(ds){
          var d = ds.data || [];
          return Object.assign({}, ds, { data: idx.map(function(i){ return d[i]; }) });
        });
        return window.__makeBarChartOrig(barId, labels2, datasets2);
      }catch(e){ console.warn('bar filter error', e); return window.__makeBarChartOrig(barId, labels, datasets); }
    };
  }

  // Donuts: show/hide by visibility
  function applyVisibilityFilter(){
    try{
      var cards = document.querySelectorAll('#cards .card');
      cards.forEach(function(card){
        var title = card.querySelector('.head > div:first-child');
        var label = title ? title.textContent : '';
        card.style.display = isVisibleLabel(label) ? '' : 'none';
      });
    }catch(e){ console.warn('applyVisibilityFilter error', e); }
  }
  window.__applyVisibilityFilter = applyVisibilityFilter;

  // Recompute summary ("–í—Å–µ–≥–æ –≥—Ä—É–ø–ø / –≤—Å–µ–≥–æ –∫–µ–π—Å–æ–≤") based on visible labels
  function updateSummaryFromFilters(){
    try{
      var sumEl = document.getElementById('summaryInfo');
      if(!sumEl || !window.__lastAgg) return;
      var labels = Object.keys(window.__lastAgg || {});
      var visible = labels.filter(isVisibleLabel);
      var totalCases = visible.reduce(function(acc, k){
        var a = window.__lastAgg[k] || {};
        var t = Number(a.total || 0);
        return acc + (isFinite(t) ? t : 0);
      }, 0);
      sumEl.textContent = '–í—Å–µ–≥–æ –≥—Ä—É–ø–ø: ' + visible.length + ', –≤—Å–µ–≥–æ –∫–µ–π—Å–æ–≤: ' + (totalCases.toLocaleString ? totalCases.toLocaleString('ru-RU') : totalCases);
    }catch(e){ console.warn('updateSummaryFromFilters error', e); }
  }
  window.__updateSummaryFromFilters = updateSummaryFromFilters;

  // Hook renderAgg to capture agg and apply filters after draw
  (function hookRender(){
    if (typeof window.renderAgg !== 'function' || window.__renderAggHooked) return;
    window.__renderAggHooked = true;
    var orig = window.renderAgg;
    window.renderAgg = function(a,b,c,d){
      window.__lastAgg = a; // remember
      var r = orig(a,b,c,d);
      try{ applyVisibilityFilter(); updateSummaryFromFilters(); }catch(_e){}
      return r;
    };
  })();

  function bindUI(){
    var ids = ['fltPlatIOS','fltPlatAndroid','fltTypeSmoke','fltTypeSelective','fltTypeHB'];
    ids.forEach(function(id){
      var el = document.getElementById(id);
      if(el && !el.__bind){
        el.__bind = true;
        el.addEventListener('change', function(){
          try{
            if (typeof window.renderAgg === 'function' && window.__lastAgg){
              window.renderAgg(window.__lastAgg, 'cards', 'barAll', document.getElementById('summaryInfo'));
            } else {
              applyVisibilityFilter();
              updateSummaryFromFilters();
              window.dispatchEvent(new Event('resize'));
            }
          }catch(e){ console.warn('repaint failed', e); }
        });
      }
    });
    document.getElementById('fltAll')?.addEventListener('click', function(){
      ['fltPlatIOS','fltPlatAndroid','fltTypeSmoke','fltTypeSelective','fltTypeHB'].forEach(function(id){ var el=document.getElementById(id); if(el) el.checked=true; });
      document.getElementById('fltPlatIOS')?.dispatchEvent(new Event('change'));
    });
    document.getElementById('fltNone')?.addEventListener('click', function(){
      ['fltPlatIOS','fltPlatAndroid','fltTypeSmoke','fltTypeSelective','fltTypeHB'].forEach(function(id){ var el=document.getElementById(id); if(el) el.checked=false; });
      document.getElementById('fltPlatIOS')?.dispatchEvent(new Event('change'));
    });
  }
  document.addEventListener('DOMContentLoaded', bindUI);
})();

</script>

<script>
/** ===== RB AUTH (vanilla) ===== */
(function () {
  const scr   = document.getElementById('rbAuthScreen') || document.querySelector('.rb-auth-screen');
  const form  = document.getElementById('rbAuthForm');
  const login = document.getElementById('rbAuthLogin');
  const pass  = document.getElementById('rbAuthPass');
  const err   = document.getElementById('rbAuthError') || (function(){ 
    const d=document.createElement('div'); d.id='rbAuthError'; d.className='rb-auth-error'; 
    d.style.display='none'; d.textContent='–ù–µ–≤–µ—Ä–Ω—ã–π –ª–æ–≥–∏–Ω –∏–ª–∏ –ø–∞—Ä–æ–ª—å'; 
    form && form.appendChild(d); return d; 
  })();
  const btnLogout = document.getElementById('rbAuthLogout');

  if (!scr || !form || !login || !pass) return;

  const LS_KEY = 'rbAuth.ok';

  // ----- DEV —Ä–µ–∂–∏–º: –ø—É—Å–∫–∞–µ–º –ª—é–±–æ–≥–æ, –µ—Å–ª–∏ –ø–æ–ª—è –Ω–µ –ø—É—Å—Ç—ã–µ -----
  const DEV_ALLOW_ANY = true;

  // –ü—Ä–æ–¥-–ø—Ä–∏–º–µ—Ä (–µ—Å–ª–∏ –Ω—É–∂–Ω–æ –∂—ë—Å—Ç–∫–æ –∑–∞–¥–∞—Ç—å –ø–∞—Ä—É –ª–æ–≥–∏–Ω/–ø–∞—Ä–æ–ª—å):
  const USERS = [
    // { u: 'admin', p: 'admin' },
    // { u: 'qa',    p: 'qa'    },
  ];

  function checkCreds(u, p) {
    if (DEV_ALLOW_ANY) return u.trim() !== '' && p.trim() !== '';
    return USERS.some(x => x.u === u && x.p === p);
  }

  function hideAuth() {
    scr.classList.add('hidden');
    scr.setAttribute('aria-hidden', 'true');
    // –†–∞–∑—Ä–µ—à–∏–º –ø—Ä–æ–∫—Ä—É—Ç–∫—É –æ—Å–Ω–æ–≤–Ω–æ–≥–æ UI, –µ—Å–ª–∏ –æ–Ω–∞ –±—ã–ª–∞ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–∞
    document.documentElement.style.overflow = '';
    document.body.style.overflow = '';
  }

  function showAuth() {
    scr.classList.remove('hidden');
    scr.removeAttribute('aria-hidden');
    err.style.display = 'none';
    pass.value = '';
    // –ï—Å–ª–∏ –Ω—É–∂–Ω–æ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å —Ñ–æ–Ω
    document.documentElement.style.overflow = 'hidden';
    document.body.style.overflow = 'hidden';
  }

  // –ê–≤—Ç–æ–≤—Ö–æ–¥, –µ—Å–ª–∏ —É–∂–µ –µ—Å—Ç—å —Ñ–ª–∞–≥
  try {
    const ok = localStorage.getItem(LS_KEY);
    if (ok === '1') hideAuth(); else showAuth();
  } catch (_) {
    // –µ—Å–ª–∏ localStorage –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω ‚Äî –ø—Ä–æ—Å—Ç–æ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Ñ–æ—Ä–º—É
    showAuth();
  }

  form.addEventListener('submit', function (e) {
    e.preventDefault();
    const u = login.value || '';
    const p = pass.value   || '';

    if (!checkCreds(u, p)) {
      err.style.display = 'block';
      err.textContent = (u.trim()==='' || p.trim()==='')
        ? '–ó–∞–ø–æ–ª–Ω–∏—Ç–µ –ª–æ–≥–∏–Ω –∏ –ø–∞—Ä–æ–ª—å'
        : '–ù–µ–≤–µ—Ä–Ω—ã–π –ª–æ–≥–∏–Ω –∏–ª–∏ –ø–∞—Ä–æ–ª—å';
      return;
    }

    // –£—Å–ø–µ—Ö: —Å–æ—Ö—Ä–∞–Ω—è–µ–º —Ñ–ª–∞–≥ –∏ —Å–∫—Ä—ã–≤–∞–µ–º —ç–∫—Ä–∞–Ω
    try { localStorage.setItem(LS_KEY, '1'); } catch (_) {}
    hideAuth();

    // –ï—Å–ª–∏ —É —Ç–µ–±—è –µ—Å—Ç—å –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –æ—Å–Ω–æ–≤–Ω–æ–≥–æ UI ‚Äî –¥–µ—Ä–Ω–∏ –µ—ë —Ç—É—Ç:
    // initDashboard();  // <- —Ç–≤–æ—è —Ñ—É–Ω–∫—Ü–∏—è
  });

  if (btnLogout) {
    btnLogout.style.display = 'inline-flex';
    btnLogout.addEventListener('click', function () {
      try { localStorage.removeItem(LS_KEY); } catch (_) {}
      showAuth();
    });
  }

  // –ù–∞ Esc –º–æ–∂–Ω–æ —Å–Ω–æ–≤–∞ –ø–æ–∫–∞–∑–∞—Ç—å —Ñ–æ—Ä–º—É (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
  document.addEventListener('keydown', (ev) => {
    if (ev.key === 'Escape' && scr.classList.contains('hidden')) {
      try { localStorage.removeItem(LS_KEY); } catch(_) {}
      showAuth();
    }
  });
})();
</script>


<script>
// ========= Settings persistence + instant filters (patch v3: debounced + calls updateSummaryFromFilters) =========
(function(){
  const LS_KEYS = {
    version: 'rb__version',
    token: 'rb__token',
    baseUrl: 'rb__baseUrl',
    projectId: 'rb__projectId'
  };
  const $ = sel => document.querySelector(sel);

  const versionInput   = $('#version');
  const tokenInput     = $('#token');
  const baseUrlInput   = $('#baseUrl');
  const projectIdInput = $('#projectId');
  const saveBtn        = $('#saveSettingsBtn');
  const toast          = $('#toast');

  function showToast(msg){
    if(!toast) return;
    toast.textContent = msg;
    toast.classList.add('show');
    setTimeout(()=> toast.classList.remove('show'), 1500);
  }
  function setIfEmpty(el, val){
    if(el && (el.value === '' || el.value == null)) el.value = val;
  }

  // Load saved values
  try {
    const v   = localStorage.getItem(LS_KEYS.version);
    const t   = localStorage.getItem(LS_KEYS.token);
    const bu  = localStorage.getItem(LS_KEYS.baseUrl);
    const pid = localStorage.getItem(LS_KEYS.projectId);
    if(v)   setIfEmpty(versionInput, v);
    if(t)   setIfEmpty(tokenInput, t);
    if(bu)  setIfEmpty(baseUrlInput, bu);
    if(pid) setIfEmpty(projectIdInput, pid);
  } catch(e){}

  function saveSettings(){
    try{
      if(versionInput)   localStorage.setItem(LS_KEYS.version,   (versionInput.value||'').trim());
      if(tokenInput)     localStorage.setItem(LS_KEYS.token,     (tokenInput.value||'').trim());
      if(baseUrlInput)   localStorage.setItem(LS_KEYS.baseUrl,   (baseUrlInput.value||'').trim());
      if(projectIdInput) localStorage.setItem(LS_KEYS.projectId, (projectIdInput.value||'').trim());
      showToast('–ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã');
    }catch(e){
      console.error(e);
      showToast('–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å');
    }
  }
  if(saveBtn) saveBtn.addEventListener('click', saveSettings);
  [versionInput, tokenInput].forEach(el => { if(el) el.addEventListener('blur', saveSettings); });

  // ========== Instant filters ==========
  const fltSmoke    = $('#fltTypeSmoke');
  const fltSel      = $('#fltTypeSelective');
  const fltHB       = $('#fltTypeHB');
  const fltIOS      = $('#fltPlatIOS');
  const fltAndroid  = $('#fltPlatAndroid');
  const btnAll      = $('#fltAll');
  const btnNone     = $('#fltNone');

  let rafId = 0;
  function scheduleApply(){
    if(rafId) cancelAnimationFrame(rafId);
    rafId = requestAnimationFrame(()=>{
      if (typeof window.updateSummaryFromFilters === 'function') {
        try { window.updateSummaryFromFilters(); } catch(e){ console.debug(e); }
      }
      const fns = [
        'buildSummaryBar','rebuildSummaryBar','renderSummaryBar','updateSummaryBar',
        'buildMiniDonuts','renderMiniDonuts','updateMiniDonuts',
        'sw_renderSummary','renderAgg','renderDashPrevCurrent','renderDashPrevCurrentStream',
        'applyRunFiltersAndRender','renderStreamSnapList','renderSnapList'
      ];
      fns.forEach(name => { if (typeof window[name] === 'function') { try{ window[name](); }catch(e){ console.debug(name, e); } } });
    });
  }

  [fltSmoke, fltSel, fltHB, fltIOS, fltAndroid].forEach(el => {
    if(!el) return;
    el.addEventListener('change', scheduleApply);
    el.addEventListener('input',  scheduleApply);
    el.addEventListener('click',  scheduleApply);
  });

  if(btnAll){
    btnAll.addEventListener('click', () => {
      [fltSmoke, fltSel, fltHB, fltIOS, fltAndroid].forEach(el => { if(el) el.checked = true; });
      scheduleApply();
    });
  }
  if(btnNone){
    btnNone.addEventListener('click', () => {
      [fltSmoke, fltSel, fltHB, fltIOS, fltAndroid].forEach(el => { if(el) el.checked = false; });
      scheduleApply();
    });
  }

  scheduleApply();
})();
</script>


<script>
/* –ö–Ω–æ–ø–∫–∞ "–°—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞—Ç—å XLSX": –∑–∞–ø—É—Å–∫–∞–µ—Ç v8.py –≤ Pyodide –∏ —Å–∫–∞—á–∏–≤–∞–µ—Ç –≥–æ—Ç–æ–≤—ã–π —Ñ–∞–π–ª */
(function(){
  let _py = null, _busy = 0;
  const $ = s => document.querySelector(s);
  const v = id => (document.getElementById(id)?.value || '').trim();
  function spinner(on){
    let el = document.getElementById('pyBusy');
    if(!el){
      el = document.createElement('div'); el.id='pyBusy';
      el.style.cssText='position:fixed;inset:0;background:rgba(0,0,0,.28);display:none;z-index:99999';
      el.innerHTML = '<div style="position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);background:#111;color:#fff;padding:14px 18px;border-radius:12px">–ì–æ—Ç–æ–≤–ª—é XLSX‚Ä¶</div>';
      document.body.appendChild(el);
    }
    _busy += on?1:-1; el.style.display = _busy>0 ? 'block' : 'none';
  }
  async function ensurePy(){
    if (typeof loadPyodide === 'undefined') {
      await new Promise(r => {
        const s = document.createElement('script');
        s.src = 'https://cdn.jsdelivr.net/pyodide/v0.25.0/full/pyodide.js';
        s.onload = r; document.head.appendChild(s);
      });
    }
    if (_py) return _py;
    const py = await loadPyodide({ indexURL: "https://cdn.jsdelivr.net/pyodide/v0.25.0/full/" });
    await py.loadPackage(['micropip']);
    const mp = py.pyimport('micropip');
    try { await mp.install('pyodide-http'); } catch(e){}
    py.runPython(`import pyodide_http; pyodide_http.patch_all()`);
    await mp.install('openpyxl==3.1.2');
    _py = py; return py;
  }
  async function buildAndDownloadXlsx(){
    const baseUrl=v('baseUrl'), token=v('token'), ver=v('version');
    if(!baseUrl||!token||!ver){ alert('–ó–∞–ø–æ–ª–Ω–∏ Base URL, Token –∏ –í–µ—Ä—Å–∏—é'); return; }
    spinner(true);
    try{
      const py = await ensurePy();
      const PRELUDE = `
import os
try: __file__
except NameError: __file__ = 'main.py'
os.environ.setdefault('HOME','/home/pyodide')
def _py_sanitize_xlsx_path(p):
    try:
        s=str(p).split('/')[-1].split('\\\\')[-1]
        return s if s.lower().endswith('.xlsx') else 'report.xlsx'
    except Exception:
        return 'report.xlsx'
try:
    import openpyxl
    _orig= openpyxl.workbook.workbook.Workbook.save
    def _save(self, filename): return _orig(self, _py_sanitize_xlsx_path(filename))
    openpyxl.workbook.workbook.Workbook.save = _save
except Exception: pass
`;
      await py.runPythonAsync(PRELUDE);
      py.globals.set('PY_BASE_URL', baseUrl);
      py.globals.set('PY_API_TOKEN', token);
      py.globals.set('PY_VERSION', ver);
      await py.runPythonAsync(`
import builtins, os
os.environ['BASE_URL'] = PY_BASE_URL
os.environ['API_TOKEN'] = PY_API_TOKEN
def _fake_input(prompt=''):
    print(prompt, end='')
    return PY_VERSION
builtins.input = _fake_input
`);
      await py.runPythonAsync(`
import pyodide_http
pyodide_http.patch_all()
try:
    import requests
except ModuleNotFoundError:
    import types, urllib.request, urllib.error, urllib.parse, json
    mod = types.ModuleType("requests")
    class _Resp:
        def __init__(self, code, data, headers):
            self.status_code = code; self.headers = headers; self.ok = 200 <= code < 300
            try: self.text = data.decode('utf-8', errors='replace')
            except Exception: self.text = ''
        def json(self): return json.loads(self.text)
        @property
        def content(self): return self.text.encode('utf-8', errors='ignore')
    def _do(method, url, **kw):
        data = kw.get('data') or kw.get('json')
        if kw.get('json') is not None:
            data = json.dumps(kw['json']).encode('utf-8')
            headers = kw.get('headers', {}); headers.setdefault('Content-Type','application/json'); kw['headers'] = headers
        if isinstance(data, str): data = data.encode('utf-8')
        req = urllib.request.Request(url=url, method=method.upper(), data=data, headers=kw.get('headers') or {})
        try:
            with urllib.request.urlopen(req) as r: return _Resp(r.getcode(), r.read(), dict(r.headers))
        except urllib.error.HTTPError as e:
            return _Resp(e.code, e.read() or b'', dict((e.headers or {})))
    def get(url, **kw):    return _do('GET', url, **kw)
    def post(url, **kw):   return _do('POST', url, **kw)
    def put(url, **kw):    return _do('PUT', url, **kw)
    def delete(url, **kw): return _do('DELETE', url, **kw)
    class _Sess:
        def request(self, method, url, **kw): return _do(method, url, **kw)
        def get(self, url, **kw):    return get(url, **kw)
        def post(self, url, **kw):   return post(url, **kw)
        def put(self, url, **kw):    return put(url, **kw)
        def delete(self, url, **kw): return delete(url, **kw)
    class sessions: Session = _Sess
    mod.get, mod.post, mod.put, mod.delete, mod.sessions = get, post, put, delete, sessions
    mod.Session = sessions.Session

    import sys; sys.modules['requests'] = mod
    # --- adapters shim ---
    import types as _types_for_adapters, sys as _sys_for_adapters
    adapters = _types_for_adapters.ModuleType("requests.adapters")
    class HTTPAdapter:
        def __init__(self, *a, **kw): pass
        def send(self, *a, **kw): return None
        def close(self): pass
    adapters.HTTPAdapter = HTTPAdapter
    _sys_for_adapters.modules["requests.adapters"] = adapters
    mod.adapters = adapters

`);
const sw = document.getElementById('runSwat')?.files?.[0];
      if (sw) _py.FS.writeFile('SWAT.txt', await sw.text()); else _py.FS.writeFile('SWAT.txt','');
      if (!window.__PY_SCRIPT__){ alert('–ù–µ –Ω–∞–π–¥–µ–Ω –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã–π –°–∫—Ä–∏–ø—Ç –ì–ª–∞–≤–Ω–∞—è v8.py'); spinner(false); return; }
      try { await py.runPythonAsync(window.__PY_SCRIPT__); }
      catch(e){ console.error(e); alert('–û—à–∏–±–∫–∞ –≤ v8.py: '+e); spinner(false); return; }
      let last = null;
      for (const name of _py.FS.readdir('.')) if (name.endsWith('.xlsx')) last = name;
      if (!last){ alert('–°–∫—Ä–∏–ø—Ç –Ω–µ —Å–æ–∑–¥–∞–ª XLSX'); spinner(false); return; }
      const data = _py.FS.readFile(last);
      const blob = new Blob([data], {type:'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = last;
      document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
    } finally { spinner(false); }
  }
  function injectButton(){
    if (document.getElementById('makeXlsxBtn')) return;
    const exportBtn = document.getElementById('runExportXlsxBtn') || document.querySelector('#tabRun .btn.primary');
    const btn = document.createElement('button');
    btn.id='makeXlsxBtn'; btn.type='button'; btn.className='btn';
    btn.textContent='–°—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞—Ç—å XLSX (Py)';
    btn.style.marginLeft='8px';
    if (exportBtn && exportBtn.parentElement){
      exportBtn.parentElement.insertBefore(btn, exportBtn.nextSibling);
    } else {
      (document.getElementById('controls')||document.body).appendChild(btn);
    }
    btn.addEventListener('click', (e)=>{ e.preventDefault(); buildAndDownloadXlsx(); });
  }
  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', injectButton, {once:true});
  else injectButton();
})();
</script>






































<script id="rr-stream-select">
(function(){
  if (window.__rrStreamSelectInstalledDDv10) return;
  window.__rrStreamSelectInstalledDDv10 = true;

  function $ (sel,root=document){return root.querySelector(sel)}
  function $$ (sel,root=document){return Array.from(root.querySelectorAll(sel))}

  // ---------- Robust stream harvesting ----------
  function extractFromText(s){
    if (!s || typeof s!=='string') return [];
    const res = [];
    const re1 = /\[\s*Stream\s+([^\]|]+?)\]/gi;
    const re2 = /(?:^|\s)Stream\s+([A-Za-z–ê-–Ø–∞-—è0-9 _()\-\/]+?)(?=\s|,|$)/gi;
    let m;
    while ((m = re1.exec(s))) res.push(m[1].trim());
    while ((m = re2.exec(s))) res.push(m[1].trim());
    return res;
  }

  function harvestStreamsFromWindow(){
    const set = new Set();
    try{
      for (const k of Object.getOwnPropertyNames(window)){
        const v = window[k];
        if (Array.isArray(v)){
          for (const it of v){
            if (it && typeof it === 'object'){
              for (const val of Object.values(it)){
                if (typeof val === 'string'){
                  extractFromText(val).forEach(s => set.add(s));
                }
              }
            } else if (typeof it === 'string'){
              extractFromText(it).forEach(s => set.add(s));
            }
          }
        } else if (v && typeof v === 'object'){
          const vals = Object.values(v);
          for (const val of vals){
            if (typeof val === 'string'){
              extractFromText(val).forEach(s => set.add(s));
            }
          }
        }
      }
    }catch(e){/* sandbox objects may throw */}
    return Array.from(set);
  }

  function harvestStreamsFromJsonScripts(){
    const set = new Set();
    $$('script[type="application/json"], script[type="application/ld+json"]')
      .forEach(scr=>{
        try{
          const txt = scr.textContent || '';
          extractFromText(txt).forEach(s => set.add(s));
          const data = JSON.parse(txt);
          const walk = (x)=>{
            if (!x) return;
            if (typeof x === 'string'){ extractFromText(x).forEach(s=>set.add(s)); return; }
            if (Array.isArray(x)) x.forEach(walk);
            else if (typeof x === 'object') Object.values(x).forEach(walk);
          };
          walk(data);
        }catch(_){/* ignore */}
      });
    return Array.from(set);
  }

  function harvestStreamsFromDOM(){
    const set = new Set();
    const allText = document.body ? document.body.textContent || '' : '';
    extractFromText(allText).forEach(s=> set.add(s));
    return Array.from(set);
  }

  function getAllStreams(){
  // –ò—Å—Ç–æ—á–Ω–∏–∫ –∏—Å—Ç–∏–Ω—ã ‚Äî —Ç–µ–∫—É—â–∏–µ –º–∏–Ω–∏-–∫–∞—Ä—Ç–æ—á–∫–∏ –≤ miniGrid
  try{
    const {grid} = findMiniSection();
    const set = new Set();
    if (grid){
      const cards = collectCards(grid);
      cards.forEach(c=>{
        const s = (c.dataset && c.dataset.stream) ? c.dataset.stream : detectStreamFromCard(c);
        if (s) set.add(String(s).trim());
      });
    }
    if (set.size) return Array.from(set).sort((a,b)=> a.localeCompare(b,'ru'));
  }catch(_){}
  // –§–æ–ª–±—ç–∫ (–µ—Å–ª–∏ –µ—â—ë –Ω–µ –æ—Ç—Ä–∏—Å–æ–≤–∞–Ω–æ)
  const merged = new Set();
  try{ harvestStreamsFromWindow().forEach(s=> merged.add(s)); }catch(_){}
  try{ harvestStreamsFromJsonScripts().forEach(s=> merged.add(s)); }catch(_){}
  try{ harvestStreamsFromDOM().forEach(s=> merged.add(s)); }catch(_){}
  if (!merged.size) merged.add('–ü—Ä–æ—á–µ–µ');
  return Array.from(merged).sort((a,b)=> a.localeCompare(b,'ru'));
}
}

  // ---------- Show-count control helpers ----------
  function findShowControl(toolbar){
    // try to find the select responsible for "–ü–æ–∫–∞–∑–∞—Ç—å"
    // look for nearest select that has only numbers as options
    let selects = Array.from(toolbar.querySelectorAll('select'));
    // also scan whole mini section head
    const head = toolbar.closest('.head') || toolbar.parentElement;
    if (head) selects = selects.concat(Array.from(head.querySelectorAll('select')));
    let numericSelects = selects.filter(s=> {
      const opts = Array.from(s.options||[]).map(o=>o.textContent.trim());
      return opts.length>0 && opts.every(t=> /^\d+$/.test(t));
    });
    if (numericSelects.length) return numericSelects[0];
    return null;
  }

  function tryOpenShowDropdown(toolbar){
    // Heuristic: find label "–ü–æ–∫–∞–∑–∞—Ç—å" and click next control
    const labelNodes = Array.from(toolbar.querySelectorAll('*')).filter(n=>/–ü–æ–∫–∞–∑–∞—Ç—å/i.test(n.textContent||''));
    let control = null;
    for (const n of labelNodes){
      // look for next sibling or parent siblings that are controls
      const sibs = [n.nextElementSibling, n.parentElement && n.parentElement.nextElementSibling].filter(Boolean);
      for (const s of sibs){
        if (!s) continue;
        if (s.tagName === 'SELECT' || s.matches('input[type="number"], [role="listbox"], [data-state="closed"], .select, .dropdown')) {
          control = s; break;
        }
        const btn = s.querySelector('button, [role="button"]');
        if (btn){ control = btn; break; }
      }
      if (control) break;
    }
    if (!control){
      // last resort: any button near that looks like numeric selector
      control = Array.from(toolbar.querySelectorAll('button, [role="button"]')).find(b=>{
        const t = (b.textContent||'').trim();
        return /^\d+$/.test(t) || /–ü–æ–∫–∞–∑–∞—Ç—å/i.test(t);
      });
    }
    if (control){
      control.click();
      // try to pick biggest number from any open menu
      setTimeout(()=>{
        const menus = Array.from(document.querySelectorAll('[role="listbox"], [role="menu"], .dropdown-menu, .select__menu, .menu'));
        let best = null, bestN = -1;
        menus.forEach(m=>{
          const opts = Array.from(m.querySelectorAll('[role="option"], li, button, div')).filter(x=>{
            const t=(x.textContent||'').trim();
            return /^\d+$/.test(t);
          });
          opts.forEach(x=>{
            const n = parseInt(x.textContent.trim(),10);
            if (n>bestN){ bestN=n; best=x; }
          });
        });
        if (best){ best.click(); }
      }, 60);
      return true;
    }
    return false;
  }

  function ensureMaxShown(toolbar, active){
    const sel = findShowControl(toolbar);
    if (!sel) { tryOpenShowDropdown(toolbar); return false; }
    if (active){
      // set to the largest option
      const nums = Array.from(sel.options).map(o=>parseInt(o.textContent,10)).filter(n=>!isNaN(n));
      if (!nums.length) return false;
      const max = Math.max.apply(null, nums);
      const current = parseInt(sel.value || sel.selectedOptions?.[0]?.textContent || '0', 10);
      if (current !== max){
        // try set by value or by index
        const opt = Array.from(sel.options).find(o=>parseInt(o.textContent,10)===max);
        if (opt){ sel.value = opt.value; opt.selected = true; }
        sel.dispatchEvent(new Event('change', {bubbles:true}));
        sel.dispatchEvent(new Event('input', {bubbles:true}));
        // click any "–ü–æ–∫–∞–∑–∞—Ç—å" button if exists
        const btn = (toolbar.querySelector('button')||{});
        const btns = Array.from(toolbar.querySelectorAll('button')).filter(b=>/–ü–æ–∫–∞–∑–∞—Ç—å/i.test(b.textContent));
        if (btns.length) btns[0].click();
        return true;
      }
    }
    return false;
  }

  // ------------- Mini section locating & cards -------------
  function findMiniSection(){
    const root = document.getElementById('miniLaunchCard') || document;
    const toolbar = root.querySelector('.head .export') || root.querySelector('.mini-toolbar') || root.querySelector('.head');
    const grid = root.querySelector('#miniGrid') ||
                 root.querySelector('[data-mini-grid]') ||
                 root.querySelector('.mini-grid') ||
                 root.querySelector('.cards') ||
                 root.querySelector('.grid');
    return {root, toolbar, grid};
  }

  function collectCards(grid){
    if (!grid) return [];
    let cards = $$('[data-mini-card], .mini-card, .miniCard, .card', grid);
    cards = cards.filter(el => {
      const t = (el.textContent||'').trim();
      return el.querySelector('svg') || /%|–ü—Ä–æ–π–¥–µ–Ω–æ/i.test(t);
    });
    cards.forEach(el=> el.classList.add('miniCard'));
    return cards;
  }

  function detectStreamFromCard(el){
    const titleNode = el.querySelector('[data-title], .title, h4, h5, .card-title') || el;
    const txt = (titleNode.textContent || el.textContent || '').replace(/\s+/g,' ');
    const m = txt.match(/\[\s*Stream\s+([^\]|]+?)]/i) || txt.match(/Stream\s+([A-Za-z–ê-–Ø–∞-—è0-9 _()\-\/]+?)(?:\s|,|$)/i);
    return m ? m[1].trim() : '–ü—Ä–æ—á–µ–µ';
  }

  // ------------- Dropdown mount -------------
  function mount(){
    const {toolbar, grid} = findMiniSection();
    if (!toolbar || !grid) return false;
    if ($('#rrStreamDD', toolbar)) return true;

    const cards = collectCards(grid);
    // assign data-stream for current cards (if —É–∂–µ –µ—Å—Ç—å)
    cards.forEach(c=> c.dataset.stream = c.dataset.stream || detectStreamFromCard(c));

    // –ë–µ—Ä—ë–º —Å—Ç—Ä–∏–º—ã –∏–∑ —Ç–µ–∫—É—â–∏—Ö –º–∏–Ω–∏-–∫–∞—Ä—Ç–æ—á–µ–∫ (–º–æ–≥—É—Ç –ø–æ—è–≤–∏—Ç—å—Å—è –ø–æ–∑–∂–µ)
    const allStreams = getAllStreams();

    const dd = document.createElement('div');
    dd.className = 'rr-stream-dd';
    dd.id = 'rrStreamDD';
    dd.innerHTML = `
      <button type="button" class="rr-dd-trigger" aria-haspopup="listbox" aria-expanded="false">
        <span>–°—Ç—Ä–∏–º—ã</span>
        <span class="rr-badge" id="rrDDCount">–í—Å–µ</span>
        <svg width="16" height="16" viewBox="0 0 20 20" fill="none"><path d="M5 7l5 6 5-6" stroke="#6b15d6" stroke-width="1.6" stroke-linecap="round"/></svg>
      </button>
      <div class="rr-dd-menu" role="listbox" aria-label="–°—Ç—Ä–∏–º—ã">
        <div class="rr-dd-item"><input type="checkbox" value="__ALL__" id="rrAll"><label for="rrAll">–í—Å–µ</label></div>
        ${allStreams.map((s,i)=>`
          <div class="rr-dd-item">
            <input type="checkbox" value="${s}" id="rrS${i}">
            <label for="${s.replace(/"/g,'&quot;')}" for="rrS${i}">${s}</label>
          </div>`).join('')}
      </div>`;
    (function(){
      const plat = toolbar.querySelector('#miniPlatform');
      if (plat && plat.parentElement) {
        plat.parentElement.insertAdjacentElement('afterend', dd);
      } else {
        toolbar.appendChild(dd);
      }
    })();

    const btn   = $('.rr-dd-trigger', dd);
    const menu  = $('.rr-dd-menu', dd);
    const count = $('#rrDDCount', dd);
    const allCb = $('#rrAll', dd);
    const cbs   = $$('input[type="checkbox"]', menu).filter(x=>x!==allCb);

    const KEY = 'mini_streams_filter_v2';

    // build options list (idempotent)
    function refreshOptions(){
      const streams = getAllStreams();
      const saved = (localStorage.getItem(KEY)||'').split('|').filter(Boolean);
      const listHtml = streams.map((s,i)=>`
        <div class="rr-dd-item">
          <input type="checkbox" value="${s}" id="rrS${i}" ${saved.length ? (saved.includes(s)?'checked':'') : 'checked'}>
          <label for="rrS${i}">${s}</label>
        </div>`).join('');
      // keep "–í—Å–µ" on top; rebuild rest
      const items = menu.querySelectorAll('.rr-dd-item');
      items.forEach((it,idx)=>{ if (idx>0) it.remove(); });
      menu.insertAdjacentHTML('beforeend', listHtml);
    }

    refreshOptions(); // –ø–µ—Ä–≤–∏—á–Ω–∞—è –æ—Ç—Ä–∏—Å–æ–≤–∫–∞
    const cbsDyn = ()=> $$('input[type="checkbox"]', menu).filter(x=>x!==allCb);

    const KEY = 'mini_streams_filter';
    const saved = (localStorage.getItem(KEY)||'').split('|').filter(Boolean);
    if (saved.length){
      // –æ—Ç–º–µ—Ç–∏–º –ø–æ–∑–∂–µ –≤ refreshOptions(); –∑–¥–µ—Å—å —Ç–æ–ª—å–∫–æ —Ñ–ª–∞–≥ '–í—Å–µ'
      allCb.checked = false;
    } else {
      allCb.checked = true;
    }

    function apply(){
      const cbs = cbsDyn();
      // –µ—Å–ª–∏ –≤—ã–±—Ä–∞–Ω —Ö–æ—Ç—è –±—ã –æ–¥–∏–Ω —Å—Ç—Ä–∏–º, —Å—Ç–∞–≤–∏–º –ü–æ–∫–∞–∑–∞—Ç—å=–º–∞–∫—Å–∏–º—É–º
      const hasSelection = !allCb.checked && cbs.some(cb=>cb.checked);
      ensureMaxShown(toolbar, hasSelection);
      const selected = cbs.filter(cb=>cb.checked).map(cb=>cb.value);
      const all = allCb.checked || selected.length===0;
      // ensure every current card has dataset.stream
      collectCards(grid).forEach(c=>{
        c.dataset.stream = c.dataset.stream || detectStreamFromCard(c);
        c.classList.toggle('hide', !all && !selected.includes(c.dataset.stream));
      });
      count.textContent = all ? '–í—Å–µ' : String(selected.length);
      localStorage.setItem(KEY, all ? '' : selected.join('|'));
    }

    btn.addEventListener('click', ()=>{
      const open = menu.classList.toggle('open');
      btn.setAttribute('aria-expanded', open ? 'true' : 'false');
    });

    menu.addEventListener('click', (e)=>{
      const t = e.target;
      if (t.tagName === 'INPUT'){
        const cbs = cbsDyn();
        if (t === allCb){
          if (allCb.checked){ cbs.forEach(cb=> cb.checked = false); }
        } else {
          if (t.checked){ allCb.checked = false; }
          else if (!cbs.some(cb=>cb.checked)){ allCb.checked = true; }
        }
        apply(); // –º–µ–Ω—é –Ω–µ –∑–∞–∫—Ä—ã–≤–∞–µ–º
      }
    });

    document.addEventListener('click', (e)=>{
      if (!dd.contains(e.target)) { menu.classList.remove('open'); btn.setAttribute('aria-expanded','false'); }
    });

    apply();

    // react to grid changes
    const mo = new MutationObserver(()=>{ refreshOptions(); apply(); });
    mo.observe(grid, {childList:true, subtree:true});
    return true;
  }

  function init(){
    mount();
  }

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', init);
  } else { init(); }

  const sec = document.getElementById('miniLaunchCard');
  if (sec){
    const mo2 = new MutationObserver(()=> mount());
    mo2.observe(sec, {childList:true, subtree:true});
  }
})();
</script>








<!-- START: Safe standalone "–°—Ç—Ä–∏–º—ã" multiselect (injected by assistant) -->


<script>
(function(){
  // Safe wrapper: errors inside will not break the page
  try{
    const LOCAL_KEY = 'mini_streams_selection_v1';
    const DROPDOWN_ID = 'rrStreamDD_safe_v1';
    const RETRY_INTERVAL_MS = 800;
    const MAX_RETRIES = 40;

    function safe$(sel, root=document){ try{ return root.querySelector(sel); }catch(_){ return null; } }
    function safe$all(sel, root=document){ try{ return Array.from(root.querySelectorAll(sel)); }catch(_){ return []; } }

    function findContext(){
      const root = document.getElementById('miniLaunchCard') || document;
      const toolbar = (root.querySelector('.head .export') || root.querySelector('.head') || root.querySelector('.mini-toolbar')) || null;
      const grid = (root.querySelector('#miniGrid') || root.querySelector('.mini-grid') || root.querySelector('[data-mini-grid]') || root.querySelector('.cards') || root.querySelector('.grid')) || null;
      return {root, toolbar, grid};
    }

    function collectCards(grid){
      if(!grid) return [];
      const candidates = safe$all('[data-mini-card], .mini-card, .miniCard, .card', grid);
      return candidates.filter(el=>{
        try{
          if(el.querySelector('svg, canvas')) return true;
          const txt = (el.textContent||'').trim();
          if(/%|–ü—Ä–æ–π–¥–µ–Ω–æ|–ü—Ä–æ–π—à–ª–æ|–ü—Ä–æ—à–ª–æ/i.test(txt)) return true;
          return false;
        }catch(_){ return false; }
      });
    }

    function detectStreamFromCard(el){
      try{
        if(!el) return '–ü—Ä–æ—á–µ–µ';
        if(el.dataset && el.dataset.stream) return el.dataset.stream.trim();
        const titleNode = el.querySelector('[data-title], .title, h4, h5, .card-title') || el.querySelector('div') || el;
        const txt = (titleNode.textContent || el.textContent || '').replace(/\s+/g,' ').trim();
        const m = txt.match(/\[\s*Stream\s+([^\]|]+?)]/i) || txt.match(/Stream\s+([A-Za-z–ê-–Ø–∞-—è0-9 _()\-\/]+?)(?:\s|,|$)/i);
        if(m && m[1]) return m[1].trim();
        return txt.split('\n')[0].slice(0,60).trim() || '–ü—Ä–æ—á–µ–µ';
      }catch(_){ return '–ü—Ä–æ—á–µ–µ'; }
    }

    function mountDropdown(toolbar, grid){
      if(!toolbar) return null;
      if(safe$('#'+DROPDOWN_ID, toolbar)) return safe$('#'+DROPDOWN_ID, toolbar);

      const dd = document.createElement('div');
      dd.id = DROPDOWN_ID;
      dd.className = 'rr-stream-dd';
      dd.innerHTML = ''
        + '<button class="rr-dd-trigger" aria-expanded="false">'
        + '  <span>–°—Ç—Ä–∏–º—ã</span>'
        + '  <span class="rr-badge" id="rrCount_safe">0</span>'
        + '</button>'
        + '<div class="rr-dd-menu" role="menu" aria-label="–°—Ç—Ä–∏–º—ã">'
        + '  <div class="rr-dd-actions"><button class="rr-small-btn" data-act="all">–í—Å–µ</button><button class="rr-small-btn" data-act="none">–°–±—Ä–æ—Å</button></div>'
        + '  <div class="rr-dd-list"></div>'
        + '</div>';

      try{
        const plat = toolbar.querySelector('#miniPlatform');
        if(plat && plat.parentElement) plat.parentElement.insertAdjacentElement('afterend', dd);
        else toolbar.appendChild(dd);
      }catch(_){
        toolbar.appendChild(dd);
      }

      attachHandlers(dd, grid);
      refreshOptions(dd, grid);
      return dd;
    }

    function refreshOptions(dd, grid){
      if(!dd) return;
      try{
        const list = dd.querySelector('.rr-dd-list');
        const cards = collectCards(grid || (document.getElementById('miniGrid') || document.querySelector('.mini-grid') || document.querySelector('[data-mini-grid]')));
        const set = new Set();
        cards.forEach(c=>{
          try{
            const name = detectStreamFromCard(c);
            if(name) set.add(name);
            if(!c.dataset.stream) c.dataset.stream = name;
          }catch(_){}
        });
        const streams = Array.from(set).sort((a,b)=> a.localeCompare(b,'ru'));
        const saved = (localStorage.getItem(LOCAL_KEY)||'').split('|').filter(Boolean);

        if(streams.length === 0){
          list.innerHTML = '<div style="padding:8px;color:#777">–ù–µ—Ç —Å—Ç—Ä–∏–º–æ–≤</div>';
          const cnt = dd.querySelector('#rrCount_safe'); if(cnt) cnt.textContent = '0';
          return;
        }

        const html = streams.map((s,i)=> {
          const safeId = 'rr_safe_cb_' + i;
          const checkedAttr = saved.length ? (saved.indexOf(s) !== -1 ? 'checked' : '') : 'checked';
          return '<div class="rr-dd-item" data-stream="'+escapeHtml(s)+'" style="display:flex;align-items:center">'
            + '<input type="checkbox" id="'+safeId+'" value="'+escapeHtml(s)+'" '+checkedAttr+'>'
            + '<label for="'+safeId+'">'+escapeHtml(s)+'</label>'
            + '</div>';
        }).join('');
        list.innerHTML = html;
        const cnt = dd.querySelector('#rrCount_safe'); if(cnt) cnt.textContent = String(streams.length);
      }catch(e){
        console.warn('rr-safe: refreshOptions error', e && e.message);
      }
    }

    function escapeHtml(s){
      return String(s).replace(/[&<>"']/g, m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
    }

    function attachHandlers(dd, grid){
      try{
        const btn = dd.querySelector('.rr-dd-trigger');
        const menu = dd.querySelector('.rr-dd-menu');
        const list = dd.querySelector('.rr-dd-list');
        if(!btn || !menu || !list) return;

        btn.addEventListener('click', function(e){
          try{
            const open = menu.classList.toggle('open');
            btn.setAttribute('aria-expanded', open ? 'true' : 'false');
            e.stopPropagation();
          }catch(_){}
        });

        document.addEventListener('click', function(e){
          try{
            if(!dd.contains(e.target)){
              menu.classList.remove('open');
              btn.setAttribute('aria-expanded','false');
            }
          }catch(_){}
        });

        dd.querySelectorAll('.rr-small-btn').forEach(function(b){
          b.addEventListener('click', function(e){
            try{
              const act = b.getAttribute('data-act');
              const cbs = Array.from(list.querySelectorAll('input[type=checkbox]'));
              if(act === 'all') cbs.forEach(cb=>cb.checked = true);
              else if(act === 'none') cbs.forEach(cb=>cb.checked = false);
              applyFilter(dd, grid);
              e.stopPropagation();
            }catch(_){}
          });
        });

        list.addEventListener('click', function(e){
          try{
            const t = e.target;
            if(t && t.matches && t.matches('input[type=checkbox]')){
              applyFilter(dd, grid);
            }
          }catch(_){}
        });

      }catch(e){
        console.warn('rr-safe: attachHandlers error', e && e.message);
      }
    }

    function applyFilter(dd, grid){
      try{
        const list = dd.querySelector('.rr-dd-list');
        if(!list) return;
        const cbs = Array.from(list.querySelectorAll('input[type=checkbox]'));
        const selected = cbs.filter(cb=>cb.checked).map(cb=>cb.value);
        const all = (selected.length === 0) || (selected.length === cbs.length);
        try{ localStorage.setItem(LOCAL_KEY, all ? '' : selected.join('|')); }catch(_){}
        const cards = collectCards(grid || (document.getElementById('miniGrid') || document.querySelector('.mini-grid') || document.querySelector('[data-mini-grid]')));
        cards.forEach(c=>{
          try{
            const s = c.dataset.stream || detectStreamFromCard(c);
            const ok = all || selected.indexOf(s) !== -1;
            c.classList.toggle('hide', !ok);
          }catch(_){}
        });
        const cnt = dd.querySelector('#rrCount_safe');
        if(cnt) cnt.textContent = all ? String(cbs.length) : String(selected.length);
      }catch(e){
        console.warn('rr-safe: applyFilter error', e && e.message);
      }
    }

    (function startMount(){
      let retries = 0;
      const root = document.getElementById('miniLaunchCard') || document;
      function tryOnce(){
        try{
          const {toolbar, grid} = findContext();
          if(toolbar){
            const dd = mountDropdown(toolbar, grid);
            const gridNode = grid || document.getElementById('miniGrid') || document.querySelector('.mini-grid') || document.querySelector('[data-mini-grid]');
            if(gridNode && !gridNode._rr_safe_observed){
              try{
                const mo = new MutationObserver(function(){ try{ refreshOptions(dd, gridNode); applyFilter(dd, gridNode); }catch(_){ } });
                mo.observe(gridNode, {childList:true, subtree:true});
                gridNode._rr_safe_observed = true;
              }catch(_){}
            }
            try{ applyFilter(dd, grid); }catch(_){}
            return true;
          }
        }catch(_){}
        return false;
      }

      if(tryOnce()) return;
      const iv = setInterval(function(){
        retries++;
        if(tryOnce() || retries > MAX_RETRIES){ clearInterval(iv); }
      }, RETRY_INTERVAL_MS);

      try{
        const container = document.getElementById('miniLaunchCard') || document.body;
        const mo2 = new MutationObserver(function(mutations){
          try{
            const {toolbar} = findContext();
            if(!toolbar) return;
            if(!safe$('#'+DROPDOWN_ID, toolbar)) {
              mountDropdown(toolbar, findContext().grid);
            } else {
              refreshOptions(safe$('#'+DROPDOWN_ID, toolbar), findContext().grid);
            }
          }catch(_){}
        });
        mo2.observe(container, {childList:true, subtree:true});
      }catch(_){}
    })();

  }catch(e){
    try{ console.warn('rr-safe: fatal initialization error', e && e.message); }catch(_){}
  }
})(); 
</script>
<!-- END: Safe standalone "–°—Ç—Ä–∏–º—ã" multiselect (injected by assistant) -->


<!-- START: remove duplicate empty "–°—Ç—Ä–∏–º—ã (0)" buttons (injected) -->
<script>
(function(){
  try{
    function cleanup(){
      const OUR_ID = 'rrStreamDD_safe_v1';
      // find candidate elements that look like stream dropdown wrappers
      const candidates = Array.from(document.querySelectorAll('.rr-stream-dd, [id^="rrStreamDD"], .rr-dd-trigger')).map(el=> el.closest('.rr-stream-dd') || el).filter(Boolean);
      const uniq = Array.from(new Set(candidates));
      uniq.forEach(dd => {
        try{
          if(!dd || dd.id === OUR_ID) return;
          // find badge or count inside
          const badge = dd.querySelector('#rrCount_safe, .rr-badge, #rrCount_compact');
          const countText = badge ? (badge.textContent || badge.innerText || '').trim() : '';
          // Also check visible label text '–°—Ç—Ä–∏–º—ã' and badge equals '0'
          const labelText = (dd.textContent || '').replace(/\s+/g,' ').trim();
          if((labelText.indexOf('–°—Ç—Ä–∏–º—ã')!==-1) && (countText === '0' || countText === '0')){
            dd.remove();
          }
        }catch(_){}
      });
    }
    if(document.readyState === 'loading') document.addEventListener('DOMContentLoaded', cleanup);
    else cleanup();
    // also run after a short delay in case components mount later
    setTimeout(cleanup, 1200);
    setTimeout(cleanup, 3000);
  }catch(e){ console.warn('rr-cleanup err', e && e.message); }
})();
</script>
<!-- END: remove duplicate empty "–°—Ç—Ä–∏–º—ã (0)" buttons (injected) -->


<!-- START: keep only rightmost .rr-stream-dd (duplicate cleanup) -->
<script>
(function(){
  function keepRightStream(){
    try{
      const all = Array.from(document.querySelectorAll('.rr-stream-dd'));
      if(all.length <= 1) return;
      // keep the rightmost (last) and remove others
      const last = all[all.length - 1];
      for(let i = 0; i < all.length - 1; i++){
        const el = all[i];
        if(el && el.parentNode) el.parentNode.removeChild(el);
      }
      console.log('rr-clean: kept rightmost rr-stream-dd, removed', all.length - 1, 'duplicates');
    }catch(e){
      console.warn('rr-clean error', e && (e.message || e));
    }
  }
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', function(){
      keepRightStream();
      setTimeout(keepRightStream, 600);
      setTimeout(keepRightStream, 1500);
      setTimeout(keepRightStream, 3000);
    });
  } else {
    keepRightStream();
    setTimeout(keepRightStream, 600);
    setTimeout(keepRightStream, 1500);
    setTimeout(keepRightStream, 3000);
  }
  // also observe DOM mutations under the toolbar area to catch late mounts
  try{
    const root = document.body;
    const mo = new MutationObserver(function(muts){
      if(muts && muts.length) keepRightStream();
    });
    mo.observe(root, { childList: true, subtree: true });
  }catch(_){}
})();
</script>
<!-- END: keep only rightmost .rr-stream-dd -->

</body>
</html>
<!-- FIXED: –¥–æ–±–∞–≤–ª–µ–Ω–∞ —Å—Ç—Ä–æ–∫–∞ –ü—Ä–æ—Ü–µ–Ω—Ç –ø–æ–∫—Ä—ã—Ç–∏—è –∫–µ–π—Å–æ–≤ SWAT —Å —É—á–µ—Ç–æ–º –ø–µ—Ä–µ–ø—Ä–æ—Ö–æ–¥–∞ STREAM -->
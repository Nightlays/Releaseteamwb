<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>WB All Table ‚Äî –≥—Ä–∞—Ñ–∏–∫–∏</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Tailwind –∫–∞–∫ –≤ uwu_6 (–¥–ª—è —É–¥–æ–±–Ω—ã—Ö —É—Ç–∏–ª–∏—Ç) -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

  <!-- –í—Å–µ –∫–∞—Å—Ç–æ–º–Ω—ã–µ —Å—Ç–∏–ª–∏ –≤—ã–Ω–µ—Å–µ–Ω—ã –≤ style.css -->
  <link rel="stylesheet" href="./style.css" />
</head>
<body class="min-h-screen">
  <div class="max-w-6xl mx-auto px-4 py-6">
    <header class="flex items-center justify-between gap-3 flex-wrap">
      <div class="brand-badge">
        <span class="brand-dot"></span>
        <div>
          <div class="flex items-center gap-2">
            <div class="font-extrabold leading-tight">WB All Table</div>
            <span id="appVersion" class="inline-flex items-center gap-1 text-[11px] font-semibold px-2 py-0.5 rounded-full bg-white/70 ring-1 ring-[#ecebff] text-slate-600">
              <span aria-hidden="true">üè∑Ô∏è</span><span>v0.1.5</span>
            </span>
          </div>
        </div>
      </div>
    </header>

    <main class="mt-5 grid grid-cols-1 gap-4">
      <!-- –ë–ª–æ–∫ –≤–≤–æ–¥–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ (–æ—Ç–¥–µ–ª—å–Ω–æ –æ—Ç —Ç–∞–±–ª–∏—Ü/–≥—Ä–∞—Ñ–∏–∫–æ–≤) -->
      <section class="card p-5 space-y-3">
        <div>
          <h2 class="text-lg font-semibold">–ü–∞—Ä–∞–º–µ—Ç—Ä—ã –∑–∞–ø—É—Å–∫–∞</h2>
          <div class="hint">–ó–∞–ø–æ–ª–Ω–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∏ –Ω–∞–∂–º–∏ ¬´–ó–∞–ø—É—Å—Ç–∏—Ç—å —Å–±–æ—Ä¬ª.</div>
        </div>

        <form class="w-full" onsubmit="return false;">
          <div class="border border-[#ecebff] rounded-2xl bg-white p-4">
            <div class="grid grid-cols-1 md:grid-cols-12 gap-3 items-end">
              <div class="md:col-span-4">
                <label class="block text-xs font-semibold text-[#111827] mb-1">–í–µ—Ä—Å–∏—è —Ä–µ–ª–∏–∑–∞</label>
                <div class="grid grid-cols-1 sm:grid-cols-2 gap-2">
                  <input class="input" id="releaseFrom" type="text" inputmode="numeric" placeholder="–û—Ç, –Ω–∞–ø—Ä. 7.3.5000" />
                  <input class="input" id="releaseTo" type="text" inputmode="numeric" placeholder="–î–æ, –Ω–∞–ø—Ä. 7.3.8000" />
                </div>
              </div>

              <div class="md:col-span-6">
                <label class="block text-xs font-semibold text-[#111827] mb-1">API —Ç–æ–∫–µ–Ω Allure</label>
                <input class="input" id="allureToken" type="password" autocomplete="off" placeholder="–í—Å—Ç–∞–≤—å—Ç–µ —Ç–æ–∫–µ–Ω Allure" />
              </div>

              <div class="md:col-span-2">
                <button id="startBtn" type="button" class="btn btn-grad w-full">–ó–∞–ø—É—Å—Ç–∏—Ç—å —Å–±–æ—Ä</button>
                <button id="stopBtn" type="button" class="btn btn-danger w-full" style="display:none;">–û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Å–±–æ—Ä</button>
                <button id="proxyBtn" type="button" class="mt-2 w-full inline-flex items-center justify-center gap-2 text-sm font-semibold px-3 py-2 rounded-2xl bg-white/70 ring-1 ring-[#ecebff] text-slate-700 hover:bg-white">
                  –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –ø—Ä–æ–∫—Å–∏
                </button>
              </div>

              <div class="md:col-span-4">
                <label class="block text-xs font-semibold text-[#111827] mb-1">Deploy-lab token</label>
                <input class="input" id="deployToken" type="password" autocomplete="off" placeholder="–í—Å—Ç–∞–≤—å—Ç–µ Deploy-lab token" />
              </div>

              <!-- YouTrack —Ç–æ–∫–µ–Ω —É–±—Ä–∞–Ω -->
            </div>

            <div class="mt-3 flex items-center gap-2 flex-wrap">
              <span class="text-xs text-slate-500">SWAT –ø–æ–ª—É—á–∞–µ–º</span>
              <a
                class="text-xs text-[#7c3aed] underline decoration-dotted hover:decoration-solid"
                href="https://docs.google.com/document/d/1AYHrg_w_aCdiunytlDVmbmyQAxiHRr51Z0Djju4GAnE/edit?tab=t.0"
                target="_blank" rel="noopener"
              >–æ—Ç—Å—é–¥–∞</a>
            </div>

            <div class="mt-1 text-xs text-slate-500">
              –ü–æ–ª—É—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö —á–µ—Ä–µ–∑ deploy-lab –∏–¥–µ—Ç —á–µ—Ä–µ–∑ –ø—Ä–æ–∫—Å–∏ <span class="mono">localhost:8787</span>
            </div>
          </div>
        </form>
      </section>

      <!-- –¢–∞–±–ª–∏—Ü—ã/–≥—Ä–∞—Ñ–∏–∫–∏ –Ω–∞—á–∏–Ω–∞—é—Ç—Å—è –Ω–∏–∂–µ -->
      <section class="card p-5 space-y-4">
        <div class="flex items-start justify-between gap-4 flex-wrap">
          <div>
            <h2 class="text-lg font-semibold">–¢–µ—Å—Ç –∫–µ–π—Å—ã –æ—Ç —Ä–µ–ª–∏–∑–∞ –∫ —Ä–µ–ª–∏–∑—É</h2>
          </div>
          <button type="button"
            class="inline-flex items-center gap-1.5 text-xs font-semibold px-2.5 py-1 rounded-xl bg-white/70 ring-1 ring-[#ecebff] text-slate-600 hover:bg-white"
            data-collapse-btn="tc" aria-expanded="true">
            <span data-collapse-ico aria-hidden="true">‚ñæ</span>
            <span data-collapse-text>–°–≤–µ—Ä–Ω—É—Ç—å</span>
          </button>
        </div>

        <div data-collapse-body="tc" class="space-y-4">
          <div class="overflow-auto border border-[#ecebff] rounded-2xl">
            <div id="tcEmpty" class="p-6 text-center text-sm text-slate-500 bg-white flex items-center justify-center" style="min-height:520px" aria-live="polite">
              –î–∞–Ω–Ω—ã–µ –ø–æ—è–≤—è—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–∑ –∏—Å—Ç–æ—á–Ω–∏–∫–∞
            </div>

            <div id="tcContent" class="tc-content" style="display:none;">
              <div class="chart-viewport" id="tcTrendViewport">
                <canvas id="tcTrendChart" aria-label="Test cases chart" role="img"></canvas>
              </div>

              <div id="tcTableWrap" style="display:none; overflow:auto">
                <table id="tcTable">
                  <thead>
                    <tr>
                      <th class="text-left">–†–µ–ª–∏–∑</th>
                      <th>–†—É—á–Ω—ã–µ</th>
                      <th>–ê–≤—Ç–æ</th>
                      <th>–í—Å–µ–≥–æ</th>
                      <th class="text-left">–ü–æ–ª–æ—Å—ã</th>
                    </tr>
                  </thead>
                  <tbody id="tcTbody"></tbody>
                </table>
              </div>
            </div>
          </div>

          <div class="flex flex-wrap items-center justify-start gap-3">
            <div class="legend">
              <span class="lg-item"><span class="dot dot-manual"></span>–†—É—á–Ω—ã–µ</span>
              <span class="lg-item"><span class="dot dot-auto"></span>–ê–≤—Ç–æ</span>
              <span class="lg-item"><span class="dot dot-total"></span>–í—Å–µ–≥–æ</span>
            </div>
          </div>
        </div>
      </section>

      <section class="card p-5 space-y-4">
        <div class="flex items-start justify-between gap-4 flex-wrap">
          <div>
            <h2 class="text-lg font-semibold">–ü–æ–∫—Ä—ã—Ç–∏–µ SWAT –∏ STREAM –•–ë</h2>
          </div>
          <button type="button"
            class="inline-flex items-center gap-1.5 text-xs font-semibold px-2.5 py-1 rounded-xl bg-white/70 ring-1 ring-[#ecebff] text-slate-600 hover:bg-white"
            data-collapse-btn="cov" aria-expanded="true">
            <span data-collapse-ico aria-hidden="true">‚ñæ</span>
            <span data-collapse-text>–°–≤–µ—Ä–Ω—É—Ç—å</span>
          </button>
        </div>

        <div data-collapse-body="cov" class="space-y-4">
          <div class="overflow-auto border border-[#ecebff] rounded-2xl">
            <div id="covEmpty" class="p-6 text-center text-sm text-slate-500 bg-white flex items-center justify-center" style="min-height:520px" aria-live="polite">
              –î–∞–Ω–Ω—ã–µ –ø–æ—è–≤—è—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–∑ –∏—Å—Ç–æ—á–Ω–∏–∫–∞
            </div>

            <div id="covContent" class="tc-content" style="display:none;">
              <div class="chart-viewport" id="covTrendViewport">
                <canvas id="covTrendChart" aria-label="SWAT/STREAM coverage chart" role="img"></canvas>
              </div>

              <div id="covTableWrap" style="display:none; overflow:auto">
                <table id="covTable">
                  <thead>
                    <tr>
                      <th class="text-left">–†–µ–ª–∏–∑</th>
                      <th>SWAT</th>
                      <th>STREAM</th>
                      <th>–í—Å–µ–≥–æ</th>
                      <th class="text-left">–ü–æ–∫—Ä—ã—Ç–∏–µ</th>
                    </tr>
                  </thead>
                  <tbody id="covTbody"></tbody>
                </table>
              </div>
            </div>
          </div>

          <div class="flex flex-wrap items-center justify-start gap-3">
            <div class="legend">
              <span class="lg-item"><span class="dot dot-swat"></span>SWAT</span>
              <span class="lg-item"><span class="dot dot-stream"></span>STREAM</span>
            </div>
          </div>
        </div>
      </section>

      <section class="card p-5 space-y-4">
        <div class="flex items-start justify-between gap-4 flex-wrap">
          <div>
            <h2 class="text-lg font-semibold">–ü–æ–∫—Ä—ã—Ç–∏–µ SWAT –∏ STREAM Selective</h2>
          </div>
          <button type="button"
            class="inline-flex items-center gap-1.5 text-xs font-semibold px-2.5 py-1 rounded-xl bg-white/70 ring-1 ring-[#ecebff] text-slate-600 hover:bg-white"
            data-collapse-btn="sel" aria-expanded="true">
            <span data-collapse-ico aria-hidden="true">‚ñæ</span>
            <span data-collapse-text>–°–≤–µ—Ä–Ω—É—Ç—å</span>
          </button>
        </div>

        <div data-collapse-body="sel" class="space-y-4">
          <div class="overflow-auto border border-[#ecebff] rounded-2xl">
            <div id="selEmpty" class="p-6 text-center text-sm text-slate-500 bg-white flex items-center justify-center" style="min-height:520px" aria-live="polite">
              –î–∞–Ω–Ω—ã–µ –ø–æ—è–≤—è—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–∑ –∏—Å—Ç–æ—á–Ω–∏–∫–∞
            </div>

            <div id="selContent" class="tc-content" style="display:none;">
              <div class="chart-viewport" id="selTrendViewport">
                <canvas id="selTrendChart" aria-label="SWAT/STREAM Selective chart" role="img"></canvas>
              </div>

              <div id="selTableWrap" style="display:none; overflow:auto">
                <table id="selTable">
                  <thead>
                    <tr>
                      <th class="text-left">–†–µ–ª–∏–∑</th>
                      <th>SWAT</th>
                      <th>STREAM</th>
                      <th>–í—Å–µ–≥–æ</th>
                      <th class="text-left">–ü–æ–∫—Ä—ã—Ç–∏–µ</th>
                    </tr>
                  </thead>
                  <tbody id="selTbody"></tbody>
                </table>
              </div>
            </div>
          </div>

          <div class="flex flex-wrap items-center justify-start gap-3">
            <div class="legend">
              <span class="lg-item"><span class="dot dot-swat"></span>SWAT</span>
              <span class="lg-item"><span class="dot dot-stream"></span>STREAM</span>
            </div>
          </div>
        </div>
      </section>

      <section class="card p-5 space-y-4">
        <div class="flex items-start justify-between gap-4 flex-wrap">
          <div>
            <h2 class="text-lg font-semibold">–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —á–µ—Ä–µ–ø–∏–∫–æ–≤</h2>
          </div>
          <button type="button"
            class="inline-flex items-center gap-1.5 text-xs font-semibold px-2.5 py-1 rounded-xl bg-white/70 ring-1 ring-[#ecebff] text-slate-600 hover:bg-white"
            data-collapse-btn="chp" aria-expanded="true">
            <span data-collapse-ico aria-hidden="true">‚ñæ</span>
            <span data-collapse-text>–°–≤–µ—Ä–Ω—É—Ç—å</span>
          </button>
        </div>

        <div data-collapse-body="chp" class="space-y-4">
          <div class="overflow-auto border border-[#ecebff] rounded-2xl">
            <div id="chpEmpty" class="p-6 text-center text-sm text-slate-500 bg-white flex items-center justify-center" style="min-height:520px" aria-live="polite">
              –î–∞–Ω–Ω—ã–µ –ø–æ—è–≤—è—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–∑ –∏—Å—Ç–æ—á–Ω–∏–∫–∞
            </div>

            <div id="chpContent" class="tc-content" style="display:none;">
              <div class="chart-viewport" id="chpTrendViewport">
                <canvas id="chpTrendChart" aria-label="Cherepiki chart" role="img"></canvas>
              </div>

              <div id="chpTableWrap" style="display:none; overflow:auto">
                <table id="chpTable">
                  <thead>
                    <tr>
                      <th class="text-left">–†–µ–ª–∏–∑</th>
                      <th>iOS</th>
                      <th>Android</th>
                      <th>–í—Å–µ–≥–æ</th>
                    </tr>
                  </thead>
                  <tbody id="chpTbody"></tbody>
                </table>
              </div>
            </div>
          </div>

          <div class="flex flex-wrap items-center justify-start gap-3">
            <div class="legend">
              <span class="lg-item"><span class="dot" style="background: var(--chp-ios, #0ea5e9)"></span>iOS</span>
              <span class="lg-item"><span class="dot" style="background: var(--chp-android, #22c55e)"></span>Android</span>
              <span class="lg-item"><span class="dot" style="background: var(--chp-total, #a855f7)"></span>–í—Å–µ–≥–æ</span>
            </div>
          </div>
        </div>
      </section>

      <!-- 5-—è —Ç–∞–±–ª–∏—Ü–∞: —Å—Ä–µ–¥–Ω–µ–µ –≤—Ä–µ–º—è -->
      <section class="card p-5 space-y-4">
        <div class="flex items-start justify-between gap-4 flex-wrap">
          <div>
            <h2 class="text-lg font-semibold">–°—Ä–µ–¥–Ω–µ–µ –≤—Ä–µ–º—è –ø—Ä–æ—Ö–æ–∂–¥–µ–Ω–∏—è –∫–µ–π—Å–∞</h2>
          </div>
          <button type="button"
            class="inline-flex items-center gap-1.5 text-xs font-semibold px-2.5 py-1 rounded-xl bg-white/70 ring-1 ring-[#ecebff] text-slate-600 hover:bg-white"
            data-collapse-btn="avg" aria-expanded="true">
            <span data-collapse-ico aria-hidden="true">‚ñæ</span>
            <span data-collapse-text>–°–≤–µ—Ä–Ω—É—Ç—å</span>
          </button>
        </div>

        <div data-collapse-body="avg" class="space-y-4">
          <div class="overflow-auto border border-[#ecebff] rounded-2xl">
            <div id="avgEmpty" class="p-6 text-center text-sm text-slate-500 bg-white flex items-center justify-center" style="min-height:520px" aria-live="polite">
              –î–∞–Ω–Ω—ã–µ –ø–æ—è–≤—è—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–∑ –∏—Å—Ç–æ—á–Ω–∏–∫–∞
            </div>

            <div id="avgContent" class="tc-content" style="display:none;">
              <div class="chart-viewport" id="avgTrendViewport">
                <canvas id="avgTrendChart" aria-label="Average time chart" role="img"></canvas>
              </div>

              <div id="avgTableWrap" style="display:none; overflow:auto">
                <table id="avgTable">
                  <thead>
                    <tr>
                      <th class="text-left">–†–µ–ª–∏–∑</th>
                      <th>SWAT</th>
                      <th>STREAM</th>
                      <th>–û–±—â–µ–µ</th>
                    </tr>
                  </thead>
                  <tbody id="avgTbody"></tbody>
                </table>
              </div>
            </div>
          </div>

          <div class="flex flex-wrap items-center justify-start gap-3">
            <div class="legend">
              <span class="lg-item"><span class="dot dot-swat"></span>SWAT</span>
              <span class="lg-item"><span class="dot dot-stream"></span>STREAM</span>
              <span class="lg-item"><span class="dot dot-total"></span>–û–±—â–µ–µ</span>
            </div>
          </div>
        </div>
      </section>

      <script>
        (function(){
          const BASE_URL = 'https://allure-testops.wb.ru';
          const PROJECT_ID = 7;
          const PAGE_SIZE = 1000;
          const KINDS = ['Smoke', 'Selective'];
          const SWAT_LIST_URL = 'https://script.google.com/macros/s/AKfycbwJapteQxL-8LqmX88qMa2wtlD760v4rvkISWm1YP-NDguwW08ZzmEADV-0kqjg3cC3zQ/exec';
          const PROXY_BASE = 'http://localhost:8787';
          const LS_COLLAPSE_KEY = 'wb_all_table_collapsed';
          const DEPLOY_ISSUES_URL_TMPL = 'https://deploy-lab-api.wb.ru/releaseboss/admin_panel/release/{prefix}_{rel}/issues';

          const LS_TOKEN_KEY = 'swat_uwu_token';
          const LS_RANGE_KEY = 'swat_uwu_release_range';

          const startBtn = document.getElementById('startBtn');
          const stopBtn  = document.getElementById('stopBtn');
          const proxyBtn = document.getElementById('proxyBtn');

          const inpFrom  = document.getElementById('releaseFrom');
          const inpTo    = document.getElementById('releaseTo');
          const inpAllureToken = document.getElementById('allureToken');
          const inpDeployToken = document.getElementById('deployToken');

          const emptyBox = document.getElementById('tcEmpty');
          const contentWrap = document.getElementById('tcContent');
          const tbody = document.getElementById('tcTbody');

          // Coverage section
          const covEmpty = document.getElementById('covEmpty');
          const covContent = document.getElementById('covContent');
          const covTbody = document.getElementById('covTbody');

          // Selective coverage section
          const selEmpty = document.getElementById('selEmpty');
          const selContent = document.getElementById('selContent');
          const selTbody = document.getElementById('selTbody');
          const selCanvas = document.getElementById('selTrendChart');

          // Cherepiki section
          const chpEmpty = document.getElementById('chpEmpty');
          const chpContent = document.getElementById('chpContent');
          const chpTbody = document.getElementById('chpTbody');
          const chpCanvas = document.getElementById('chpTrendChart');

          // Average time section
          const avgEmpty = document.getElementById('avgEmpty');
          const avgContent = document.getElementById('avgContent');
          const avgTbody = document.getElementById('avgTbody');
          const avgCanvas = document.getElementById('avgTrendChart');

          const chartCanvas = document.getElementById('tcTrendChart');
          const covCanvas = document.getElementById('covTrendChart');

          let tcChart = null;
          let covChart = null;
          let selChart = null;
          let chpChart = null;
          let avgChart = null;

          // SWAT list cache: fetch exec only once (shared promise)
          let __swatSetCache = null;
          let __swatSetPromise = null;

          // Plugin: delta labels above points (for selected dataset)
          const deltaLabelsPlugin = {
            id: 'deltaLabels',
            afterDatasetsDraw(chart, args, pluginOptions){
              const opts = pluginOptions || chart?.options?.plugins?.deltaLabels;
              if(!opts) return;
              const dsIndex = Number(opts.datasetIndex);
              if(!Number.isFinite(dsIndex)) return;
              const ds = chart.data?.datasets?.[dsIndex];
              const meta = chart.getDatasetMeta(dsIndex);
              if(!ds || !meta || !meta.data) return;

              const data = Array.isArray(ds.data) ? ds.data : [];
              if(data.length < 2) return;

              const green = (opts.upColor) || '#22c55e';
              const red   = (opts.downColor) || '#f43f5e';
              const font  = (opts.font) || '600 11px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial';

              const fmt = (v) => {
                try {
                  const n = Number(v);
                  if(!Number.isFinite(n)) return '';
                  const sign = n > 0 ? '+' : '';
                  return sign + Math.round(n).toLocaleString('ru-RU');
                } catch {
                  const sign = v > 0 ? '+' : '';
                  return sign + String(v);
                }
              };

              const ctx = chart.ctx;
ctx.save();

// allow drawing outside chartArea (e.g., delta labels above top points)
ctx.beginPath();
ctx.rect(0, 0, chart.width, chart.height);
ctx.clip();

ctx.font = font;
              ctx.textAlign = 'center';
              ctx.textBaseline = 'bottom';

              for(let i = 1; i < data.length; i++){
                const cur = Number(data[i]);
                const prev = Number(data[i-1]);
                if(!Number.isFinite(cur) || !Number.isFinite(prev)) continue;
                const delta = cur - prev;
                if(!delta) continue;

                const pt = meta.data[i];
                if(!pt) continue;
                const x = pt.x;
                const y = pt.y;

                const label = fmt(delta);
                if(!label) continue;

                ctx.fillStyle = delta > 0 ? green : red;
                ctx.fillText(label, x, y - 12);
              }

              ctx.restore();
            }
          };

          try{
            if(window.Chart && typeof window.Chart.register === 'function'){
              window.Chart.register(deltaLabelsPlugin);
            }
          }catch(e){}

          function b64Utf8(str){
            return btoa(unescape(encodeURIComponent(str)));
          }
          function b64Query(filters){
            return b64Utf8(JSON.stringify(filters));
          }

          function normalizeLogin(v){
            if(v === null || v === undefined) return '';
            let s = String(v).trim();
            if(!s) return '';
            s = s.replace(/^@+/, '');
            s = s.split(/[\s,(]/)[0];
            return s.trim().toLowerCase();
          }

          function authHeaders(){
            const tok = (inpAllureToken?.value || '').trim();
            return {
              'Accept': 'application/json',
              'Authorization': `Api-Token ${tok}`
            };
          }

          function deployHeaders(){
            const tok = (inpDeployToken?.value || '').trim();
            return {
              'accept': '*/*',
              'accept-language': 'ru,en;q=0.9',
              'authorization-deploy-lab': `Bearer ${tok}`,
              'origin': 'https://deploy-lab.wb.ru',
              'referer': 'https://deploy-lab.wb.ru/',
              'user-agent': 'Mozilla/5.0'
            };
          }

          function showToast(msg, ok=true){
            const el = document.getElementById('toast');
            const inner = document.getElementById('toastInner');
            if(!el || !inner) return;
            inner.textContent = msg;
            inner.className = 'px-4 py-2 rounded-2xl text-sm font-semibold ring-1 shadow ' + (ok
              ? 'bg-white/90 ring-[#ecebff] text-slate-700'
              : 'bg-rose-50 ring-rose-200 text-rose-700'
            );
            el.style.opacity = '1';
            clearTimeout(showToast.__t);
            showToast.__t = setTimeout(() => { el.style.opacity = '0'; }, 1800);
          }

          async function proxyGetJson(targetUrl, headers, signal){
            const p = new URL(PROXY_BASE + '/proxy');
            p.searchParams.set('url', targetUrl);
            const r = await fetch(p.toString(), { headers, signal });
            if(!r.ok) throw new Error(`Proxy HTTP ${r.status}`);
            return r.json();
          }

          async function fetchDeployIssueCount(prefix, release, signal){
            const tok = (inpDeployToken?.value || '').trim();
            if(!tok) return 0;
            const url = DEPLOY_ISSUES_URL_TMPL
              .replace('{prefix}', prefix)
              .replace('{rel}', release);
            const data = await proxyGetJson(url, deployHeaders(), signal);
            if(!Array.isArray(data)) return 0;
            let n = 0;
            for(const item of data){
              if(item && item.merged_after_cutoff === true) n += 1;
            }
            return n;
          }

          function setChpEmpty(text){
            if(!chpEmpty) return;
            chpEmpty.textContent = text;
            chpEmpty.style.display = '';
          }
          function showChpContent(){
            if(chpEmpty) chpEmpty.style.display = 'none';
            if(chpContent) chpContent.style.display = '';
          }
          function showChpEmpty(text){
            setChpEmpty(text);
            if(chpContent) chpContent.style.display = 'none';
          }

          function setAvgEmpty(text){
            if(!avgEmpty) return;
            avgEmpty.textContent = text;
            avgEmpty.style.display = '';
          }
          function showAvgContent(){
            if(avgEmpty) avgEmpty.style.display = 'none';
            if(avgContent) avgContent.style.display = '';
          }
          function showAvgEmpty(text){
            setAvgEmpty(text);
            if(avgContent) avgContent.style.display = 'none';
          }

          // –í–≤–æ–¥ —Å–≤–æ–±–æ–¥–Ω—ã–π: X.Y.Z, –≥–¥–µ Z –º–æ–∂–µ—Ç –±—ã—Ç—å 1..4 —Ü–∏—Ñ—Ä—ã (7 -> 7000, 73 -> 7300, 777 -> 7770)
          function parseVersion(v){
            const raw = (v||'').trim();
            const parts = raw.split('.').map(x => x.trim());
            if(parts.length < 3) return null;

            const [major, minor, buildRaw] = parts;
            if(!/^\d+$/.test(major) || !/^\d+$/.test(minor) || !/^\d+$/.test(buildRaw)) return null;

            const majorN = Number(major);
            const minorN = Number(minor);
            if(!Number.isFinite(majorN) || !Number.isFinite(minorN)) return null;

            let buildN = Number(buildRaw);
            if(!Number.isFinite(buildN)) return null;

            const len = buildRaw.length;
            if(len < 4){
              buildN = buildN * Math.pow(10, 4 - len);
            }

            const buildStrNorm = String(buildN).padStart(4, '0');
            return { major, minor, majorN, minorN, build: buildN, buildStrRaw: buildRaw, buildStrNorm };
          }

          function buildMajorRange(){
            const a = parseVersion(inpFrom?.value);
            const b = parseVersion(inpTo?.value);
            if(!a || !b) return [];

            if(a.majorN !== b.majorN) return [];

            const step = 1000;

            const aKey = a.minorN * 10000 + a.build;
            const bKey = b.minorN * 10000 + b.build;
            const loV = aKey <= bKey ? a : b;
            const hiV = aKey <= bKey ? b : a;

            const out = [];

            for(let m = loV.minorN; m <= hiV.minorN; m++){
              let startBuild = 0;
              let endBuild   = 9000;

              if(m === loV.minorN) startBuild = Math.ceil(loV.build / step) * step;
              if(m === hiV.minorN) endBuild   = Math.floor(hiV.build / step) * step;

              if(startBuild > endBuild) continue;

              for(let build = startBuild; build <= endBuild; build += step){
                const buildStr = String(build).padStart(4, '0');
                out.push(`${loV.major}.${m}.${buildStr}`);
              }
            }

            return out;
          }

          function formatRelease(vObj){
            const m = String(vObj.majorN);
            const n = String(vObj.minorN);
            const b = (vObj.buildStrNorm ? String(vObj.buildStrNorm) : String(vObj.build).padStart(4, '0'));
            return `${m}.${n}.${b}`;
          }

          function validateAndNormalizeReleaseInput(inputEl){
            if(!inputEl) return null;
            const raw = (inputEl.value || '').trim();
            if(!raw){
              try{ inputEl.setCustomValidity(''); }catch(e){}
              return null;
            }
            const v = parseVersion(raw);
            if(!v){
              try{ inputEl.setCustomValidity(''); }catch(e){}
              return null;
            }
            const norm = formatRelease(v);
            inputEl.value = norm;
            try{ inputEl.setCustomValidity(''); }catch(e){}
            return norm;
          }

          function attachReleaseMask(){
            [inpFrom, inpTo].forEach(el => {
              if(!el) return;
              el.addEventListener('input', () => { try{ el.setCustomValidity(''); }catch(e){} });
              el.addEventListener('blur', () => validateAndNormalizeReleaseInput(el));
            });
          }

          async function httpGet(path, params, signal){
            const url = new URL(BASE_URL + path);
            if(params){
              Object.entries(params).forEach(([k,v]) => {
                if(v !== undefined && v !== null && v !== '') url.searchParams.set(k, String(v));
              });
            }
            const r = await fetch(url.toString(), { headers: authHeaders(), signal });
            if(!r.ok) throw new Error(`HTTP ${r.status} ${path}`);
            return r.json();
          }

          async function fetchLaunches(version, kind, signal){
            const terms = [`[${kind}] –†–µ–≥—Ä–µ—Å—Å ${version}`];
            if(kind === 'Smoke') terms.push(`[High/Blocker][DeployLab] –†–µ–≥—Ä–µ—Å—Å ${version}`);
            if(kind === 'Selective') terms.push(`[Selective][DeployLab] –†–µ–≥—Ä–µ—Å—Å ${version}`);

            const byId = new Map();
            for(const term of terms){
              const search = b64Query([{ id:'name', type:'string', value: term }]);
              let page = 0;
              while(true){
                const data = await httpGet('/api/launch', {
                  page, size: PAGE_SIZE, search,
                  projectId: PROJECT_ID,
                  preview: 'true',
                  sort: 'createdDate,desc'
                }, signal);

                const content = (data && data.content) ? data.content : [];
                if(!content.length) break;
                content.forEach(it => {
                  const id = Number(it && it.id);
                  if(Number.isFinite(id)) byId.set(id, it);
                });
                if(content.length < PAGE_SIZE) break;
                page += 1;
              }
            }
            return Array.from(byId.values());
          }

          async function fetchHBLaunches(version, signal){
            const terms = [
              `[High/Blocker][DeployLab] –†–µ–≥—Ä–µ—Å—Å ${version}`,
            ];

            const byId = new Map();
            for(const term of terms){
              const search = b64Query([{ id:'name', type:'string', value: term }]);
              let page = 0;
              while(true){
                const data = await httpGet('/api/launch', {
                  page, size: PAGE_SIZE, search,
                  projectId: PROJECT_ID,
                  preview: 'true',
                  sort: 'createdDate,desc'
                }, signal);

                const content = (data && data.content) ? data.content : [];
                if(!content.length) break;
                content.forEach(it => {
                  const id = Number(it && it.id);
                  if(Number.isFinite(id)) byId.set(id, it);
                });
                if(content.length < PAGE_SIZE) break;
                page += 1;
              }
            }
            return Array.from(byId.values());
          }

          async function fetchTotalCases(launchId, signal){
            const data = await httpGet(`/api/launch/${launchId}/statistic`, null, signal);
            if(!Array.isArray(data)) return 0;
            return data.reduce((acc, d) => acc + Number(d?.count || 0), 0);
          }

          async function fetchAutomatedTotalCases(launchId, signal, treeId=14){
            const search = b64Query([{ id:'automated', type:'boolean', value: true }]);
            const data = await httpGet('/api/testresulttree/group', {
              launchId, treeId, search,
              sort: 'duration,asc',
              size: PAGE_SIZE
            }, signal);
            const content = (data && data.content) ? data.content : [];
            let total = 0;
            content.forEach(item => {
              const stat = item?.statistic || {};
              total += Number(stat?.total || 0);
            });
            return total;
          }

          const __memberStatsCache = new Map();
          const __launchDurationCache = new Map();

          async function fetchMemberStats(launchId, signal){
            if(__memberStatsCache.has(launchId)) return __memberStatsCache.get(launchId);
            const data = await httpGet(`/api/launch/${launchId}/memberstats`, { size: 1000, page: 0 }, signal);
            let out;
            if(Array.isArray(data)) out = data;
            else if(data && typeof data === 'object') out = data.content || [];
            else out = [];
            __memberStatsCache.set(launchId, out);
            return out;
          }

          async function fetchLaunchDurationMs(launchId, signal){
            if(__launchDurationCache.has(launchId)) return __launchDurationCache.get(launchId);
            let ms = 0;
            try{
              const d = await httpGet(`/api/launch/${launchId}`, null, signal);
              ms = Number(d?.duration || d?.statistic?.duration || 0) || 0;
            }catch(e){
              ms = 0;
            }
            __launchDurationCache.set(launchId, ms);
            return ms;
          }

         function swatStreamAgg(memberstats, swatSet){
  let swatTotal = 0;
  let streamTotal = 0;
  let swatDur = 0;
  let streamDur = 0;
  let swatExec = 0;
  let streamExec = 0;

  const pushStat = (bucket, statItem) => {
    if(!statItem || typeof statItem !== 'object') return;
    const c = Number(statItem.count ?? statItem.total ?? statItem.tests ?? 0) || 0;
    const d = Number(statItem.duration ?? statItem.time ?? 0) || 0;

    if(c > 0) bucket.total += c;
    // for avg time we count only "executed" items (where we have duration)
    if(c > 0 && d > 0) bucket.exec += c;
    if(d > 0) bucket.dur += d;
  };

  for(const m of (memberstats || [])){
    if(!m || typeof m !== 'object') continue;
    const assignee = String(m.assignee || '').trim().toLowerCase();

    let total = 0;
    let exec = 0;
    let dur = 0;

    const stat = m.statistic;

    // statistic can be: array of items OR object keyed by status OR a single object
    if(Array.isArray(stat)){
      const bucket = { total: 0, exec: 0, dur: 0 };
      for(const s of stat) pushStat(bucket, s);
      total = bucket.total;
      exec  = bucket.exec;
      dur   = bucket.dur;
    }else if(stat && typeof stat === 'object'){
      const bucket = { total: 0, exec: 0, dur: 0 };

      // if it already looks like a stat item
      if(('count' in stat) || ('total' in stat) || ('duration' in stat) || ('time' in stat)){
        pushStat(bucket, stat);
      }else{
        // otherwise iterate nested values
        for(const v of Object.values(stat)){
          if(Array.isArray(v)){
            for(const vv of v) pushStat(bucket, vv);
          }else{
            pushStat(bucket, v);
          }
        }
      }

      total = bucket.total;
      exec  = bucket.exec;
      dur   = bucket.dur;
    }

    // fallback: memberstats provides durationSum per assignee
    if(!dur){
      dur = Number(m.durationSum ?? m.duration ?? m.time ?? 0) || 0;
    }

    // if we have duration but exec is 0 (no per-status durations), assume all counted cases are executed
    if(dur > 0 && exec === 0 && total > 0){
      exec = total;
    }

    if(total <= 0) continue;

    if(assignee && swatSet && swatSet.has(assignee)){
      swatTotal += total;
      swatExec  += exec;
      swatDur   += dur;
    }else{
      streamTotal += total;
      streamExec  += exec;
      streamDur   += dur;
    }
  }

  return { swatTotal, streamTotal, swatDur, streamDur, swatExec, streamExec };
}

          function saveInputs(){
            try{ localStorage.setItem(LS_TOKEN_KEY, inpAllureToken.value || ''); }catch(e){}
            try{ localStorage.setItem(LS_RANGE_KEY, JSON.stringify({ from: inpFrom.value || '', to: inpTo.value || '' })); }catch(e){}
          }

          function restoreInputs(){
            try{
              const tok = localStorage.getItem(LS_TOKEN_KEY) || '';
              if(inpAllureToken) inpAllureToken.value = tok;
            }catch(e){}
            try{
              const raw = localStorage.getItem(LS_RANGE_KEY);
              if(raw){
                const obj = JSON.parse(raw);
                if(inpFrom) inpFrom.value = obj?.from || '';
                if(inpTo) inpTo.value = obj?.to || '';
              }
            }catch(e){}
          }

          function setEmpty(text){
            if(!emptyBox) return;
            emptyBox.textContent = text;
            emptyBox.style.display = '';
          }

          function showContent(){
            if(emptyBox) emptyBox.style.display = 'none';
            contentWrap.style.display = '';
          }

          function showEmpty(text){
            setEmpty(text);
            contentWrap.style.display = 'none';
          }

          function setCovEmpty(text){
            if(!covEmpty) return;
            covEmpty.textContent = text;
            covEmpty.style.display = '';
          }

          function showCovContent(){
            if(covEmpty) covEmpty.style.display = 'none';
            if(covContent) covContent.style.display = '';
          }

          function showCovEmpty(text){
            setCovEmpty(text);
            if(covContent) covContent.style.display = 'none';
          }

          function setSelEmpty(text){
            if(!selEmpty) return;
            selEmpty.textContent = text;
            selEmpty.style.display = '';
          }

          function showSelContent(){
            if(selEmpty) selEmpty.style.display = 'none';
            if(selContent) selContent.style.display = '';
          }

          function showSelEmpty(text){
            setSelEmpty(text);
            if(selContent) selContent.style.display = 'none';
          }

          function setRunning(running){
            if(running){
              startBtn.style.display = 'none';
              stopBtn.style.display = '';
              window.__wbAbortController = new AbortController();
              showEmpty('–î–∞–Ω–Ω—ã–µ –ø–æ—è–≤—è—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–∑ –∏—Å—Ç–æ—á–Ω–∏–∫–∞');
              showCovEmpty('–î–∞–Ω–Ω—ã–µ –ø–æ—è–≤—è—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–∑ –∏—Å—Ç–æ—á–Ω–∏–∫–∞');
              showSelEmpty('–î–∞–Ω–Ω—ã–µ –ø–æ—è–≤—è—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–∑ –∏—Å—Ç–æ—á–Ω–∏–∫–∞');
              showChpEmpty('–î–∞–Ω–Ω—ã–µ –ø–æ—è–≤—è—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–∑ –∏—Å—Ç–æ—á–Ω–∏–∫–∞');
              showAvgEmpty('–î–∞–Ω–Ω—ã–µ –ø–æ—è–≤—è—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–∑ –∏—Å—Ç–æ—á–Ω–∏–∫–∞');
            }else{
              stopBtn.style.display = 'none';
              startBtn.style.display = '';
              if(window.__wbAbortController){
                try{ window.__wbAbortController.abort(); }catch(e){}
              }
              window.__wbAbortController = null;
            }
          }

          function clear(){
            tbody.innerHTML = '';
            if(tcChart){
              tcChart.data.labels = [];
              tcChart.data.datasets.forEach(d => d.data = []);
              tcChart.update();
            }

            if(covTbody) covTbody.innerHTML = '';
            if(covChart){
              covChart.data.labels = [];
              covChart.data.datasets.forEach(d => d.data = []);
              covChart.update();
            }

            if(selTbody) selTbody.innerHTML = '';
            if(selChart){
              selChart.data.labels = [];
              selChart.data.datasets.forEach(d => d.data = []);
              selChart.update();
            }

            if(chpTbody) chpTbody.innerHTML = '';
            if(chpChart){
              chpChart.data.labels = [];
              chpChart.data.datasets.forEach(d => d.data = []);
              chpChart.update();
            }

            if(avgTbody) avgTbody.innerHTML = '';
            if(avgChart){
              avgChart.data.labels = [];
              avgChart.data.datasets.forEach(d => d.data = []);
              avgChart.update();
            }
          }

          async function fetchSwatLogins(release, signal){
            if(__swatSetCache) return __swatSetCache;
            if(__swatSetPromise) return __swatSetPromise;

            __swatSetPromise = (async () => {
              const url = new URL(SWAT_LIST_URL);

              const r = await fetch(url.toString(), { signal });
              if(!r.ok) throw new Error(`SWAT list HTTP ${r.status}`);
              const text = await r.text();
              const set = new Set();
              text.split(/\r?\n/).forEach(line => {
                const s = (line || '').trim();
                if(!s) return;
                const first = s.split(/\s+/)[0];
                const norm = normalizeLogin(first);
                if(norm) set.add(norm);
              });
              __swatSetCache = set;
              return set;
            })();

            try{
              return await __swatSetPromise;
            }catch(e){
              __swatSetPromise = null;
              __swatSetCache = null;
              throw e;
            }
          }

          function cssVar(name, fallback){
            try{
              const v = getComputedStyle(document.documentElement).getPropertyValue(name).trim();
              return v || fallback;
            }catch{ return fallback; }
          }

          function formatMsPerCase(ms){
            const n = Number(ms) || 0;
            if(n <= 0) return '00:00';
            const totalSec = Math.round(n / 1000);
            const h = Math.floor(totalSec / 3600);
            const m = Math.floor((totalSec % 3600) / 60);
            const s = totalSec % 60;
            const mm = String(m).padStart(2,'0');
            const ss = String(s).padStart(2,'0');
            if(h > 0){
              return `${h}:${mm}:${ss}`;
            }
            return `${mm}:${ss}`;
          }

          function ensureCoverageChart(){
            if(!covCanvas || !window.Chart) return;
            if(covChart){
              covChart.data.labels = [];
              covChart.data.datasets.forEach(d => d.data = []);
              covChart.update();
              return;
            }

            const cSwat   = cssVar('--cov-swat', '#22c55e');
            const cStream = cssVar('--cov-stream', '#f43f5e');

            covChart = new Chart(covCanvas, {
              type: 'line',
              data: {
                labels: [],
                datasets: [
                  { label: 'SWAT',   data: [], borderColor: cSwat,   backgroundColor: cSwat,   tension: 0.25, pointRadius: 3, pointHoverRadius: 5 },
                  { label: 'STREAM', data: [], borderColor: cStream, backgroundColor: cStream, tension: 0.25, pointRadius: 3, pointHoverRadius: 5 }
                ]
              },
              options: {
                maintainAspectRatio: false,
                plugins: {
                  legend: { display: false },
                  deltaLabels: { datasetIndex: 0 }, /* –¥–µ–ª—å—Ç–∞ –¥–ª—è SWAT */
                  tooltip: {
                    mode: 'index',
                    intersect: false,
                    itemSort: (a, b) => {
                      const av = Number(a?.raw ?? a?.parsed?.y ?? 0);
                      const bv = Number(b?.raw ?? b?.parsed?.y ?? 0);
                      return (bv - av) || ((a.datasetIndex ?? 0) - (b.datasetIndex ?? 0));
                    },
                    callbacks: {
                      title: (items) => {
                        const lbl = items?.[0]?.label;
                        return lbl ? `–†–µ–ª–∏–∑ ${lbl}` : '';
                      },
                      label: (ctx) => {
                        const i = ctx.dataIndex;
                        const sw = Number(covChart.data.datasets[0].data[i] || 0);
                        const st = Number(covChart.data.datasets[1].data[i] || 0);
                        const sum = Math.max(1, sw + st);
                        const val = Number(ctx.raw || 0);
                        const pct = Math.round((val / sum) * 1000) / 10;
                        return `${ctx.dataset.label}: ${val} | ${pct}%`;
                      },
                      footer: (items) => {
                        const i = items?.[0]?.dataIndex;
                        const sw = Number(covChart.data.datasets[0].data[i] || 0);
                        const st = Number(covChart.data.datasets[1].data[i] || 0);
                        return `–í—Å–µ–≥–æ: ${sw + st}`;
                      }
                    }
                  }
                },
                interaction: { mode: 'index', intersect: false },
                scales: {
                  x: {
                    offset: false,
                    bounds: 'data',
                    ticks: { maxRotation: 0, autoSkip: true },
                    grid: { color: 'rgba(148,163,184,.25)' }
                  },
              y: { beginAtZero: true, grace: '12%', grid: { color: 'rgba(148,163,184,.25)' } }
                }
              }
            });
          }

          function ensureSelectiveChart(){
            if(!selCanvas || !window.Chart) return;
            if(selChart){
              selChart.data.labels = [];
              selChart.data.datasets.forEach(d => d.data = []);
              selChart.update();
              return;
            }

            const cSwat   = cssVar('--cov-swat', '#22c55e');
            const cStream = cssVar('--cov-stream', '#f43f5e');

            selChart = new Chart(selCanvas, {
              type: 'line',
              data: {
                labels: [],
                datasets: [
                  { label: 'SWAT',   data: [], borderColor: cSwat,   backgroundColor: cSwat,   tension: 0.25, pointRadius: 3, pointHoverRadius: 5 },
                  { label: 'STREAM', data: [], borderColor: cStream, backgroundColor: cStream, tension: 0.25, pointRadius: 3, pointHoverRadius: 5 }
                ]
              },
              options: {
                maintainAspectRatio: false,
                plugins: {
                  legend: { display: false },
                  deltaLabels: { datasetIndex: 0 }, /* –¥–µ–ª—å—Ç–∞ –¥–ª—è SWAT */
                  tooltip: {
                    mode: 'index',
                    intersect: false,
                    itemSort: (a, b) => {
                      const av = Number(a?.raw ?? a?.parsed?.y ?? 0);
                      const bv = Number(b?.raw ?? b?.parsed?.y ?? 0);
                      return (bv - av) || ((a.datasetIndex ?? 0) - (b.datasetIndex ?? 0));
                    },
                    callbacks: {
                      title: (items) => {
                        const lbl = items?.[0]?.label;
                        return lbl ? `–†–µ–ª–∏–∑ ${lbl}` : '';
                      },
                      label: (ctx) => {
                        const i = ctx.dataIndex;
                        const sw = Number(selChart.data.datasets[0].data[i] || 0);
                        const st = Number(selChart.data.datasets[1].data[i] || 0);
                        const sum = Math.max(1, sw + st);
                        const val = Number(ctx.raw || 0);
                        const pct = Math.round((val / sum) * 1000) / 10;
                        return `${ctx.dataset.label}: ${val} | ${pct}%`;
                      },
                      footer: (items) => {
                        const i = items?.[0]?.dataIndex;
                        const sw = Number(selChart.data.datasets[0].data[i] || 0);
                        const st = Number(selChart.data.datasets[1].data[i] || 0);
                        return `–í—Å–µ–≥–æ: ${sw + st}`;
                      }
                    }
                  }
                },
                interaction: { mode: 'index', intersect: false },
                scales: {
                  x: {
                    offset: false,
                    bounds: 'data',
                    ticks: { maxRotation: 0, autoSkip: true },
                    grid: { color: 'rgba(148,163,184,.25)' }
                  },
                  y: { beginAtZero: true, grace: '12%', grid: { color: 'rgba(148,163,184,.25)' } }
                }
              }
            });
          }

          function ensureChpChart(){
            if(!chpCanvas || !window.Chart) return;
            if(chpChart){
              chpChart.data.labels = [];
              chpChart.data.datasets.forEach(d => d.data = []);
              chpChart.update();
              return;
            }
            const cIos = cssVar('--chp-ios', '#0ea5e9');
            const cAnd = cssVar('--chp-android', '#22c55e');
            const cTot = cssVar('--chp-total', '#a855f7');

            chpChart = new Chart(chpCanvas, {
              type: 'line',
              data: {
                labels: [],
                datasets: [
                  { label: 'iOS', data: [], borderColor: cIos, backgroundColor: cIos, tension: 0.25, pointRadius: 3, pointHoverRadius: 5 },
                  { label: 'Android', data: [], borderColor: cAnd, backgroundColor: cAnd, tension: 0.25, pointRadius: 3, pointHoverRadius: 5 },
                  { label: '–í—Å–µ–≥–æ', data: [], borderColor: cTot, backgroundColor: cTot, tension: 0.25, pointRadius: 3, pointHoverRadius: 5 }
                ]
              },
              options: {
                maintainAspectRatio: false,
                plugins: {
                  legend: { display: false },
                  deltaLabels: { datasetIndex: 2 }, /* –¥–µ–ª—å—Ç–∞ –¥–ª—è –í—Å–µ–≥–æ */
                  tooltip: {
                    mode: 'index',
                    intersect: false,
                    itemSort: (a, b) => {
                      const av = Number(a?.raw ?? a?.parsed?.y ?? 0);
                      const bv = Number(b?.raw ?? b?.parsed?.y ?? 0);
                      return (bv - av) || ((a.datasetIndex ?? 0) - (b.datasetIndex ?? 0));
                    },
                    callbacks: {
                      title: (items) => {
                        const lbl = items?.[0]?.label;
                        return lbl ? `–†–µ–ª–∏–∑ ${lbl}` : '';
                      }
                    }
                  }
                },
                interaction: { mode: 'index', intersect: false },
                scales: {
                  x: { bounds: 'data', ticks: { maxRotation: 0, autoSkip: true }, grid: { color: 'rgba(148,163,184,.25)' } },
                  y: { beginAtZero: true, grace: '12%', grid: { color: 'rgba(148,163,184,.25)' } }
                }
              }
            });
          }

          function ensureAvgChart(){
            if(!avgCanvas || !window.Chart) return;
            if(avgChart){
              avgChart.data.labels = [];
              avgChart.data.datasets.forEach(d => d.data = []);
              avgChart.update();
              return;
            }

            const cSwat   = cssVar('--cov-swat', '#22c55e');
            const cStream = cssVar('--cov-stream', '#f43f5e');
            const cTotal  = cssVar('--tc-total', '#a855f7');

            avgChart = new Chart(avgCanvas, {
              type: 'line',
              data: {
                labels: [],
                datasets: [
                  { label: 'SWAT',   data: [], borderColor: cSwat,   backgroundColor: cSwat,   tension: 0.25, pointRadius: 3, pointHoverRadius: 5 },
                  { label: 'STREAM', data: [], borderColor: cStream, backgroundColor: cStream, tension: 0.25, pointRadius: 3, pointHoverRadius: 5 },
                  { label: '–û–±—â–µ–µ',  data: [], borderColor: cTotal,  backgroundColor: cTotal,  tension: 0.25, pointRadius: 3, pointHoverRadius: 5 }
                ]
              },
              options: {
                maintainAspectRatio: false,
                plugins: {
                  legend: { display: false },
                  tooltip: {
                    mode: 'index',
                    intersect: false,
                    itemSort: (a, b) => {
                      const av = Number(a?.raw ?? a?.parsed?.y ?? 0);
                      const bv = Number(b?.raw ?? b?.parsed?.y ?? 0);
                      return (bv - av) || ((a.datasetIndex ?? 0) - (b.datasetIndex ?? 0));
                    },
                    callbacks: {
                      title: (items) => {
                        const lbl = items?.[0]?.label;
                        return lbl ? `–†–µ–ª–∏–∑ ${lbl}` : '';
                      },
                      label: (ctx) => {
                        const minutes = Number(ctx.raw || 0);
                        const ms = minutes * 60_000;
                        return `${ctx.dataset.label}: ${formatMsPerCase(ms)}`;
                      }
                    }
                  }
                },
                interaction: { mode: 'index', intersect: false },
                scales: {
                  x: { bounds: 'data', ticks: { maxRotation: 0, autoSkip: true }, grid: { color: 'rgba(148,163,184,.25)' } },
                  y: {
                    beginAtZero: true,
                    grid: { color: 'rgba(148,163,184,.25)' },
                    ticks: { callback: (v) => (Number(v) || 0).toFixed(1) }
                  }
                }
              }
            });
          }

          function addCoveragePoint(release, swatCount, streamCount){
            if(!covChart) return;
            covChart.data.labels.push(release);
            covChart.data.datasets[0].data.push(swatCount);
            covChart.data.datasets[1].data.push(streamCount);
            covChart.update();
          }

          function addSelectivePoint(release, swatCount, streamCount){
            if(!selChart) return;
            selChart.data.labels.push(release);
            selChart.data.datasets[0].data.push(swatCount);
            selChart.data.datasets[1].data.push(streamCount);
            selChart.update();
          }

          function ensureChart(){
            if(!chartCanvas || !window.Chart) return;
            if(tcChart){
              tcChart.data.labels = [];
              tcChart.data.datasets.forEach(d => d.data = []);
              tcChart.update();
              return;
            }

            const cManual = cssVar('--tc-manual', '#f59e0b');
            const cAuto   = cssVar('--tc-auto',   '#3b82f6');
            const cTotal  = cssVar('--tc-total',  '#a855f7');

            tcChart = new Chart(chartCanvas, {
              type: 'line',
              data: {
                labels: [],
                datasets: [
                  { label: '–†—É—á–Ω—ã–µ', data: [], borderColor: cManual, backgroundColor: cManual, tension: 0.25, pointRadius: 3, pointHoverRadius: 5 },
                  { label: '–ê–≤—Ç–æ',   data: [], borderColor: cAuto,   backgroundColor: cAuto,   tension: 0.25, pointRadius: 3, pointHoverRadius: 5 },
                  { label: '–í—Å–µ–≥–æ',  data: [], borderColor: cTotal,  backgroundColor: cTotal,  tension: 0.25, pointRadius: 3, pointHoverRadius: 5 }
                ]
              },
              options: {
                maintainAspectRatio: false,
                plugins: {
                  legend: { display: false },
                  deltaLabels: { datasetIndex: 2 }, /* –¥–µ–ª—å—Ç–∞ –¥–ª—è –í—Å–µ–≥–æ */
                  tooltip: {
                    mode: 'index',
                    intersect: false,
                    itemSort: (a, b) => {
                      const av = Number(a?.raw ?? a?.parsed?.y ?? 0);
                      const bv = Number(b?.raw ?? b?.parsed?.y ?? 0);
                      return (bv - av) || ((a.datasetIndex ?? 0) - (b.datasetIndex ?? 0));
                    },
                    callbacks: {
                      title: (items) => {
                        const lbl = items?.[0]?.label;
                        return lbl ? `–†–µ–ª–∏–∑ ${lbl}` : '';
                      },
                      label: (ctx) => {
                        const i = ctx.dataIndex;
                        const total = Number(tcChart?.data?.datasets?.[2]?.data?.[i] || 0);
                        const val = Number(ctx.raw || 0);
                        let pct = 0;
                        if(ctx.datasetIndex === 2) pct = 100;
                        else if(total > 0) pct = Math.round((val / total) * 1000) / 10;
                        return `${ctx.dataset.label}: ${val} | ${pct}%`;
                      }
                    }
                  }
                },
                interaction: { mode: 'index', intersect: false },
                scales: {
                  x: { ticks: { maxRotation: 0, autoSkip: true }, grid: { color: 'rgba(148,163,184,.25)' } },
                  y: { beginAtZero: true, grace: '12%', grid: { color: 'rgba(148,163,184,.25)' } }
                }
              }
            });
          }

          function addChartPoint(release, manual, auto, total){
            if(!tcChart) return;
            tcChart.data.labels.push(release);
            tcChart.data.datasets[0].data.push(manual);
            tcChart.data.datasets[1].data.push(auto);
            tcChart.data.datasets[2].data.push(total);
            tcChart.update();
          }

          function addChpPoint(release, ios, android, total){
            if(!chpChart) return;
            chpChart.data.labels.push(release);
            chpChart.data.datasets[0].data.push(ios);
            chpChart.data.datasets[1].data.push(android);
            chpChart.data.datasets[2].data.push(total);
            chpChart.update();
          }

          function addAvgPoint(release, swatMin, streamMin, totalMin){
            if(!avgChart) return;
            avgChart.data.labels.push(release);
            avgChart.data.datasets[0].data.push(swatMin);
            avgChart.data.datasets[1].data.push(streamMin);
            avgChart.data.datasets[2].data.push(totalMin);
            avgChart.update();
          }

          function renderRow({release, manual, auto, total}){
            const max = Math.max(total, 1);
            const pctM = Math.round((manual / max) * 100);
            const pctA = Math.round((auto / max) * 100);
            const pctT = 100;

            const tr = document.createElement('tr');
            tr.innerHTML = `
              <td class="mono text-left">${release}</td>
              <td class="mono">${manual}</td>
              <td class="mono">${auto}</td>
              <td class="mono">${total}</td>
              <td class="text-left">
                <div class="space-y-2 min-w-[260px]">
                  <div class="flex items-center gap-2">
                    <span class="text-xs text-slate-500 w-14">–†—É—á–Ω—ã–µ</span>
                    <div class="bar flex-1"><div class="bar-fill bar-fill-manual" style="width:${pctM}%"></div></div>
                    <span class="mono text-xs w-10 text-right">${manual}</span>
                  </div>
                  <div class="flex items-center gap-2">
                    <span class="text-xs text-slate-500 w-14">–ê–≤—Ç–æ</span>
                    <div class="bar flex-1"><div class="bar-fill bar-fill-auto" style="width:${pctA}%"></div></div>
                    <span class="mono text-xs w-10 text-right">${auto}</span>
                  </div>
                  <div class="flex items-center gap-2">
                    <span class="text-xs text-slate-500 w-14">–í—Å–µ–≥–æ</span>
                    <div class="bar flex-1"><div class="bar-fill bar-fill-total" style="width:${pctT}%"></div></div>
                    <span class="mono text-xs w-10 text-right">${total}</span>
                  </div>
                </div>
              </td>
            `;
            tbody.appendChild(tr);
          }

          function renderCovRow({release, swatCount, streamCount}){
            const sum = (Number(swatCount) || 0) + (Number(streamCount) || 0);
            const swPct = sum ? (Math.round(((Number(swatCount)||0) / sum) * 1000) / 10) : 0;
            const stPct = sum ? (Math.round(((Number(streamCount)||0) / sum) * 1000) / 10) : 0;
            const tr2 = document.createElement('tr');
            tr2.innerHTML = `
              <td class="mono text-left">${release}</td>
              <td class="mono">${swatCount}</td>
              <td class="mono">${streamCount}</td>
              <td class="mono">${sum}</td>
              <td class="text-left"><span class="mono">SWAT ${swPct}%</span> ¬∑ <span class="mono">STREAM ${stPct}%</span></td>
            `;
            covTbody.appendChild(tr2);
          }

          function renderSelRow({release, swatCount, streamCount}){
            const sum = (Number(swatCount) || 0) + (Number(streamCount) || 0);
            const swPct = sum ? (Math.round(((Number(swatCount)||0) / sum) * 1000) / 10) : 0;
            const stPct = sum ? (Math.round(((Number(streamCount)||0) / sum) * 1000) / 10) : 0;
            const tr2 = document.createElement('tr');
            tr2.innerHTML = `
              <td class="mono text-left">${release}</td>
              <td class="mono">${swatCount}</td>
              <td class="mono">${streamCount}</td>
              <td class="mono">${sum}</td>
              <td class="text-left"><span class="mono">SWAT ${swPct}%</span> ¬∑ <span class="mono">STREAM ${stPct}%</span></td>
            `;
            selTbody.appendChild(tr2);
          }

          function renderAvgRow({release, swatMs, streamMs, totalMs}){
            const tr = document.createElement('tr');
            tr.innerHTML = `
              <td class="mono text-left">${release}</td>
              <td class="mono">${formatMsPerCase(swatMs)}</td>
              <td class="mono">${formatMsPerCase(streamMs)}</td>
              <td class="mono">${formatMsPerCase(totalMs)}</td>
            `;
            avgTbody.appendChild(tr);
          }

          async function asyncPool(items, concurrency, iterator, signal){
            const results = [];
            let i = 0;
            const workers = Array.from({length: Math.max(1, concurrency)}, async () => {
              while(i < items.length){
                if(signal?.aborted) return;
                const idx = i++;
                results[idx] = await iterator(items[idx], idx);
              }
            });
            await Promise.all(workers);
            return results;
          }

          async function run(){
            validateAndNormalizeReleaseInput(inpFrom);
            validateAndNormalizeReleaseInput(inpTo);
            saveInputs();
            clear();

            const tok = (inpAllureToken?.value || '').trim();
            if(!tok){
              showEmpty('–í—Å—Ç–∞–≤—å—Ç–µ API —Ç–æ–∫–µ–Ω Allure');
              return;
            }

            const releases = buildMajorRange();
            if(!releases.length){
              showEmpty('–£–∫–∞–∂–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –¥–∏–∞–ø–∞–∑–æ–Ω (–Ω–∞–ø—Ä–∏–º–µ—Ä 7.4.1000 ‚Üí 7.4.4000 –∏–ª–∏ 7.3.7 ‚Üí 7.4.2)');
              return;
            }

            ensureChart();
            ensureCoverageChart();
            ensureSelectiveChart();
            ensureChpChart();
            ensureAvgChart();

            showContent();
            showCovContent();
            showSelContent();
            showChpContent();
            showAvgContent();

            const signal = window.__wbAbortController?.signal;

            let swatSet;
            try{
              swatSet = await fetchSwatLogins(null, signal);
            }catch(e){
              showEmpty(`–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å–ø–∏—Å–∫–∞ SWAT: ${e?.message || e}`);
              return;
            }

            tbody.innerHTML = '<tr><td class="mono text-left" colspan="5">–°–±–æ—Ä –¥–∞–Ω–Ω—ã—Ö‚Ä¶</td></tr>';

            const LAUNCH_CONCURRENCY = 10;

            const tcRowsData = [];
            const covRowsData = [];
            const selRowsData = [];
            const avgRowsData = [];
            const avgGrand = { swatDur: 0, swatCnt: 0, streamDur: 0, streamCnt: 0, totalDur: 0, totalCnt: 0 };

            let firstRow = true;
            for(const rel of releases){
              if(signal?.aborted) break;

              let total = 0;
              let manual = 0;
              let auto  = 0;

              let swatCount = 0;
              let streamCount = 0;

              // 1) –î–ª—è –ø–µ—Ä–≤–æ–π –¥–∏–∞–≥—Ä–∞–º–º—ã (Manual/Auto/Total) –±–µ—Ä—ë–º –≤—Å–µ —Ä–∞–Ω—ã (Smoke/Selective)
              const launchMapAll = new Map();
              for(const kind of KINDS){
                const launches = await fetchLaunches(rel, kind, signal);
                for(const l of launches){
                  const id = Number(l?.id);
                  if(Number.isFinite(id)) launchMapAll.set(id, id);
                }
              }
              const idsAll = Array.from(launchMapAll.keys());

              // AVG TIME (SWAT/STREAM/Total): memberstats(count+duration); –µ—Å–ª–∏ duration –Ω–µ—Ç ‚Äî —Ä–∞—Å–∫–ª–∞–¥—ã–≤–∞–µ–º launch.duration –ø—Ä–æ–ø–æ—Ä—Ü–∏–æ–Ω–∞–ª—å–Ω–æ count
              let avgSwatCnt = 0, avgStreamCnt = 0;
              let avgSwatDur = 0, avgStreamDur = 0;

              const perAvg = await asyncPool(idsAll, LAUNCH_CONCURRENCY, async (id) => {
                const ms = await fetchMemberStats(id, signal);
                const agg = swatStreamAgg(ms, swatSet);

                if((agg.swatDur + agg.streamDur) <= 0){
                  const launchDur = await fetchLaunchDurationMs(id, signal);
                  const totalCnt = Math.max(1, (agg.swatTotal + agg.streamTotal));
                  const swShare = (agg.swatTotal || 0) / totalCnt;
                  const stShare = (agg.streamTotal || 0) / totalCnt;
                  agg.swatDur = launchDur * swShare;
                  agg.streamDur = launchDur * stShare;
                  agg.swatExec = agg.swatTotal;
                  agg.streamExec = agg.streamTotal;
                }

                return agg;
              }, signal);

              for(const r of perAvg){
                if(!r) continue;
                avgSwatCnt += Number((r.swatExec ?? r.swatTotal) || 0);
                avgStreamCnt += Number((r.streamExec ?? r.streamTotal) || 0);
                avgSwatDur += Number(r.swatDur || 0);
                avgStreamDur += Number(r.streamDur || 0);
              }

              const avgTotalCnt = avgSwatCnt + avgStreamCnt;
              const avgTotalDur = avgSwatDur + avgStreamDur;

              const swatMsPerCase = avgSwatCnt ? (avgSwatDur / avgSwatCnt) : 0;
              const streamMsPerCase = avgStreamCnt ? (avgStreamDur / avgStreamCnt) : 0;
              const totalMsPerCase = avgTotalCnt ? (avgTotalDur / avgTotalCnt) : 0;

              addAvgPoint(rel, swatMsPerCase/60000, streamMsPerCase/60000, totalMsPerCase/60000);

              if(avgTbody){
                renderAvgRow({ release: rel, swatMs: swatMsPerCase, streamMs: streamMsPerCase, totalMs: totalMsPerCase });
              }

              avgRowsData.push({ release: rel, swatMs: swatMsPerCase, streamMs: streamMsPerCase, totalMs: totalMsPerCase, total: totalMsPerCase });
              avgGrand.swatDur += avgSwatDur; avgGrand.swatCnt += avgSwatCnt;
              avgGrand.streamDur += avgStreamDur; avgGrand.streamCnt += avgStreamCnt;
              avgGrand.totalDur += avgTotalDur; avgGrand.totalCnt += avgTotalCnt;

              // 2) –î–ª—è –≤—Ç–æ—Ä–æ–π –¥–∏–∞–≥—Ä–∞–º–º—ã (SWAT/STREAM) –±–µ—Ä—ë–º —Ç–æ–ª—å–∫–æ High/Blocker —Ä–∞–Ω—ã –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é
              const hbLaunches = await fetchHBLaunches(rel, signal);
              const idsHB = hbLaunches.map(l => Number(l?.id)).filter(id => Number.isFinite(id));

              // 1) TOTAL/AUTO
              const perLaunchAll = await asyncPool(idsAll, LAUNCH_CONCURRENCY, async (id) => {
                const [t, a] = await Promise.all([
                  fetchTotalCases(id, signal),
                  fetchAutomatedTotalCases(id, signal)
                ]);
                return { t: Number(t||0), a: Number(a||0) };
              }, signal);

              for(const r of perLaunchAll){
                if(!r) continue;
                total += r.t;
                auto  += r.a;
              }
              manual = Math.max(0, total - auto);

              // 2) SWAT/STREAM –•–ë —á–µ—Ä–µ–∑ memberstats
              const perHB = await asyncPool(idsHB, LAUNCH_CONCURRENCY, async (id) => {
                const ms = await fetchMemberStats(id, signal);
                return swatStreamAgg(ms, swatSet);
              }, signal);

              for(const r of perHB){
                if(!r) continue;
                swatCount += Number(r.swatTotal || 0);
                streamCount += Number(r.streamTotal || 0);
              }

              // 3) SWAT/STREAM Selective —á–µ—Ä–µ–∑ memberstats (—Ç–æ–ª—å–∫–æ Selective)
              const selLaunches = await fetchLaunches(rel, 'Selective', signal);
              const selIds = selLaunches.map(l => Number(l?.id)).filter(id => Number.isFinite(id));
              let selSwat = 0;
              let selStream = 0;
              const perSel = await asyncPool(selIds, LAUNCH_CONCURRENCY, async (id) => {
                const ms = await fetchMemberStats(id, signal);
                return swatStreamAgg(ms, swatSet);
              }, signal);
              for(const r of perSel){
                if(!r) continue;
                selSwat += Number(r.swatTotal || 0);
                selStream += Number(r.streamTotal || 0);
              }

              // –ß–µ—Ä–µ–ø–∏–∫–∏ (deploy-lab) ‚Äî —á–µ—Ä–µ–∑ –ø—Ä–æ–∫—Å–∏
              let chpIos = 0;
              let chpAndroid = 0;
              try{
                [chpIos, chpAndroid] = await Promise.all([
                  fetchDeployIssueCount('IOS', rel, signal),
                  fetchDeployIssueCount('ANDROID', rel, signal)
                ]);
              }catch(e){
                // ok: –æ—Å—Ç–∞–≤–ª—è–µ–º 0
              }
              const chpTotal = (Number(chpIos)||0) + (Number(chpAndroid)||0);
              if(chpTbody){
                const tr = document.createElement('tr');
                tr.innerHTML = `
                  <td class="mono text-left">${rel}</td>
                  <td class="mono">${chpIos}</td>
                  <td class="mono">${chpAndroid}</td>
                  <td class="mono">${chpTotal}</td>
                `;
                chpTbody.appendChild(tr);
              }
              addChpPoint(rel, chpIos, chpAndroid, chpTotal);

              if(firstRow){
                tbody.innerHTML = '';
                firstRow = false;
              }
              renderRow({ release: rel, manual, auto, total });
              addChartPoint(rel, manual, auto, total);
              tcRowsData.push({ release: rel, manual, auto, total });

              if(covTbody){
                renderCovRow({ release: rel, swatCount, streamCount });
              }
              covRowsData.push({ release: rel, swatCount, streamCount, total: (swatCount + streamCount) });
              addCoveragePoint(rel, swatCount, streamCount);

              if(selTbody){
                renderSelRow({ release: rel, swatCount: selSwat, streamCount: selStream });
              }
              selRowsData.push({ release: rel, swatCount: selSwat, streamCount: selStream, total: (selSwat + selStream) });
              addSelectivePoint(rel, selSwat, selStream);
            }

            // –¢–∞–±–ª–∏—Ü—ã (—Å–∫—Ä—ã—Ç—ã–µ) —Å–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ —É–±—ã–≤–∞–Ω–∏—é "–∏—Ç–æ–≥–∞"
            if(tbody && tcRowsData.length){
              tbody.innerHTML = '';
              tcRowsData.sort((a,b) => (Number(b.total)||0) - (Number(a.total)||0));
              tcRowsData.forEach(renderRow);
            }

            if(covTbody && covRowsData.length){
              covTbody.innerHTML = '';
              covRowsData.sort((a,b) => (Number(b.total)||0) - (Number(a.total)||0));
              covRowsData.forEach(r => renderCovRow({ release: r.release, swatCount: r.swatCount, streamCount: r.streamCount }));
            }

            if(selTbody && selRowsData.length){
              selTbody.innerHTML = '';
              selRowsData.sort((a,b) => (Number(b.total)||0) - (Number(a.total)||0));
              selRowsData.forEach(r => renderSelRow({ release: r.release, swatCount: r.swatCount, streamCount: r.streamCount }));
            }

            if(avgTbody && avgRowsData.length){
              avgTbody.innerHTML = '';
              avgRowsData.sort((a,b) => (Number(b.total)||0) - (Number(a.total)||0));
              avgRowsData.forEach(r => renderAvgRow({ release: r.release, swatMs: r.swatMs, streamMs: r.streamMs, totalMs: r.totalMs }));

              // –ò—Ç–æ–≥–æ–≤–∞—è —Å—Ç—Ä–æ–∫–∞ (—Å–∫—Ä—ã—Ç–∞, –Ω–æ –ø—Ä–∏–≥–æ–¥–∏—Ç—Å—è)
              const swMs = avgGrand.swatCnt ? (avgGrand.swatDur / avgGrand.swatCnt) : 0;
              const stMs = avgGrand.streamCnt ? (avgGrand.streamDur / avgGrand.streamCnt) : 0;
              const ttMs = avgGrand.totalCnt ? (avgGrand.totalDur / avgGrand.totalCnt) : 0;
              const tr = document.createElement('tr');
              tr.innerHTML = `
                <td class="mono text-left font-semibold">–ò—Ç–æ–≥–æ</td>
                <td class="mono font-semibold">${formatMsPerCase(swMs)}</td>
                <td class="mono font-semibold">${formatMsPerCase(stMs)}</td>
                <td class="mono font-semibold">${formatMsPerCase(ttMs)}</td>
              `;
              avgTbody.appendChild(tr);
            }

            if(!tcRowsData.length){
              showEmpty('–î–∞–Ω–Ω—ã–µ –ø–æ—è–≤—è—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–∑ –∏—Å—Ç–æ—á–Ω–∏–∫–∞');
            }
            if(!selRowsData.length){
              showSelEmpty('–î–∞–Ω–Ω—ã–µ –ø–æ—è–≤—è—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–∑ –∏—Å—Ç–æ—á–Ω–∏–∫–∞');
            }
            if(chpTbody && !chpTbody.children.length){
              showChpEmpty('–î–∞–Ω–Ω—ã–µ –ø–æ—è–≤—è—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–∑ –∏—Å—Ç–æ—á–Ω–∏–∫–∞');
            }
            if(avgTbody && !avgTbody.children.length){
              showAvgEmpty('–î–∞–Ω–Ω—ã–µ –ø–æ—è–≤—è—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–∑ –∏—Å—Ç–æ—á–Ω–∏–∫–∞');
            }
          }

          function initCollapsers(){
            let state = {};
            try{ state = JSON.parse(localStorage.getItem(LS_COLLAPSE_KEY) || '{}') || {}; }catch(e){ state = {}; }

            function save(){
              try{ localStorage.setItem(LS_COLLAPSE_KEY, JSON.stringify(state)); }catch(e){}
            }

            function animateBody(body, collapse){
              const dur = 180;
              body.style.overflow = 'hidden';
              body.style.transition = `height ${dur}ms ease, opacity ${dur}ms ease`;

              if(collapse){
                body.style.display = '';
                const h = body.getBoundingClientRect().height;
                body.style.height = h + 'px';
                body.style.opacity = '1';
                requestAnimationFrame(() => {
                  body.style.height = '0px';
                  body.style.opacity = '0';
                });
                const onEnd = (ev) => {
                  if(ev.propertyName !== 'height') return;
                  body.removeEventListener('transitionend', onEnd);
                  body.style.display = 'none';
                  body.style.height = '';
                  body.style.opacity = '';
                  body.style.overflow = '';
                  body.style.transition = '';
                };
                body.addEventListener('transitionend', onEnd);
              }else{
                body.style.display = '';
                const h = body.scrollHeight;
                body.style.height = '0px';
                body.style.opacity = '0';
                requestAnimationFrame(() => {
                  body.style.height = h + 'px';
                  body.style.opacity = '1';
                });
                const onEnd = (ev) => {
                  if(ev.propertyName !== 'height') return;
                  body.removeEventListener('transitionend', onEnd);
                  body.style.height = '';
                  body.style.opacity = '';
                  body.style.overflow = '';
                  body.style.transition = '';
                };
                body.addEventListener('transitionend', onEnd);
              }
            }

            function resizeChartsForKey(key){
              try{
                if(key === 'tc') tcChart?.resize();
                if(key === 'cov') covChart?.resize();
                if(key === 'sel') selChart?.resize();
                if(key === 'chp') chpChart?.resize();
                if(key === 'avg') avgChart?.resize();
              }catch(e){}
            }

            const btns = document.querySelectorAll('[data-collapse-btn]');
            btns.forEach(btn => {
              const key = btn.getAttribute('data-collapse-btn');
              const section = btn.closest('section');
              if(!section) return;
              const body = section.querySelector(`[data-collapse-body="${key}"]`);
              if(!body) return;

              const ico = btn.querySelector('[data-collapse-ico]');
              const txt = btn.querySelector('[data-collapse-text]');

              let collapsed = !!state[key];

              const applyInstant = () => {
                body.style.display = collapsed ? 'none' : '';
                btn.setAttribute('aria-expanded', collapsed ? 'false' : 'true');
                if(ico) ico.textContent = collapsed ? '‚ñ∏' : '‚ñæ';
                if(txt) txt.textContent = collapsed ? '–†–∞–∑–≤–µ—Ä–Ω—É—Ç—å' : '–°–≤–µ—Ä–Ω—É—Ç—å';
              };

              applyInstant();

              btn.addEventListener('click', () => {
                collapsed = !collapsed;
                state[key] = collapsed;
                save();

                btn.setAttribute('aria-expanded', collapsed ? 'false' : 'true');
                if(ico) ico.textContent = collapsed ? '‚ñ∏' : '‚ñæ';
                if(txt) txt.textContent = collapsed ? '–†–∞–∑–≤–µ—Ä–Ω—É—Ç—å' : '–°–≤–µ—Ä–Ω—É—Ç—å';

                animateBody(body, collapsed);
                if(!collapsed){
                  requestAnimationFrame(() => requestAnimationFrame(() => resizeChartsForKey(key)));
                }
              });
            });
          }

          // init: restore inputs
          restoreInputs();
          attachReleaseMask();
          validateAndNormalizeReleaseInput(inpFrom);
          validateAndNormalizeReleaseInput(inpTo);
          showEmpty('–î–∞–Ω–Ω—ã–µ –ø–æ—è–≤—è—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–∑ –∏—Å—Ç–æ—á–Ω–∏–∫–∞');
          initCollapsers();

          proxyBtn?.addEventListener('click', async () => {
            try{
              const r = await fetch(PROXY_BASE + '/health', { cache: 'no-store' });
              const j = await r.json();
              const ok = !!(j && j.ok === true && Number(j.port) === 8787);
              showToast(ok ? `–ü—Ä–æ–∫—Å–∏ OK (–ø–æ—Ä—Ç ${j.port})` : '–ü—Ä–æ–∫—Å–∏ –Ω–µ –æ—Ç–≤–µ—á–∞–µ—Ç', ok);
            }catch(e){
              showToast('–ü—Ä–æ–∫—Å–∏ –Ω–µ –æ—Ç–≤–µ—á–∞–µ—Ç', false);
            }
          });

          startBtn?.addEventListener('click', async () => {
            try{
              setRunning(true);
              await run();
            }catch(e){
              if(!(window.__wbAbortController?.signal?.aborted)){
                console.error(e);
                showEmpty(`–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö: ${e?.message || e}`);
              }
            }finally{
              if(!window.__wbAbortController?.signal?.aborted){
                setRunning(false);
              }
            }
          });

          stopBtn?.addEventListener('click', () => {
            setRunning(false);
          });
        })();
      </script>
    </main>
  </div>

  <div id="toast" class="pointer-events-none fixed bottom-6 left-1/2 -translate-x-1/2 opacity-0 transition-opacity duration-200">
    <div id="toastInner" class="px-4 py-2 rounded-2xl text-sm font-semibold bg-white/90 ring-1 ring-[#ecebff] text-slate-700 shadow"></div>
  </div>
</body>
</html>
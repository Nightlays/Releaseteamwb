<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>WB All Table ‚Äî –≥—Ä–∞—Ñ–∏–∫–∏</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Tailwind –∫–∞–∫ –≤ uwu_6 (–¥–ª—è —É–¥–æ–±–Ω—ã—Ö —É—Ç–∏–ª–∏—Ç) -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

  <!-- –í—Å–µ –∫–∞—Å—Ç–æ–º–Ω—ã–µ —Å—Ç–∏–ª–∏ –≤—ã–Ω–µ—Å–µ–Ω—ã –≤ style.css -->
  <link rel="stylesheet" href="./style.css" />
</head>
<body class="min-h-screen">
   <div class="max-w-screen-2xl mx-auto px-4 py-6">
    <header class="flex items-center justify-between gap-3 flex-wrap">
      <div class="brand-badge">
        <span class="brand-dot"></span>
        <div>
          <div class="flex items-center gap-2">
            <div class="font-extrabold leading-tight">WB All Table</div>
            <span id="appVersion" class="inline-flex items-center gap-1 text-[11px] font-semibold px-2 py-0.5 rounded-full bg-white/70 ring-1 ring-[#ecebff] text-slate-600">
              <span aria-hidden="true">üè∑Ô∏è</span><span>v0.2.15</span>
            </span>
            <button id="exportPdfBtn"
              class="inline-flex items-center gap-2 text-sm font-semibold px-3 py-1.5 rounded-2xl bg-white/70 ring-1 ring-[#ecebff] text-slate-700 hover:bg-white">
              üìÑ –≠–∫—Å–ø–æ—Ä—Ç PDF
            </button>
          </div>
        </div>
      </div>
    </header>

    <main class="mt-5 grid grid-cols-1 gap-4">
      <!-- –ë–ª–æ–∫ –≤–≤–æ–¥–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ (–æ—Ç–¥–µ–ª—å–Ω–æ –æ—Ç —Ç–∞–±–ª–∏—Ü/–≥—Ä–∞—Ñ–∏–∫–æ–≤) -->
      <section class="card p-5 space-y-3">
        <div>
          <h2 class="text-lg font-semibold">–ü–∞—Ä–∞–º–µ—Ç—Ä—ã –∑–∞–ø—É—Å–∫–∞</h2>
          <div class="hint">–ó–∞–ø–æ–ª–Ω–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∏ –Ω–∞–∂–º–∏ ¬´–ó–∞–ø—É—Å—Ç–∏—Ç—å —Å–±–æ—Ä¬ª.</div>
        </div>

        <form class="w-full" onsubmit="return false;">
          <div class="border border-[#ecebff] rounded-2xl bg-white p-4">
            <div class="grid grid-cols-1 md:grid-cols-12 gap-3 items-end">
              <div class="md:col-span-4">
                <label class="block text-xs font-semibold text-[#111827] mb-1">–í–µ—Ä—Å–∏—è —Ä–µ–ª–∏–∑–∞</label>
                <div class="grid grid-cols-1 sm:grid-cols-2 gap-2">
                  <input class="input" id="releaseFrom" type="text" inputmode="numeric" placeholder="–û—Ç, –Ω–∞–ø—Ä. 7.3.5000" />
                  <input class="input" id="releaseTo" type="text" inputmode="numeric" placeholder="–î–æ, –Ω–∞–ø—Ä. 7.3.8000" />
                </div>
              </div>

              <div class="md:col-span-6">
                <label class="block text-xs font-semibold text-[#111827] mb-1">API —Ç–æ–∫–µ–Ω Allure</label>
                <input class="input" id="allureToken" type="password" autocomplete="off" placeholder="–í—Å—Ç–∞–≤—å—Ç–µ —Ç–æ–∫–µ–Ω Allure" />
              </div>

              <div class="md:col-span-2">
                <button id="startBtn" type="button" class="btn btn-grad w-full">–ó–∞–ø—É—Å—Ç–∏—Ç—å —Å–±–æ—Ä</button>
                <button id="stopBtn" type="button" class="btn btn-danger w-full" style="display:none;">–û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Å–±–æ—Ä</button>
                <button id="proxyBtn" type="button" class="mt-2 w-full inline-flex items-center justify-center gap-2 text-sm font-semibold px-3 py-2 rounded-2xl bg-white/70 ring-1 ring-[#ecebff] text-slate-700 hover:bg-white">
                  –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –ø—Ä–æ–∫—Å–∏
                </button>
              </div>

              <div class="md:col-span-4">
                <label class="block text-xs font-semibold text-[#111827] mb-1">Deploy-lab token</label>
                <input class="input" id="deployToken" type="password" autocomplete="off" placeholder="–í—Å—Ç–∞–≤—å—Ç–µ Deploy-lab token" />
              </div>
            </div>

          </div>
        </form>
      </section>

      <!-- 1) –¢–µ—Å—Ç –∫–µ–π—Å—ã -->
      <section class="card p-5 space-y-4">
        <div class="flex items-start justify-between gap-4 flex-wrap">
          <div>
            <h2 class="text-lg font-semibold">–¢–µ—Å—Ç –∫–µ–π—Å—ã –æ—Ç —Ä–µ–ª–∏–∑–∞ –∫ —Ä–µ–ª–∏–∑—É</h2>
          </div>
          <div class="flex items-center gap-2">
            <button type="button"
              class="inline-flex items-center gap-1.5 text-xs font-semibold px-2.5 py-1 rounded-xl bg-white/70 ring-1 ring-[#ecebff] text-slate-600 hover:bg-white"
              data-toggle="tcChart" aria-expanded="true">
              <span aria-hidden="true">‚ñæ</span>
              <span>–ì—Ä–∞—Ñ–∏–∫</span>
            </button>
            <button type="button"
              class="inline-flex items-center gap-1.5 text-xs font-semibold px-2.5 py-1 rounded-xl bg-white/70 ring-1 ring-[#ecebff] text-slate-600 hover:bg-white"
              data-collapse-btn="tc" aria-expanded="true">
              <span data-collapse-ico aria-hidden="true">‚ñæ</span>
              <span data-collapse-text>–°–≤–µ—Ä–Ω—É—Ç—å</span>
            </button>
          </div>
        </div>

        <div data-collapse-body="tc" class="space-y-4">
          <div class="overflow-auto border border-[#ecebff] rounded-2xl">
            <div id="tcEmpty" class="p-6 text-center text-sm text-slate-500 bg-white flex items-center justify-center" style="min-height:520px" aria-live="polite">
              –î–∞–Ω–Ω—ã–µ –ø–æ—è–≤—è—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–∑ –∏—Å—Ç–æ—á–Ω–∏–∫–∞
            </div>

            <div id="tcContent" class="tc-content" style="display:none;">
              <div class="chart-viewport" id="tcTrendViewport" data-toggle-body="tcChart">
                <canvas id="tcTrendChart" aria-label="Test cases chart" role="img"></canvas>
              </div>

              <div id="tcStreamDeltaWrap" class="px-4 pb-4 pt-2" style="overflow:auto">
                <div class="flex items-center justify-between gap-2 mb-2 flex-wrap">
                  <div class="text-xs font-semibold text-slate-600">–ü—Ä–∏—Ä–æ—Å—Ç/–æ—Ç—Ç–æ–∫ –ø–æ —Å—Ç—Ä–∏–º–∞–º (Manual/AT)</div>
                  <div class="flex items-center gap-2 flex-wrap">
                    <label class="text-xs text-slate-500" style="white-space:nowrap;">–†–µ–ª–∏–∑</label>
                    <select id="tcReleaseFilter" class="input text-xs" multiple size="1" style="min-width:200px;width:auto;flex:0 0 auto;"></select>
                    <button type="button"
                      class="inline-flex items-center gap-1.5 text-xs font-semibold px-2.5 py-1 rounded-xl bg-white/70 ring-1 ring-[#ecebff] text-slate-600 hover:bg-white"
                      data-collapse-btn="tcStreamDelta" aria-expanded="true">
                      <span data-collapse-ico aria-hidden="true">‚ñæ</span>
                      <span data-collapse-text>–°–≤–µ—Ä–Ω—É—Ç—å</span>
                    </button>
                  </div>
                </div>
                <table id="tcStreamDeltaTable" data-collapse-body="tcStreamDelta">
                  <thead>
                    <tr>
                      <th class="text-left">–†–µ–ª–∏–∑</th>
                      <th class="text-left">Stream</th>
                      <th>Manual Œî</th>
                      <th>AT Œî</th>
                    </tr>
                  </thead>
                  <tbody id="tcStreamDeltaTbody"></tbody>
                </table>
              </div>

              <div id="tcTableWrap" style="display:none; overflow:auto">
                <div class="flex items-center gap-2 flex-wrap px-4 pt-2">
                  <label class="text-xs text-slate-500" style="white-space:nowrap;">–†–µ–ª–∏–∑</label>
                  <select id="tcTableReleaseFilter" class="input text-xs" multiple size="1" style="min-width:200px;width:auto;flex:0 0 auto;"></select>
                </div>
                <table id="tcTable">
                  <thead>
                    <tr>
                      <th class="text-left">–†–µ–ª–∏–∑</th>
                      <th>–†—É—á–Ω—ã–µ</th>
                      <th>–ê–≤—Ç–æ</th>
                      <th>–í—Å–µ–≥–æ</th>
                      <th class="text-left">–ü–æ–ª–æ—Å—ã</th>
                    </tr>
                  </thead>
                  <tbody id="tcTbody"></tbody>
                </table>
              </div>
            </div>
          </div>

          <div class="flex flex-wrap items-center justify-start gap-3">
            <div class="legend">
              <span class="lg-item"><span class="dot dot-manual"></span>–†—É—á–Ω—ã–µ</span>
              <span class="lg-item"><span class="dot dot-auto"></span>–ê–≤—Ç–æ</span>
              <span class="lg-item"><span class="dot dot-total"></span>–í—Å–µ–≥–æ</span>
            </div>
          </div>
        </div>
      </section>

      <!-- 2) SWAT/STREAM –•–ë -->
      <section class="card p-5 space-y-4">
        <div class="flex items-start justify-between gap-4 flex-wrap">
          <div>
            <h2 class="text-lg font-semibold">–ü–æ–∫—Ä—ã—Ç–∏–µ SWAT –∏ STREAM –•–ë</h2>
          </div>
          <button type="button"
            class="inline-flex items-center gap-1.5 text-xs font-semibold px-2.5 py-1 rounded-xl bg-white/70 ring-1 ring-[#ecebff] text-slate-600 hover:bg-white"
            data-collapse-btn="cov" aria-expanded="true">
            <span data-collapse-ico aria-hidden="true">‚ñæ</span>
            <span data-collapse-text>–°–≤–µ—Ä–Ω—É—Ç—å</span>
          </button>
        </div>

        <div data-collapse-body="cov" class="space-y-4">
          <div class="overflow-auto border border-[#ecebff] rounded-2xl">
            <div id="covEmpty" class="p-6 text-center text-sm text-slate-500 bg-white flex items-center justify-center" style="min-height:520px" aria-live="polite">
              –î–∞–Ω–Ω—ã–µ –ø–æ—è–≤—è—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–∑ –∏—Å—Ç–æ—á–Ω–∏–∫–∞
            </div>

            <div id="covContent" class="tc-content" style="display:none;">
              <div class="chart-viewport" id="covTrendViewport">
                <canvas id="covTrendChart" aria-label="SWAT/STREAM coverage chart" role="img"></canvas>
              </div>

              <div id="covTableWrap" style="display:none; overflow:auto">
                <div class="flex items-center gap-2 flex-wrap px-4 pt-2">
                  <label class="text-xs text-slate-500" style="white-space:nowrap;">–†–µ–ª–∏–∑</label>
                  <select id="covReleaseFilter" class="input text-xs" multiple size="1" style="min-width:200px;width:auto;flex:0 0 auto;"></select>
                </div>
                <table id="covTable">
                  <thead>
                    <tr>
                      <th class="text-left">–ù–æ–º–µ—Ä —Ä–µ–ª–∏–∑–∞</th>
                      <th>SWAT</th>
                      <th>SWAT (—Å–æ—Ç—Ä.)</th>
                      <th>STREAM</th>
                      <th>–í—Å–µ–≥–æ</th>
                      <th class="text-left">–ü–æ–∫—Ä—ã—Ç–∏–µ</th>
                    </tr>
                  </thead>
                  <tbody id="covTbody"></tbody>
                </table>
              </div>
            </div>
          </div>

          <div class="flex flex-wrap items-center justify-start gap-3">
            <div class="legend">
              <span class="lg-item"><span class="dot dot-swat"></span>SWAT</span>
              <span class="lg-item"><span class="dot dot-stream"></span>STREAM</span>
            </div>
          </div>
        </div>
      </section>

      <!-- 3) SWAT/STREAM Selective -->
      <section class="card p-5 space-y-4">
        <div class="flex items-start justify-between gap-4 flex-wrap">
          <div>
            <h2 class="text-lg font-semibold">–ü–æ–∫—Ä—ã—Ç–∏–µ SWAT –∏ STREAM Selective</h2>
          </div>
          <button type="button"
            class="inline-flex items-center gap-1.5 text-xs font-semibold px-2.5 py-1 rounded-xl bg-white/70 ring-1 ring-[#ecebff] text-slate-600 hover:bg-white"
            data-collapse-btn="sel" aria-expanded="true">
            <span data-collapse-ico aria-hidden="true">‚ñæ</span>
            <span data-collapse-text>–°–≤–µ—Ä–Ω—É—Ç—å</span>
          </button>
        </div>

        <div data-collapse-body="sel" class="space-y-4">
          <div class="overflow-auto border border-[#ecebff] rounded-2xl">
            <div id="selEmpty" class="p-6 text-center text-sm text-slate-500 bg-white flex items-center justify-center" style="min-height:520px" aria-live="polite">
              –î–∞–Ω–Ω—ã–µ –ø–æ—è–≤—è—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–∑ –∏—Å—Ç–æ—á–Ω–∏–∫–∞
            </div>

            <div id="selContent" class="tc-content" style="display:none;">
              <div class="chart-viewport" id="selTrendViewport">
                <canvas id="selTrendChart" aria-label="SWAT/STREAM Selective chart" role="img"></canvas>
              </div>

              <div id="selTableWrap" style="display:none; overflow:auto">
                <div class="flex items-center gap-2 flex-wrap px-4 pt-2">
                  <label class="text-xs text-slate-500" style="white-space:nowrap;">–†–µ–ª–∏–∑</label>
                  <select id="selReleaseFilter" class="input text-xs" multiple size="1" style="min-width:200px;width:auto;flex:0 0 auto;"></select>
                </div>
                <table id="selTable">
                  <thead>
                    <tr>
                      <th class="text-left">–ù–æ–º–µ—Ä —Ä–µ–ª–∏–∑–∞</th>
                      <th>SWAT</th>
                      <th>SWAT (—Å–æ—Ç—Ä.)</th>
                      <th>STREAM</th>
                      <th>–í—Å–µ–≥–æ</th>
                      <th class="text-left">–ü–æ–∫—Ä—ã—Ç–∏–µ</th>
                    </tr>
                  </thead>
                  <tbody id="selTbody"></tbody>
                </table>
              </div>
            </div>
          </div>

          <div class="flex flex-wrap items-center justify-start gap-3">
            <div class="legend">
              <span class="lg-item"><span class="dot dot-swat"></span>SWAT</span>
              <span class="lg-item"><span class="dot dot-stream"></span>STREAM</span>
            </div>
          </div>
        </div>
      </section>

      <!-- 4) –°—Ä–µ–¥–Ω–µ–µ –≤—Ä–µ–º—è -->
      <section class="card p-5 space-y-4">
        <div class="flex items-start justify-between gap-4 flex-wrap">
          <div>
            <h2 class="text-lg font-semibold">–°—Ä–µ–¥–Ω–µ–µ –≤—Ä–µ–º—è –ø—Ä–æ—Ö–æ–∂–¥–µ–Ω–∏—è –∫–µ–π—Å–∞</h2>
          </div>
          <button type="button"
            class="inline-flex items-center gap-1.5 text-xs font-semibold px-2.5 py-1 rounded-xl bg-white/70 ring-1 ring-[#ecebff] text-slate-600 hover:bg-white"
            data-collapse-btn="avg" aria-expanded="true">
            <span data-collapse-ico aria-hidden="true">‚ñæ</span>
            <span data-collapse-text>–°–≤–µ—Ä–Ω—É—Ç—å</span>
          </button>
        </div>

        <div data-collapse-body="avg" class="space-y-4">
          <div class="overflow-auto border border-[#ecebff] rounded-2xl">
            <div id="avgEmpty" class="p-6 text-center text-sm text-slate-500 bg-white flex items-center justify-center" style="min-height:520px" aria-live="polite">
              –î–∞–Ω–Ω—ã–µ –ø–æ—è–≤—è—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–∑ –∏—Å—Ç–æ—á–Ω–∏–∫–∞
            </div>

            <div id="avgContent" class="tc-content" style="display:none;">
              <div class="chart-viewport" id="avgTrendViewport">
                <canvas id="avgTrendChart" aria-label="Average time chart" role="img"></canvas>
              </div>

              <div id="avgTableWrap" style="display:none; overflow:auto">
                <div class="flex items-center gap-2 flex-wrap px-4 pt-2">
                  <label class="text-xs text-slate-500" style="white-space:nowrap;">–†–µ–ª–∏–∑</label>
                  <select id="avgReleaseFilter" class="input text-xs" multiple size="1" style="min-width:200px;width:auto;flex:0 0 auto;"></select>
                </div>
                <table id="avgTable">
                  <thead>
                    <tr>
                      <th class="text-left">–ù–æ–º–µ—Ä —Ä–µ–ª–∏–∑–∞</th>
                      <th>SWAT</th>
                      <th>STREAM</th>
                      <th>–û–±—â–µ–µ</th>
                    </tr>
                  </thead>
                  <tbody id="avgTbody"></tbody>
                </table>
              </div>
            </div>
          </div>

          <div class="flex flex-wrap items-center justify-start gap-3">
            <div class="legend">
              <span class="lg-item"><span class="dot dot-swat"></span>SWAT</span>
              <span class="lg-item"><span class="dot dot-stream"></span>STREAM</span>
              <span class="lg-item"><span class="dot dot-total"></span>–û–±—â–µ–µ</span>
            </div>
          </div>
        </div>
      </section>

      <!-- 5) –ß–µ—Ä–µ–ø–∏–∫–∏ -->
      <section class="card p-5 space-y-4">
        <div class="flex items-start justify-between gap-4 flex-wrap">
          <div>
            <h2 class="text-lg font-semibold">–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —á–µ—Ä–µ–ø–∏–∫–æ–≤</h2>
          </div>
          <button type="button"
            class="inline-flex items-center gap-1.5 text-xs font-semibold px-2.5 py-1 rounded-xl bg-white/70 ring-1 ring-[#ecebff] text-slate-600 hover:bg-white"
            data-collapse-btn="chp" aria-expanded="true">
            <span data-collapse-ico aria-hidden="true">‚ñæ</span>
            <span data-collapse-text>–°–≤–µ—Ä–Ω—É—Ç—å</span>
          </button>
        </div>

        <div data-collapse-body="chp" class="space-y-4">
          <div class="overflow-auto border border-[#ecebff] rounded-2xl">
            <div id="chpEmpty" class="p-6 text-center text-sm text-slate-500 bg-white flex items-center justify-center" style="min-height:520px" aria-live="polite">
              –î–∞–Ω–Ω—ã–µ –ø–æ—è–≤—è—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–∑ –∏—Å—Ç–æ—á–Ω–∏–∫–∞
            </div>

            <div id="chpContent" class="tc-content" style="display:none;">
              <div class="chart-viewport" id="chpTrendViewport">
                <canvas id="chpTrendChart" aria-label="Cherepiki chart" role="img"></canvas>
              </div>

              <div id="chpTableWrap" style="display:none; overflow:auto">
                <div class="flex items-center gap-2 flex-wrap px-4 pt-2">
                  <label class="text-xs text-slate-500" style="white-space:nowrap;">–†–µ–ª–∏–∑</label>
                  <select id="chpReleaseFilter" class="input text-xs" multiple size="1" style="min-width:200px;width:auto;flex:0 0 auto;"></select>
                </div>
                <table id="chpTable">
                  <thead>
                    <tr>
                      <th class="text-left">–ù–æ–º–µ—Ä —Ä–µ–ª–∏–∑–∞</th>
                      <th>iOS</th>
                      <th>Android</th>
                      <th>–í—Å–µ–≥–æ</th>
                    </tr>
                  </thead>
                  <tbody id="chpTbody"></tbody>
                </table>
              </div>
            </div>
          </div>

          <div class="flex flex-wrap items-center justify-start gap-3">
            <div class="legend">
              <span class="lg-item"><span class="dot" style="background: var(--chp-ios, #0ea5e9)"></span>iOS</span>
              <span class="lg-item"><span class="dot" style="background: var(--chp-android, #22c55e)"></span>Android</span>
              <span class="lg-item"><span class="dot" style="background: var(--chp-total, #a855f7)"></span>–í—Å–µ–≥–æ</span>
            </div>
          </div>
        </div>
      </section>

      <!-- 6) –í—Ä–µ–º—è cutoff –∏ –æ—Ç–ø—Ä–∞–≤–∫–∏ –≤ store -->
      <section class="card p-5 space-y-4">
        <div class="flex items-start justify-between gap-4 flex-wrap">
          <div>
            <h2 class="text-lg font-semibold">–í—Ä–µ–º—è cutoff –∏ –æ—Ç–ø—Ä–∞–≤–∫–∏ –≤ store</h2>
          </div>
          <button type="button"
            class="inline-flex items-center gap-1.5 text-xs font-semibold px-2.5 py-1 rounded-xl bg-white/70 ring-1 ring-[#ecebff] text-slate-600 hover:bg-white"
            data-collapse-btn="cut" aria-expanded="true">
            <span data-collapse-ico aria-hidden="true">‚ñæ</span>
            <span data-collapse-text>–°–≤–µ—Ä–Ω—É—Ç—å</span>
          </button>
        </div>

        <div data-collapse-body="cut" class="space-y-4">
          <div class="overflow-auto border border-[#ecebff] rounded-2xl">
            <div id="cutEmpty" class="p-6 text-center text-sm text-slate-500 bg-white flex items-center justify-center" style="min-height:520px" aria-live="polite">
              –î–∞–Ω–Ω—ã–µ –ø–æ—è–≤—è—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–∑ –∏—Å—Ç–æ—á–Ω–∏–∫–∞
            </div>

            <div id="cutContent" class="tc-content" style="display:none;">
              <div class="chart-viewport" id="cutTrendViewport">
                <canvas id="cutTrendChart" aria-label="Cutoff & Store chart" role="img"></canvas>
              </div>

              <div id="cutTableWrap" style="display:none; overflow:auto">
                <div class="flex items-center gap-2 flex-wrap px-4 pt-2">
                  <label class="text-xs text-slate-500" style="white-space:nowrap;">–†–µ–ª–∏–∑</label>
                  <select id="cutReleaseFilter" class="input text-xs" multiple size="1" style="min-width:200px;width:auto;flex:0 0 auto;"></select>
                </div>
                <div class="cutoff-legend px-4 pt-1 text-xs text-slate-600 flex items-center gap-3 flex-wrap">
                  <span class="cutoff-item"><span class="cutoff-dot cutoff-on"></span>14:00-14:05 ‚Äî —Å—Ç–∞—Ä—Ç –≤–æ–≤—Ä–µ–º—è</span>
                  <span class="cutoff-item"><span class="cutoff-dot cutoff-late"></span>–ø–æ—Å–ª–µ 14:05 ‚Äî —Å—Ç–∞—Ä—Ç –ø–æ–∑–∂–µ</span>
                </div>
                <table id="cutTable">
                  <thead>
                    <tr>
                      <th class="text-left">–ù–æ–º–µ—Ä —Ä–µ–ª–∏–∑–∞</th>
                      <th>iOS Cutoff</th>
                      <th>iOS Store</th>
                      <th>Android Cutoff</th>
                      <th>Android Store</th>
                    </tr>
                  </thead>
                  <tbody id="cutTbody"></tbody>
                </table>
              </div>
            </div>
          </div>

          <div class="flex flex-wrap items-center justify-start gap-3">
            <div class="legend">
              <span class="lg-item"><span class="dot dot-ios-cutoff"></span>iOS Cutoff</span>
              <span class="lg-item"><span class="dot dot-ios-store"></span>iOS Store</span>
              <span class="lg-item"><span class="dot dot-android-cutoff"></span>Android Cutoff</span>
              <span class="lg-item"><span class="dot dot-android-store"></span>Android Store</span>
            </div>
          </div>
        </div>
      </section>

<!-- 7) –¢–∏–ø—ã –∑–∞–¥–∞—á —Ä–µ–ª–∏–∑–∞ iOS -->
      <section class="card p-5 space-y-4">
        <div class="flex items-start justify-between gap-4 flex-wrap">
          <div>
            <h2 class="text-lg font-semibold">–¢–∏–ø—ã –∑–∞–¥–∞—á —Ä–µ–ª–∏–∑–∞ iOS</h2>
          </div>
          <button type="button"
            class="inline-flex items-center gap-1.5 text-xs font-semibold px-2.5 py-1 rounded-xl bg-white/70 ring-1 ring-[#ecebff] text-slate-600 hover:bg-white"
            data-collapse-btn="iosTypes" aria-expanded="true">
            <span data-collapse-ico aria-hidden="true">‚ñæ</span>
            <span data-collapse-text>–°–≤–µ—Ä–Ω—É—Ç—å</span>
          </button>
        </div>

        <div data-collapse-body="iosTypes" class="space-y-3">
          <div class="overflow-auto border border-[#ecebff] rounded-2xl bg-white">
            <div id="iosTypesEmpty" class="p-6 text-slate-500" style="min-height:520px">
              –î–∞–Ω–Ω—ã–µ –ø–æ—è–≤—è—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–∑ –∏—Å—Ç–æ—á–Ω–∏–∫–∞
            </div>

            <div id="iosTypesContent" class="tc-content" style="display:none;">
              <div class="chart-viewport" id="iosTypesTrendViewport">
                <canvas id="iosTypesTrendChart" aria-label="iOS types chart" role="img"></canvas>
              </div>

              <div class="legend px-4 pb-3" id="iosTypesLegend"></div>

            <div id="iosTypesTableWrap" style="overflow:auto" class="px-4 pb-4">
              <div class="flex items-center gap-2 flex-wrap pt-2 pb-2">
                <label class="text-xs text-slate-500" style="white-space:nowrap;">–†–µ–ª–∏–∑</label>
                <select id="iosTypesReleaseFilter" class="input text-xs" multiple size="1" style="min-width:200px;width:auto;flex:0 0 auto;"></select>
              </div>
              <table id="iosTypesTable" class="types-table">
                  <thead>
                    <tr id="iosTypesTheadRow"></tr>
                  </thead>
                  <tbody id="iosTypesTbody"></tbody>
                </table>
              </div>
            </div>
          </div>
        </div>
      </section>

<!-- 8) –¢–∏–ø—ã –∑–∞–¥–∞—á —Ä–µ–ª–∏–∑–∞ Android -->
      <section class="card p-5 space-y-4">
        <div class="flex items-start justify-between gap-4 flex-wrap">
          <div>
            <h2 class="text-lg font-semibold">–¢–∏–ø—ã –∑–∞–¥–∞—á —Ä–µ–ª–∏–∑–∞ Android</h2>
          </div>
          <button type="button"
            class="inline-flex items-center gap-1.5 text-xs font-semibold px-2.5 py-1 rounded-xl bg-white/70 ring-1 ring-[#ecebff] text-slate-600 hover:bg-white"
            data-collapse-btn="andTypes" aria-expanded="true">
            <span data-collapse-ico aria-hidden="true">‚ñæ</span>
            <span data-collapse-text>–°–≤–µ—Ä–Ω—É—Ç—å</span>
          </button>
        </div>

        <div data-collapse-body="andTypes" class="space-y-3">
          <div class="overflow-auto border border-[#ecebff] rounded-2xl bg-white">
            <div id="andTypesEmpty" class="p-6 text-slate-500" style="min-height:520px">
              –î–∞–Ω–Ω—ã–µ –ø–æ—è–≤—è—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–∑ –∏—Å—Ç–æ—á–Ω–∏–∫–∞
            </div>

            <div id="andTypesContent" class="tc-content" style="display:none;">
              <div class="chart-viewport" id="andTypesTrendViewport">
                <canvas id="andTypesTrendChart" aria-label="Android types chart" role="img"></canvas>
              </div>

              <div class="legend px-4 pb-3" id="andTypesLegend"></div>

            <div id="andTypesTableWrap" style="overflow:auto" class="px-4 pb-4">
              <div class="flex items-center gap-2 flex-wrap pt-2 pb-2">
                <label class="text-xs text-slate-500" style="white-space:nowrap;">–†–µ–ª–∏–∑</label>
                <select id="andTypesReleaseFilter" class="input text-xs" multiple size="1" style="min-width:200px;width:auto;flex:0 0 auto;"></select>
              </div>
              <table id="andTypesTable" class="types-table">
                  <thead>
                    <tr id="andTypesTheadRow"></tr>
                  </thead>
                  <tbody id="andTypesTbody"></tbody>
                </table>
              </div>
            </div>
          </div>
        </div>
      </section>


      <script>
        (function(){
          const BASE_URL = 'https://allure-testops.wb.ru';
          const PROJECT_ID = 7;
          const PAGE_SIZE = 1000;
          const KINDS = ['Smoke', 'Selective'];
          const SWAT_LIST_URL = 'https://script.google.com/macros/s/AKfycbzLmb5ATmHOip7REPsl_iSLH2GuEHui0W_czyrPgW_8G1Wl-RY8CiM2UeAdqQQEwoNx-Q/exec';
          const PROXY_BASE = 'http://localhost:8787';
          const LS_COLLAPSE_KEY = 'wb_all_table_collapsed';

          const DEPLOY_BASE_URL_TMPL   = 'https://deploy-lab-api.wb.ru/releaseboss/admin_panel/release/{prefix}_{rel}';
          const DEPLOY_DEPLOY_URL_TMPL = 'https://deploy-lab-api.wb.ru/releaseboss/admin_panel/release/{prefix}_{rel}/deploy';
          const DEPLOY_ISSUES_URL_TMPL = 'https://deploy-lab-api.wb.ru/releaseboss/admin_panel/release/{prefix}_{rel}/issues';

          const LS_TOKEN_KEY = 'swat_uwu_token';
          const LS_RANGE_KEY = 'swat_uwu_release_range';
          const LS_DEPLOY_KEY = 'wb_all_table_deploy_token';

          const startBtn = document.getElementById('startBtn');
          const stopBtn  = document.getElementById('stopBtn');
          const proxyBtn = document.getElementById('proxyBtn');

          const inpFrom  = document.getElementById('releaseFrom');
          const inpTo    = document.getElementById('releaseTo');
          const inpAllureToken = document.getElementById('allureToken');
          const inpDeployToken = document.getElementById('deployToken');

          document.getElementById('exportPdfBtn')
            ?.addEventListener('click', exportAllChartsToPDF);
        // –≠–∫—Å–ø–æ—Ä—Ç –≤—Å–µ–π –∫–∞—Ä—Ç–æ—á–∫–∏ –≥—Ä–∞—Ñ–∏–∫–∞ —Ü–µ–ª–∏–∫–æ–º (–∑–∞–≥–æ–ª–æ–≤–æ–∫ + —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–∞ + –≥—Ä–∞—Ñ–∏–∫) –≤ PDF
        async function exportAllChartsToPDF(){
          if (!window.jspdf || !window.html2canvas) return;

          const { jsPDF } = window.jspdf;
          const pdf = new jsPDF('p', 'mm', 'a4');

          const pageW = pdf.internal.pageSize.getWidth();
          const pageH = pdf.internal.pageSize.getHeight();
          const margin = 10;
          let y = margin;

          // –ë–µ—Ä—ë–º –∏–º–µ–Ω–Ω–æ –∫–∞—Ä—Ç–æ—á–∫–∏ –≥—Ä–∞—Ñ–∏–∫–æ–≤ —Ü–µ–ª–∏–∫–æ–º
          const cards = Array.from(document.querySelectorAll('section.card'))
            .filter(card => card.querySelector('canvas'));

          for (const card of cards) {
            const scale = 2;
            const scrollables = Array.from(card.querySelectorAll('[style*="overflow:auto"], [style*="overflow: auto"], .overflow-auto'));
            const restore = [];
            for(const el of scrollables){
              restore.push({
                el,
                overflow: el.style.overflow,
                overflowX: el.style.overflowX,
                overflowY: el.style.overflowY,
                height: el.style.height,
                maxHeight: el.style.maxHeight
              });
              el.style.overflow = 'visible';
              el.style.overflowX = 'visible';
              el.style.overflowY = 'visible';
              el.style.height = el.scrollHeight + 'px';
              el.style.maxHeight = 'none';
            }

            // –†–µ–Ω–¥–µ—Ä DOM –∫–∞—Ä—Ç–æ—á–∫–∏ –≤ canvas
            const canvas = await html2canvas(card, {
              backgroundColor: '#ffffff',
              scale: scale,
              useCORS: true,
              scrollY: -window.scrollY
            });

            for(const r of restore){
              r.el.style.overflow = r.overflow;
              r.el.style.overflowX = r.overflowX;
              r.el.style.overflowY = r.overflowY;
              r.el.style.height = r.height;
              r.el.style.maxHeight = r.maxHeight;
            }

            const img = canvas.toDataURL('image/png');

            const imgW = pageW - margin * 2;
            const imgH = imgW * (canvas.height / canvas.width);

            if (y + imgH > pageH - margin && y !== margin) {
              pdf.addPage();
              y = margin;
            }

            pdf.addImage(img, 'PNG', margin, y, imgW, imgH);
            y += imgH + 10;
          }

          pdf.save('WB_All_Charts.pdf');
        }

          // Sections: TC
          const emptyBox = document.getElementById('tcEmpty');
          const contentWrap = document.getElementById('tcContent');
          const tbody = document.getElementById('tcTbody');
          const tcStreamDeltaTbody = document.getElementById('tcStreamDeltaTbody');
          const tcTableReleaseFilter = document.getElementById('tcTableReleaseFilter');

          // Coverage (HB)
          const covEmpty = document.getElementById('covEmpty');
          const covContent = document.getElementById('covContent');
          const covTbody = document.getElementById('covTbody');
          const covTableWrap = document.getElementById('covTableWrap');
          const covReleaseFilter = document.getElementById('covReleaseFilter');

          // Coverage Selective
          const selEmpty = document.getElementById('selEmpty');
          const selContent = document.getElementById('selContent');
          const selTbody = document.getElementById('selTbody');
          const selTableWrap = document.getElementById('selTableWrap');
          const selReleaseFilter = document.getElementById('selReleaseFilter');
          const selCanvas = document.getElementById('selTrendChart');

          // Average time
          const avgEmpty = document.getElementById('avgEmpty');
          const avgContent = document.getElementById('avgContent');
          const avgTbody = document.getElementById('avgTbody');
          const avgTableWrap = document.getElementById('avgTableWrap');
          const avgReleaseFilter = document.getElementById('avgReleaseFilter');
          const avgCanvas = document.getElementById('avgTrendChart');

          // Cherepiki
          const chpEmpty = document.getElementById('chpEmpty');
          const chpContent = document.getElementById('chpContent');
          const chpTbody = document.getElementById('chpTbody');
          const chpTableWrap = document.getElementById('chpTableWrap');
          const chpReleaseFilter = document.getElementById('chpReleaseFilter');
          const chpCanvas = document.getElementById('chpTrendChart');

          // Cutoff/store
          const cutEmpty = document.getElementById('cutEmpty');
          const cutContent = document.getElementById('cutContent');
          const cutTbody = document.getElementById('cutTbody');
          const cutTableWrap = document.getElementById('cutTableWrap');
          const cutReleaseFilter = document.getElementById('cutReleaseFilter');
          const cutCanvas = document.getElementById('cutTrendChart');

          // Types (Deploy-lab issues) ‚Äî iOS/Android
          const iosTypesEmpty = document.getElementById('iosTypesEmpty');
          const iosTypesContent = document.getElementById('iosTypesContent');
          const iosTypesTheadRow = document.getElementById('iosTypesTheadRow');
          const iosTypesTbody = document.getElementById('iosTypesTbody');
          const iosTypesLegend = document.getElementById('iosTypesLegend');
          const iosTypesCanvas = document.getElementById('iosTypesTrendChart');
          const iosTypesReleaseFilter = document.getElementById('iosTypesReleaseFilter');

          const andTypesEmpty = document.getElementById('andTypesEmpty');
          const andTypesContent = document.getElementById('andTypesContent');
          const andTypesTheadRow = document.getElementById('andTypesTheadRow');
          const andTypesTbody = document.getElementById('andTypesTbody');
          const andTypesLegend = document.getElementById('andTypesLegend');
          const andTypesCanvas = document.getElementById('andTypesTrendChart');
          const andTypesReleaseFilter = document.getElementById('andTypesReleaseFilter');

          const chartCanvas = document.getElementById('tcTrendChart');
          const covCanvas = document.getElementById('covTrendChart');
          const tcReleaseFilter = document.getElementById('tcReleaseFilter');

          let tcChart = null;
          let covChart = null;
          let selChart = null;
          let avgChart = null;
          let chpChart = null;
          let cutChart = null;
          let iosTypesChart = null;
          let andTypesChart = null;

          // SWAT list cache: fetch exec per release (cache by release)
          const __swatCache = new Map();
          const __swatPromiseCache = new Map();

          // Plugin: delta labels above points
          const deltaLabelsPlugin = {
            id: 'deltaLabels',
            afterDatasetsDraw(chart, args, pluginOptions){
              const opts = pluginOptions || chart?.options?.plugins?.deltaLabels;
              if(!opts) return;
              const dsIndex = Number(opts.datasetIndex);
              if(!Number.isFinite(dsIndex)) return;
              const ds = chart.data?.datasets?.[dsIndex];
              const meta = chart.getDatasetMeta(dsIndex);
              if(!ds || !meta || !meta.data) return;

              const data = Array.isArray(ds.data) ? ds.data : [];
              if(data.length < 2) return;

              const green = (opts.upColor) || '#22c55e';
              const red   = (opts.downColor) || '#f43f5e';
              const font  = (opts.font) || '600 11px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial';

              const fmt = (v) => {
                const n = Number(v);
                if(!Number.isFinite(n)) return '';
                const sign = n > 0 ? '+' : '';
                return sign + Math.round(n).toLocaleString('ru-RU');
              };

              const ctx = chart.ctx;
              ctx.save();

              // draw across full canvas (avoid clipping near top)
              ctx.beginPath();
              ctx.rect(0, 0, chart.width, chart.height);
              ctx.clip();

              ctx.font = font;
              ctx.textAlign = 'center';
              ctx.textBaseline = 'bottom';

              for(let i = 1; i < data.length; i++){
                const cur = Number(data[i]);
                const prev = Number(data[i-1]);
                if(!Number.isFinite(cur) || !Number.isFinite(prev)) continue;
                const delta = cur - prev;
                if(!delta) continue;

                const pt = meta.data[i];
                if(!pt) continue;

                const label = fmt(delta);
                if(!label) continue;

                ctx.fillStyle = delta > 0 ? green : red;
                ctx.fillText(label, pt.x, pt.y - 12);
              }

              ctx.restore();
            }
          };

          const valueLabelsPlugin = {
            id: 'valueLabels',
            afterDatasetsDraw(chart, args, pluginOptions){
              const opts = pluginOptions || chart?.options?.plugins?.valueLabels;
              if(!opts || !opts.datasets) return;
              const ctx = chart.ctx;
              ctx.save();
              ctx.font = (opts.font) || '600 11px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial';
              ctx.textAlign = 'center';
              ctx.textBaseline = 'bottom';
              for(const dsIndex of opts.datasets){
                const ds = chart.data?.datasets?.[dsIndex];
                const meta = chart.getDatasetMeta(dsIndex);
                if(!ds || !meta || !meta.data) continue;
                const data = Array.isArray(ds.data) ? ds.data : [];
                for(let i=0;i<data.length;i++){
                  const v = Number(data[i]);
                  if(!Number.isFinite(v)) continue;
                  const pt = meta.data[i];
                  if(!pt) continue;
                  ctx.fillStyle = ds.borderColor || '#111';
                  ctx.fillText(Math.round(v).toLocaleString('ru-RU'), pt.x, pt.y - 12);
                }
              }
              ctx.restore();
            }
          };

          const cutTimeLabelsPlugin = {
            id: 'cutTimeLabels',
            afterDatasetsDraw(chart, args, pluginOptions){
              const opts = pluginOptions || chart?.options?.plugins?.cutTimeLabels;
              if(!opts) return;
              const targetMin = Number(opts.targetMinutes);
              const windowMin = Number(opts.windowMinutes);
              if(!Number.isFinite(targetMin) || !Number.isFinite(windowMin)) return;

              const green = (opts.onColor) || '#22c55e';
              const red   = (opts.lateColor) || '#f43f5e';
              const font  = (opts.font) || '600 10px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial';

              const ctx = chart.ctx;
              ctx.save();
              ctx.beginPath();
              ctx.rect(0, 0, chart.width, chart.height);
              ctx.clip();
              ctx.font = font;
              ctx.textAlign = 'center';
              ctx.textBaseline = 'bottom';

              const datasets = chart.data?.datasets || [];
              for(let di = 0; di < datasets.length; di++){
                const ds = datasets[di];
                const label = String(ds?.label || '');
                if(!label.includes('Cutoff')) continue;
                const meta = chart.getDatasetMeta(di);
                if(!meta || !meta.data) continue;
                for(let i = 0; i < meta.data.length; i++){
                  const pt = meta.data[i];
                  if(!pt || pt.skip) continue;
                  const timeText = ds?._timeLabel?.[i] || '';
                  const m = String(timeText).match(/(\d{2}):(\d{2})$/);
                  if(!m) continue;
                  const minutes = Number(m[1]) * 60 + Number(m[2]);
                  const onTime = minutes >= targetMin && minutes <= (targetMin + windowMin);
                  const text = m[0];
                  const padX = 6;
                  const padY = 3;
                  const metrics = ctx.measureText(text);
                  const textW = metrics.width;
                  const textH = 10;
                  const offsetY = (di % 2 === 0) ? -18 : -32;
                  const x = pt.x;
                  const y = pt.y + offsetY;

                  ctx.fillStyle = 'rgba(255,255,255,0.9)';
                  ctx.strokeStyle = 'rgba(148,163,184,0.35)';
                  ctx.lineWidth = 1;
                  const boxX = x - textW / 2 - padX;
                  const boxY = y - textH - padY * 2;
                  const boxW = textW + padX * 2;
                  const boxH = textH + padY * 2;
                  const r = 6;
                  ctx.beginPath();
                  ctx.moveTo(boxX + r, boxY);
                  ctx.lineTo(boxX + boxW - r, boxY);
                  ctx.quadraticCurveTo(boxX + boxW, boxY, boxX + boxW, boxY + r);
                  ctx.lineTo(boxX + boxW, boxY + boxH - r);
                  ctx.quadraticCurveTo(boxX + boxW, boxY + boxH, boxX + boxW - r, boxY + boxH);
                  ctx.lineTo(boxX + r, boxY + boxH);
                  ctx.quadraticCurveTo(boxX, boxY + boxH, boxX, boxY + boxH - r);
                  ctx.lineTo(boxX, boxY + r);
                  ctx.quadraticCurveTo(boxX, boxY, boxX + r, boxY);
                  ctx.closePath();
                  ctx.fill();
                  ctx.stroke();

                  // leader line from point to label
                  ctx.beginPath();
                  ctx.strokeStyle = 'rgba(148,163,184,0.6)';
                  ctx.lineWidth = 1;
                  ctx.moveTo(pt.x, pt.y - 2);
                  ctx.lineTo(x, y - textH - padY * 2 + 1);
                  ctx.stroke();

                  ctx.fillStyle = onTime ? green : red;
                  ctx.fillText(text, x, y - padY);
                }
              }

              ctx.restore();
            }
          };

          try{
            if(window.Chart && typeof window.Chart.register === 'function'){
              window.Chart.register(deltaLabelsPlugin);
              window.Chart.register(valueLabelsPlugin);
              window.Chart.register(cutTimeLabelsPlugin);
            }
          }catch(e){}

          function b64Utf8(str){
            return btoa(unescape(encodeURIComponent(str)));
          }
          function b64Query(filters){
            return b64Utf8(JSON.stringify(filters));
          }

          function normalizeLogin(v){
            if(v === null || v === undefined) return '';
            let s = String(v).trim();
            if(!s) return '';
            s = s.replace(/^@+/, '');
            s = s.split(/[\s,(]/)[0];
            return s.trim().toLowerCase();
          }

          function authHeaders(){
            const tok = (inpAllureToken?.value || '').trim();
            return {
              'Accept': 'application/json',
              'Authorization': `Api-Token ${tok}`
            };
          }

          // –í–ê–ñ–ù–û: —Ç—É—Ç –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –º–∏–Ω–∏–º–∞–ª—å–Ω–æ –Ω—É–∂–Ω—ã–µ –∑–∞–≥–æ–ª–æ–≤–∫–∏
          function deployHeaders(){
            const tok = (inpDeployToken?.value || '').trim();
            return {
              'accept': '*/*',
              'accept-language': 'ru,en;q=0.9',
              'authorization-deploy-lab': `Bearer ${tok}`
            };
          }

          function showToast(msg, ok=true){
            const el = document.getElementById('toast');
            const inner = document.getElementById('toastInner');
            if(!el || !inner) return;
            inner.textContent = msg;
            inner.className = 'px-4 py-2 rounded-2xl text-sm font-semibold ring-1 shadow ' + (ok
              ? 'bg-white/90 ring-[#ecebff] text-slate-700'
              : 'bg-rose-50 ring-rose-200 text-rose-700'
            );
            el.style.opacity = '1';
            clearTimeout(showToast.__t);
            showToast.__t = setTimeout(() => { el.style.opacity = '0'; }, 1800);
          }

          async function fetchWithRetry(fetcher, { maxTries = 5, baseDelay = 200 } = {}){
            let lastErr;
            for(let i=0;i<maxTries;i++){
              try{
                return await fetcher();
              }catch(e){
                lastErr = e;
                if(i < maxTries - 1){
                  const jitter = Math.floor(Math.random() * 120);
                  const waitMs = baseDelay * Math.pow(2, i) + jitter;
                  await new Promise(res => setTimeout(res, waitMs));
                  continue;
                }
              }
            }
            throw lastErr;
          }

          async function proxyGetJson(targetUrl, headers, signal){
            const p = new URL(PROXY_BASE + '/proxy');
            p.searchParams.set('url', targetUrl);
            return fetchWithRetry(async () => {
              const r = await fetch(p.toString(), { headers, signal });
              if(!r.ok) throw new Error(`Proxy HTTP ${r.status}`);
              return r.json();
            });
          }

          async function fetchLastCherepik(prefix, release, signal){
            const tok = (inpDeployToken?.value || '').trim();
            if(!tok) return null;

            const url = `https://deploy-lab-api.wb.ru/releaseboss/admin_panel/release/${prefix}_${release}/notification_history`;
            try {
              const headers = {
                'authorization-deploy-lab': `Bearer ${tok}`,
                'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36'
              };
              const response = await proxyGetJson(url, headers, signal);
              if (!Array.isArray(response?.logs)) return null;

              // –ë–µ—Ä—ë–º —Å–∞–º—ã–π –ù–û–í–´–ô –ª–æ–≥ (–º–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è date) —Å—Ä–µ–¥–∏ —Å–æ–æ–±—â–µ–Ω–∏–π —Å "–ù–æ–≤—ã–π —á–µ—Ä–∏–ø–∏–∫"
              let maxMsLocal = null;
              for (const log of response.logs) {
                if (log?.message && String(log.message).includes('–ù–æ–≤—ã–π —á–µ—Ä–∏–ø–∏–∫')) {
                  const dateStr = log.date;
                  const p = toMskLocalParts(dateStr);
                  if (p && Number.isFinite(p.msLocal)) {
                    if (maxMsLocal === null || p.msLocal > maxMsLocal) maxMsLocal = p.msLocal;
                  }
                }
              }

              if (maxMsLocal === null) return null;
              return labelFromMsLocal(maxMsLocal);
            } catch (e) {
              console.error('Error fetching last cherepik:', e);
              return null;
            }
          }

          async function fetchDeployIssueCount(prefix, release, signal){
            const tok = (inpDeployToken?.value || '').trim();
            if(!tok) return 0;
            const url = DEPLOY_ISSUES_URL_TMPL
              .replace('{prefix}', prefix)
              .replace('{rel}', release);
            const data = await proxyGetJson(url, deployHeaders(), signal);
            if(!Array.isArray(data)) return 0;
            let n = 0;
            for(const item of data){
              if(item && item.merged_after_cutoff === true) n += 1;
            }
            return n;
          }

          async function fetchDeployIssuesList(prefix, release, signal){
            const tok = (inpDeployToken?.value || '').trim();
            if(!tok) return [];

            const url = DEPLOY_ISSUES_URL_TMPL
              .replace('{prefix}', prefix)
              .replace('{rel}', release);

            const data = await proxyGetJson(url, deployHeaders(), signal);
            if(Array.isArray(data)) return data;
            if(Array.isArray(data?.data)) return data.data;
            if(Array.isArray(data?.content)) return data.content;
            return [];
          }

          function normalizeIssueType(x){
            const t = String(x || '').trim();
            return t || 'Unknown';
          }

          function aggregateIssuesByType(items){
            const counts = Object.create(null);
            const details = Object.create(null);
            const typeSet = new Set();

            for(const it of (items || [])){
              if(!it) continue;
              const type = normalizeIssueType(it.type);
              typeSet.add(type);
              counts[type] = (counts[type] || 0) + 1;

              if(!details[type]) details[type] = [];
              details[type].push({
                key: it.key || '',
                summary: it.summary || '',
                status: it.status || '',
                stream: it.stream || '',
                merged_after_cutoff: it.merged_after_cutoff === true
              });
            }

            for(const t of Object.keys(details)){
              details[t].sort((a,b) => String(a.key || '').localeCompare(String(b.key || '')));
            }

            return { counts, details, typeSet };
          }

          const TYPES_CANON_ORDER = [
            'Task','Bug','Release','Epic','Defect','Analytics','User Story','Testing','Documentation','Test automation','Feature','Tech Dept'
          ];

          function sortTypesByCanon(typeSet){
            const types = Array.from(typeSet || []);
            const canon = [];
            const rest = [];
            for(const t of types){
              if(TYPES_CANON_ORDER.includes(t)) canon.push(t);
              else rest.push(t);
            }
            canon.sort((a,b) => TYPES_CANON_ORDER.indexOf(a) - TYPES_CANON_ORDER.indexOf(b));
            rest.sort((a,b) => a.localeCompare(b));
            return [...canon, ...rest];
          }

          function colorForTypeLabel(label){
            const s = String(label || '');
            let h = 0;
            for(let i=0;i<s.length;i++){
              h = (h*31 + s.charCodeAt(i)) >>> 0;
            }
            const hue = h % 360;
            return `hsl(${hue}, 65%, 45%)`;
          }

          function renderDynamicLegend(container, chart){
            if(!container) return;
            container.innerHTML = '';
            if(!chart?.data?.datasets?.length) return;

            for(const ds of chart.data.datasets){
              const item = document.createElement('span');
              item.className = 'lg-item';

              const dot = document.createElement('span');
              dot.className = 'dot';
              dot.style.background = ds.borderColor || ds.backgroundColor || '#999';

              const txt = document.createElement('span');
              txt.textContent = ds.label || '';

              item.appendChild(dot);
              item.appendChild(txt);
              container.appendChild(item);
            }
          }

          function normalizeStreamLabel(x){
            const s = String(x || '').trim();
            return s || '–ë–µ–∑ —Å—Ç—Ä–∏–º–∞';
          }

          function isExternalStreamLabel(label){
            const s = String(label || '').trim().toLowerCase();
            if(!s) return false;
            const norm = s
              .replace(/[—ë]/g, '–µ')
              .replace(/[_\-]+/g, ' ')
              .replace(/\s+/g, ' ')
              .trim();

            const external = [
              '—Ñ–∏–Ω—Ç–µ—Ö',
              '–±–∞–Ω–∫',
              'payments',
              '–ø–ª–∞—Ç–µ–∂–∏',
              'travel',
              '—Ç—Ä–µ–≤–µ–ª',
              'wb club',
              '–≤–± –∫–ª—É–±'
            ];
            return external.some(x => norm === x || norm.includes(x));
          }

          function groupIssuesByStream(items){
            const map = new Map();
            for(const it of (items || [])){
              if(!it) continue;
              const stream = normalizeStreamLabel(it.stream);
              map.set(stream, (map.get(stream) || 0) + 1);
            }
            return Array.from(map.entries()).sort((a,b) => a[0].localeCompare(b[0]));
          }

          function countIssuesByStreamGroup(items){
            let internal = 0;
            let external = 0;
            for(const it of (items || [])){
              if(!it) continue;
              const stream = normalizeStreamLabel(it.stream);
              if(isExternalStreamLabel(stream)) external += 1;
              else internal += 1;
            }
            return { internal, external };
          }

          let __streamPopover = null;
          function ensureStreamPopover(){
            if(__streamPopover) return __streamPopover;
            const el = document.createElement('div');
            el.className = 'popover';
            el.style.display = 'none';
            document.body.appendChild(el);
            __streamPopover = el;
            return el;
          }

          function hideStreamPopover(){
            if(__streamPopover) __streamPopover.style.display = 'none';
          }

          function showStreamPopover(anchor, items){
            const groups = groupIssuesByStream(items);
            if(!groups.length) return;

            const internal = [];
            const external = [];
            for(const [name, count] of groups){
              const entry = { name, count };
              if(isExternalStreamLabel(name)) external.push(entry);
              else internal.push(entry);
            }

            const pop = ensureStreamPopover();
            pop.innerHTML = '';

            const addBlock = (title, list) => {
              const hdr = document.createElement('div');
              hdr.className = 'pop-hdr';
              hdr.textContent = title;
              pop.appendChild(hdr);
              if(!list.length){
                const empty = document.createElement('div');
                empty.className = 'pop-row';
                empty.textContent = '‚Äî';
                pop.appendChild(empty);
                return;
              }
              for(const it of list){
                const row = document.createElement('div');
                row.className = 'pop-row';
                const name = document.createElement('span');
                name.className = 'pop-name';
                name.textContent = it.name;
                const val = document.createElement('span');
                val.className = 'pop-val';
                val.textContent = String(it.count);
                row.appendChild(name);
                row.appendChild(val);
                pop.appendChild(row);
              }
            };

            addBlock('–í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ', internal);
            addBlock('–í–Ω–µ—à–Ω–∏–µ', external);

            const r = anchor.getBoundingClientRect();
            pop.style.display = 'block';
            pop.style.left = Math.max(12, r.left) + 'px';
            pop.style.top = (r.bottom + 8 + window.scrollY) + 'px';
          }

          function renderIssuesByStream(td, items){
            td.innerHTML = '';
            const { internal, external } = countIssuesByStreamGroup(items);
            if((internal + external) === 0){
              td.textContent = '‚Äî';
              return;
            }

            const wrap = document.createElement('div');
            wrap.className = 'stream-cell';

            const lineIn = document.createElement('div');
            lineIn.className = 'stream-line';
            const nameIn = document.createElement('span');
            nameIn.className = 'stream-name';
            nameIn.textContent = '–í–Ω—É—Ç—Ä.:';
            const valIn = document.createElement('span');
            valIn.className = 'stream-issues';
            valIn.textContent = String(internal);
            lineIn.appendChild(nameIn);
            lineIn.appendChild(valIn);

            const lineOut = document.createElement('div');
            lineOut.className = 'stream-line';
            const nameOut = document.createElement('span');
            nameOut.className = 'stream-name';
            nameOut.textContent = '–í–Ω–µ—à–Ω–∏–µ:';
            const valOut = document.createElement('span');
            valOut.className = 'stream-issues';
            valOut.textContent = String(external);
            lineOut.appendChild(nameOut);
            lineOut.appendChild(valOut);

            wrap.appendChild(lineIn);
            wrap.appendChild(lineOut);
            td.appendChild(wrap);

            td.onmouseenter = () => showStreamPopover(td, items);
            td.onmouseleave = hideStreamPopover;
          }

          function renderTypesTable(theadRowEl, tbodyEl, typeList, rows){
            if(!theadRowEl || !tbodyEl) return;

            theadRowEl.innerHTML = '';
            const th0 = document.createElement('th');
            th0.className = 'text-left';
            th0.textContent = '–†–µ–ª–∏–∑';
            theadRowEl.appendChild(th0);

            for(const t of typeList){
              const th = document.createElement('th');
              th.className = 'text-center';
              th.textContent = t;
              theadRowEl.appendChild(th);
            }

            tbodyEl.innerHTML = '';
            for(const row of rows){
              const tr = document.createElement('tr');
              tr.dataset.release = row.release;

              const td0 = document.createElement('td');
              td0.className = 'mono text-left';
              td0.textContent = row.release;
              tr.appendChild(td0);

              for(const t of typeList){
                const td = document.createElement('td');
                td.className = 'mono text-left';
                renderIssuesByStream(td, row.details ? row.details[t] : []);
                tr.appendChild(td);
              }

              tbodyEl.appendChild(tr);
            }
          }

          function buildOrUpdateTypesChart(existingChart, canvas, legendEl, typeList, labels, rows){
            if(!canvas) return existingChart;

            const datasetsRaw = typeList.map((t)=>({
              label: t,
              data: rows.map(r => (r.counts && r.counts[t]) ? r.counts[t] : 0),
              borderColor: colorForTypeLabel(t),
              backgroundColor: colorForTypeLabel(t),
              tension: 0.25,
              borderWidth: 2,
              pointRadius: 3,
              pointHoverRadius: 5,
              spanGaps: true
            }));

            const datasets = datasetsRaw.filter(ds => ds.data.some(v => (Number(v)||0) !== 0));

            if(!datasets.length){
              if(existingChart){
                try{ existingChart.destroy(); }catch(e){}
              }
              if(legendEl) legendEl.innerHTML = '';
              return null;
            }

            if(!existingChart){
              existingChart = new Chart(canvas, {
                type: 'line',
                data: { labels, datasets },
                options: {
                  responsive: true,
                  maintainAspectRatio: false,
                  interaction: { mode: 'nearest', intersect: false },
                  scales: {
                    x: { ticks: { maxRotation: 0, autoSkip: true }, grid: { display: false } },
                    y: { beginAtZero: true, ticks: { precision: 0 } }
                  },
                  plugins: {
                    legend: { display: false },
                    tooltip: {
                      mode: 'index',
                      intersect: false,
                      callbacks: {
                        afterLabel: () => ''
                      }
                    }
                  }
                }
              });
            }else{
              existingChart.data.labels = labels;
              existingChart.data.datasets = datasets;
              existingChart.update();
            }

            existingChart._typeDetails = rows.map(r => r.details || {});
            renderDynamicLegend(legendEl, existingChart);
            try{ existingChart.resize(); }catch(e){}
            return existingChart;
          }


          // ---- –¥–∞—Ç—ã/–≤—Ä–µ–º—è –∏–∑ deploy-lab (1–≤1 –ø–æ python): cutoff_date –∏–∑ base, store_time = earliest note.date –∏–∑ deploy ----

          function normalizeIsoForJS(s){
            if(!s) return null;
            let x = String(s).trim();
            // trim fractional seconds to max 3 digits (JS Date is picky)
            x = x.replace(/(\.\d{3})\d+(?=[Z+\-])/, '$1');
            x = x.replace(/(\.\d{2})(?=[Z+\-])/, '$10');
            x = x.replace(/(\.\d)(?=[Z+\-])/, '$100');
            return x;
          }

          function parseTzOffsetMinutes(iso){
            if(!iso) return 0;
            const s = String(iso);
            if(s.endsWith('Z')) return 0;
            const m = s.match(/([+\-])(\d{2}):?(\d{2})$/);
            if(!m) return 0;
            const sign = m[1] === '-' ? -1 : 1;
            const hh = Number(m[2] || 0);
            const mm = Number(m[3] || 0);
            return sign * (hh * 60 + mm);
          }

          function pad2(n){ return String(n).padStart(2,'0'); }

          function dayShortRuFromDow(dow){
            // 0 –≤—Å,1 –ø–Ω,2 –≤—Ç,3 —Å—Ä,4 —á—Ç,5 –ø—Ç,6 —Å–±
            return ['–≤—Å','–ø–Ω','–≤—Ç','—Å—Ä','—á—Ç','–ø—Ç','—Å–±'][dow] || '';
          }

          function toMskLocalParts(iso){
            const norm = normalizeIsoForJS(iso);
            if(!norm) return null;

            const d = new Date(norm);
            if(Number.isNaN(d.getTime())) return null;

            const offMin = parseTzOffsetMinutes(norm);
            const msLocal = d.getTime() + offMin * 60_000;
            const dl = new Date(msLocal);

            const dow = dl.getUTCDay(); // day in that offset zone
            const dayShort = dayShortRuFromDow(dow);
            const dd = pad2(dl.getUTCDate());
            const MM = pad2(dl.getUTCMonth()+1);
            const hh = pad2(dl.getUTCHours());
            const mm = pad2(dl.getUTCMinutes());

            return {
              msLocal,
              dow,
              dayShort,
              dateText: `${dd}.${MM}`,
              timeText: `${hh}:${mm}`,
              fullText: `${dayShort} ${dd}.${MM} ${hh}:${mm}`
            };
          }

          // –∏–Ω–¥–µ–∫—Å –¥–ª—è –æ—Å–∏ Y: –ø–æ—Ä—è–¥–æ–∫ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —Å–≤–µ—Ä—Ö—É –≤–Ω–∏–∑: –≤—Å, —Å–±, –ø—Ç, —á—Ç, —Å—Ä, –≤—Ç, –ø–Ω
          function dayIndexCustom(dow){
            // dow: 0 –≤—Å ... 6 —Å–±
            // idx: 0 –≤—Å, 1 —Å–±, 2 –ø—Ç, 3 —á—Ç, 4 —Å—Ä, 5 –≤—Ç, 6 –ø–Ω
            return (7 - dow) % 7;
          }

          function yValueFromIso(iso){
            const p = toMskLocalParts(iso);
            if(!p) return null;
            const idx = dayIndexCustom(p.dow);
            const dl = new Date(p.msLocal);
            const mins = dl.getUTCHours() * 60 + dl.getUTCMinutes() + (dl.getUTCSeconds() / 60);
            return {
              y: idx * 1440 + mins,
              msLocal: p.msLocal,
              label: p.fullText
            };
          }

          function yValueFromMsLocal(msLocal){
            const ms = Number(msLocal);
            if(!Number.isFinite(ms)) return null;
            const dl = new Date(ms);
            if(Number.isNaN(dl.getTime())) return null;
            const idx = dayIndexCustom(dl.getUTCDay());
            const mins = dl.getUTCHours() * 60 + dl.getUTCMinutes() + (dl.getUTCSeconds() / 60);
            return {
              y: idx * 1440 + mins,
              msLocal: ms,
              label: labelFromMsLocal(ms)
            };
          }

          function yValueFromIsoCut(iso){
            const p = toMskLocalParts(iso);
            if(!p) return null;
            const dl = new Date(p.msLocal);
            const mins = dl.getUTCHours() * 60 + dl.getUTCMinutes();
            return {
              y: mins,
              msLocal: p.msLocal,
              label: p.fullText
            };
          }

          function yValueFromMsLocalCut(msLocal){
            const ms = Number(msLocal);
            if(!Number.isFinite(ms)) return null;
            const dl = new Date(ms);
            if(Number.isNaN(dl.getTime())) return null;
            const mins = dl.getUTCHours() * 60 + dl.getUTCMinutes();
            return {
              y: mins,
              msLocal: ms,
              label: labelFromMsLocal(ms)
            };
          }


          function extractEarliestNoteDate(deployObj, sectionKey){
            if(!deployObj || typeof deployObj !== 'object') return null;
            const sec = deployObj[sectionKey];
            if(!sec || typeof sec !== 'object') return null;
            const notes = Array.isArray(sec.notes) ? sec.notes : [];
            const dates = [];
            for(const n of notes){
              const iso = n && n.date;
              const p = toMskLocalParts(iso);
              if(p && Number.isFinite(p.msLocal)) dates.push(p.msLocal);
            }
            if(!dates.length) return null;
            const minMs = Math.min(...dates);
            // –≤–µ—Ä–Ω—É—Ç—å –∏—Å—Ö–æ–¥–Ω—ã–π ISO –Ω–µ –º–æ–∂–µ–º, –Ω–æ –º–æ–∂–µ–º –≤–µ—Ä–Ω—É—Ç—å msLocal + label (label –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏–º –∏–∑ msLocal)
            return minMs;
          }

          function labelFromMsLocal(msLocal){
            const dl = new Date(msLocal);
            const dow = dl.getUTCDay();
            const dayShort = dayShortRuFromDow(dow);
            const dd = pad2(dl.getUTCDate());
            const MM = pad2(dl.getUTCMonth()+1);
            const hh = pad2(dl.getUTCHours());
            const mm = pad2(dl.getUTCMinutes());
            return `${dayShort} ${dd}.${MM} ${hh}:${mm}`;
          }

          async function fetchDeployDates(prefix, release, signal){
            const tok = (inpDeployToken?.value || '').trim();
            if(!tok) return { cutoff: null, store: null };

            const baseUrl = DEPLOY_BASE_URL_TMPL.replace('{prefix}', prefix).replace('{rel}', release);
            const deployUrl = DEPLOY_DEPLOY_URL_TMPL.replace('{prefix}', prefix).replace('{rel}', release);

            let cutoffIso = null;
            let storeMsLocal = null;

            try{
              const base = await proxyGetJson(baseUrl, deployHeaders(), signal);
              cutoffIso = base?.cutoff_date || null;
            }catch(e){
              cutoffIso = null;
            }

            try{
              const dep = await proxyGetJson(deployUrl, deployHeaders(), signal);
              if(prefix === 'ANDROID'){
                storeMsLocal = extractEarliestNoteDate(dep, 'Google Play');
              }else{
                storeMsLocal = extractEarliestNoteDate(dep, 'AppStore');
              }
            }catch(e){
              storeMsLocal = null;
            }

            return { cutoff: cutoffIso, storeMsLocal };
          }

          // ---- helpers: UI/empty ----
          function setEmpty(text){
            if(!emptyBox) return;
            emptyBox.textContent = text;
            emptyBox.style.display = '';
          }
          function showContent(){
            if(emptyBox) emptyBox.style.display = 'none';
            contentWrap.style.display = '';
          }
          function showEmpty(text){
            setEmpty(text);
            contentWrap.style.display = 'none';
          }

          function setCovEmpty(text){
            if(!covEmpty) return;
            covEmpty.textContent = text;
            covEmpty.style.display = '';
          }
          function showCovContent(){
            if(covEmpty) covEmpty.style.display = 'none';
            if(covContent) covContent.style.display = '';
          }
          function showCovEmpty(text){
            setCovEmpty(text);
            if(covContent) covContent.style.display = 'none';
            if(covTableWrap) covTableWrap.style.display = 'none';
          }

          function setSelEmpty(text){
            if(!selEmpty) return;
            selEmpty.textContent = text;
            selEmpty.style.display = '';
          }
          function showSelContent(){
            if(selEmpty) selEmpty.style.display = 'none';
            if(selContent) selContent.style.display = '';
          }
          function showSelEmpty(text){
            setSelEmpty(text);
            if(selContent) selContent.style.display = 'none';
            if(selTableWrap) selTableWrap.style.display = 'none';
          }

          function setAvgEmpty(text){
            if(!avgEmpty) return;
            avgEmpty.textContent = text;
            avgEmpty.style.display = '';
          }
          function showAvgContent(){
            if(avgEmpty) avgEmpty.style.display = 'none';
            if(avgContent) avgContent.style.display = '';
          }
          function showAvgEmpty(text){
            setAvgEmpty(text);
            if(avgContent) avgContent.style.display = 'none';
            if(avgTableWrap) avgTableWrap.style.display = 'none';
          }

          function setChpEmpty(text){
            if(!chpEmpty) return;
            chpEmpty.textContent = text;
            chpEmpty.style.display = '';
          }
          function showChpContent(){
            if(chpEmpty) chpEmpty.style.display = 'none';
            if(chpContent) chpContent.style.display = '';
          }
          function showChpEmpty(text){
            setChpEmpty(text);
            if(chpContent) chpContent.style.display = 'none';
            if(chpTableWrap) chpTableWrap.style.display = 'none';
          }

          function setCutEmpty(text){
            if(!cutEmpty) return;
            cutEmpty.textContent = text;
            cutEmpty.style.display = '';
          }
          function showCutContent(){
            if(cutEmpty) cutEmpty.style.display = 'none';
            if(cutContent) cutContent.style.display = '';
          }
          function showCutEmpty(text){
            setCutEmpty(text);
            if(cutContent) cutContent.style.display = 'none';
            if(cutTableWrap) cutTableWrap.style.display = 'none';
          }



          function setIosTypesEmpty(text){
            if(!iosTypesEmpty) return;
            iosTypesEmpty.textContent = text;
            iosTypesEmpty.style.display = '';
          }
          function showIosTypesContent(){
            if(iosTypesEmpty) iosTypesEmpty.style.display = 'none';
            if(iosTypesContent) iosTypesContent.style.display = '';
          }
          function showIosTypesEmpty(text){
            setIosTypesEmpty(text);
            if(iosTypesContent) iosTypesContent.style.display = 'none';
          }

          function setAndTypesEmpty(text){
            if(!andTypesEmpty) return;
            andTypesEmpty.textContent = text;
            andTypesEmpty.style.display = '';
          }
          function showAndTypesContent(){
            if(andTypesEmpty) andTypesEmpty.style.display = 'none';
            if(andTypesContent) andTypesContent.style.display = '';
          }
          function showAndTypesEmpty(text){
            setAndTypesEmpty(text);
            if(andTypesContent) andTypesContent.style.display = 'none';
          }

          function setRunning(running){
            if(running){
              startBtn.style.display = 'none';
              stopBtn.style.display = '';
              window.__wbAbortController = new AbortController();
              showEmpty('–î–∞–Ω–Ω—ã–µ –ø–æ—è–≤—è—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–∑ –∏—Å—Ç–æ—á–Ω–∏–∫–∞');
              showCovEmpty('–î–∞–Ω–Ω—ã–µ –ø–æ—è–≤—è—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–∑ –∏—Å—Ç–æ—á–Ω–∏–∫–∞');
              showSelEmpty('–î–∞–Ω–Ω—ã–µ –ø–æ—è–≤—è—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–∑ –∏—Å—Ç–æ—á–Ω–∏–∫–∞');
              showAvgEmpty('–î–∞–Ω–Ω—ã–µ –ø–æ—è–≤—è—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–∑ –∏—Å—Ç–æ—á–Ω–∏–∫–∞');
              showChpEmpty('–î–∞–Ω–Ω—ã–µ –ø–æ—è–≤—è—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–∑ –∏—Å—Ç–æ—á–Ω–∏–∫–∞');
              showCutEmpty('–î–∞–Ω–Ω—ã–µ –ø–æ—è–≤—è—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–∑ –∏—Å—Ç–æ—á–Ω–∏–∫–∞');
              showIosTypesEmpty('–î–∞–Ω–Ω—ã–µ –ø–æ—è–≤—è—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–∑ –∏—Å—Ç–æ—á–Ω–∏–∫–∞');
              showAndTypesEmpty('–î–∞–Ω–Ω—ã–µ –ø–æ—è–≤—è—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–∑ –∏—Å—Ç–æ—á–Ω–∏–∫–∞');
            }else{
              stopBtn.style.display = 'none';
              startBtn.style.display = '';
              if(window.__wbAbortController){
                try{ window.__wbAbortController.abort(); }catch(e){}
              }
              window.__wbAbortController = null;
            }
          }

          function saveInputs(){
            try{ localStorage.setItem(LS_TOKEN_KEY, inpAllureToken.value || ''); }catch(e){}
            try{ localStorage.setItem(LS_DEPLOY_KEY, inpDeployToken.value || ''); }catch(e){}
            try{ localStorage.setItem(LS_RANGE_KEY, JSON.stringify({ from: inpFrom.value || '', to: inpTo.value || '' })); }catch(e){}
          }

          function restoreInputs(){
            try{
              const tok = localStorage.getItem(LS_TOKEN_KEY) || '';
              if(inpAllureToken) inpAllureToken.value = tok;
            }catch(e){}
            try{
              const dt = localStorage.getItem(LS_DEPLOY_KEY) || '';
              if(inpDeployToken) inpDeployToken.value = dt;
            }catch(e){}
            try{
              const raw = localStorage.getItem(LS_RANGE_KEY);
              if(raw){
                const obj = JSON.parse(raw);
                if(inpFrom) inpFrom.value = obj?.from || '';
                if(inpTo) inpTo.value = obj?.to || '';
              }
            }catch(e){}
          }

          function clear(){
            tbody.innerHTML = '';
            if(tcStreamDeltaTbody) tcStreamDeltaTbody.innerHTML = '';
            if(tcChart){
              tcChart.data.labels = [];
              tcChart.data.datasets.forEach(d => d.data = []);
              tcChart.update();
            }

            if(covTbody) covTbody.innerHTML = '';
            if(covTableWrap) covTableWrap.style.display = 'none';
            if(covChart){
              covChart.data.labels = [];
              covChart.data.datasets.forEach(d => d.data = []);
              covChart._swatPeople = [];
              covChart.update();
            }

            if(selTbody) selTbody.innerHTML = '';
            if(selTableWrap) selTableWrap.style.display = 'none';
            if(selChart){
              selChart.data.labels = [];
              selChart.data.datasets.forEach(d => d.data = []);
              selChart._swatPeople = [];
              selChart.update();
            }

            if(avgTbody) avgTbody.innerHTML = '';
            if(avgTableWrap) avgTableWrap.style.display = 'none';
            if(avgChart){
              avgChart.data.labels = [];
              avgChart.data.datasets.forEach(d => d.data = []);
              avgChart.update();
            }

            if(chpTbody) chpTbody.innerHTML = '';
            if(chpTableWrap) chpTableWrap.style.display = 'none';
            if(chpChart){
              chpChart.data.labels = [];
              chpChart.data.datasets.forEach(d => d.data = []);
              chpChart.update();
            }

            if(cutTbody) cutTbody.innerHTML = '';
            if(cutTableWrap) cutTableWrap.style.display = 'none';
            if(cutChart){
              cutChart.data.labels = [];
              cutChart.data.datasets.forEach(d => {
                d.data = [];
                d._timeLabel = [];
                d._timeMs = [];
                d._lastChpLabel = [];
              });
              cutChart.update();
            }
          }

          async function fetchSwatLogins(release, signal){
            const rel = String(release || '').trim();
            if(!rel) return { set: new Set(), total: 0 };

            if(__swatCache.has(rel)) return __swatCache.get(rel);
            if(__swatPromiseCache.has(rel)) return __swatPromiseCache.get(rel);

            const p = (async () => {
              const url = new URL(SWAT_LIST_URL);
              url.searchParams.set('release', rel);

              const r = await fetch(url.toString(), { signal });
              if(!r.ok) throw new Error(`SWAT list HTTP ${r.status}`);

              const data = await r.json();
              const logins = Array.isArray(data?.worked_SWAT?.login) ? data.worked_SWAT.login : [];
              const declaredTotal = Number(data?.worked_SWAT?.total || 0) || 0;

              const set = new Set();
              for(const l of logins){
                const norm = normalizeLogin(l);
                if(norm) set.add(norm);
              }

              const out = { set, total: declaredTotal || set.size };
              __swatCache.set(rel, out);
              __swatPromiseCache.delete(rel);
              return out;
            })();

            __swatPromiseCache.set(rel, p);

            try{
              return await p;
            }catch(e){
              __swatPromiseCache.delete(rel);
              __swatCache.delete(rel);
              throw e;
            }
          }

          function cssVar(name, fallback){
            try{
              const v = getComputedStyle(document.documentElement).getPropertyValue(name).trim();
              return v || fallback;
            }catch{ return fallback; }
          }

          // ---- —Ä–µ–ª–∏–∑—ã ----
          function parseVersion(v){
            const raw = (v||'').trim();
            const parts = raw.split('.').map(x => x.trim());
            if(parts.length < 3) return null;

            const [major, minor, buildRaw] = parts;
            if(!/^\d+$/.test(major) || !/^\d+$/.test(minor) || !/^\d+$/.test(buildRaw)) return null;

            const majorN = Number(major);
            const minorN = Number(minor);
            if(!Number.isFinite(majorN) || !Number.isFinite(minorN)) return null;

            let buildN = Number(buildRaw);
            if(!Number.isFinite(buildN)) return null;

            const len = buildRaw.length;
            if(len < 4){
              buildN = buildN * Math.pow(10, 4 - len);
            }

            const buildStrNorm = String(buildN).padStart(4, '0');
            return { major, minor, majorN, minorN, build: buildN, buildStrRaw: buildRaw, buildStrNorm };
          }

          function formatRelease(vObj){
            const m = String(vObj.majorN);
            const n = String(vObj.minorN);
            const b = (vObj.buildStrNorm ? String(vObj.buildStrNorm) : String(vObj.build).padStart(4, '0'));
            return `${m}.${n}.${b}`;
          }

          function validateAndNormalizeReleaseInput(inputEl){
            if(!inputEl) return null;
            const raw = (inputEl.value || '').trim();
            if(!raw) return null;
            const v = parseVersion(raw);
            if(!v) return null;
            const norm = formatRelease(v);
            inputEl.value = norm;
            return norm;
          }

          function attachReleaseMask(){
            [inpFrom, inpTo].forEach(el => {
              if(!el) return;
              el.addEventListener('blur', () => validateAndNormalizeReleaseInput(el));
            });
          }

          function buildMajorRange(){
            const a = parseVersion(inpFrom?.value);
            const b = parseVersion(inpTo?.value);
            if(!a || !b) return [];
            if(a.majorN !== b.majorN) return [];

            const step = 1000;

            const aKey = a.minorN * 10000 + a.build;
            const bKey = b.minorN * 10000 + b.build;
            const loV = aKey <= bKey ? a : b;
            const hiV = aKey <= bKey ? b : a;

            const out = [];
            for(let m = loV.minorN; m <= hiV.minorN; m++){
              let startBuild = 0;
              let endBuild   = 9000;

              if(m === loV.minorN) startBuild = Math.ceil(loV.build / step) * step;
              if(m === hiV.minorN) endBuild   = Math.floor(hiV.build / step) * step;

              if(startBuild > endBuild) continue;
              for(let build = startBuild; build <= endBuild; build += step){
                const buildStr = String(build).padStart(4, '0');
                out.push(`${loV.major}.${m}.${buildStr}`);
              }
            }
            return out;
          }

          function compareReleaseAsc(a, b){
            const pa = String(a || '').split('.').map(n => parseInt(n, 10) || 0);
            const pb = String(b || '').split('.').map(n => parseInt(n, 10) || 0);
            const len = Math.max(pa.length, pb.length);
            for(let i=0;i<len;i++){
              const da = pa[i] || 0;
              const db = pb[i] || 0;
              if(da !== db) return da - db;
            }
            return 0;
          }

          // ---- allure http ----
          const NET_CONCURRENCY = 1000;
          let __netActive = 0;
          const __netQueue = [];

          async function withNetLimit(fn){
            if(__netActive >= NET_CONCURRENCY){
              await new Promise(res => __netQueue.push(res));
            }
            __netActive += 1;
            try{
              return await fn();
            }finally{
              __netActive -= 1;
              const next = __netQueue.shift();
              if(next) next();
            }
          }

          async function httpGet(path, params, signal){
            const url = new URL(BASE_URL + path);
            if(params){
              Object.entries(params).forEach(([k,v]) => {
                if(v !== undefined && v !== null && v !== '') url.searchParams.set(k, String(v));
              });
            }
            return fetchWithRetry(async () => {
              const r = await withNetLimit(() => fetch(url.toString(), { headers: authHeaders(), signal }));
              if(!r.ok) throw new Error(`HTTP ${r.status} ${path}`);
              return r.json();
            });
          }

          async function fetchLaunches(version, kind, signal){
            const terms = [`[${kind}] –†–µ–≥—Ä–µ—Å—Å ${version}`];
            if(kind === 'Smoke') terms.push(`[High/Blocker][DeployLab] –†–µ–≥—Ä–µ—Å—Å ${version}`);
            if(kind === 'Selective') terms.push(`[Selective][DeployLab] –†–µ–≥—Ä–µ—Å—Å ${version}`);

            const byId = new Map();
            for(const term of terms){
              const search = b64Query([{ id:'name', type:'string', value: term }]);
              let page = 0;
              while(true){
                const data = await httpGet('/api/launch', {
                  page, size: PAGE_SIZE, search,
                  projectId: PROJECT_ID,
                  preview: 'true',
                  sort: 'createdDate,desc'
                }, signal);

                const content = (data && data.content) ? data.content : [];
                if(!content.length) break;
                content.forEach(it => {
                  const id = Number(it && it.id);
                  if(Number.isFinite(id)) byId.set(id, it);
                });
                if(content.length < PAGE_SIZE) break;
                page += 1;
              }
            }
            return Array.from(byId.values());
          }

          async function fetchHBLaunches(version, signal){
            const term = `[High/Blocker][DeployLab] –†–µ–≥—Ä–µ—Å—Å ${version}`;
            const search = b64Query([{ id:'name', type:'string', value: term }]);
            const byId = new Map();
            let page = 0;
            while(true){
              const data = await httpGet('/api/launch', {
                page, size: PAGE_SIZE, search,
                projectId: PROJECT_ID,
                preview: 'true',
                sort: 'createdDate,desc'
              }, signal);

              const content = (data && data.content) ? data.content : [];
              if(!content.length) break;
              content.forEach(it => {
                const id = Number(it && it.id);
                if(Number.isFinite(id)) byId.set(id, it);
              });
              if(content.length < PAGE_SIZE) break;
              page += 1;
            }
            return Array.from(byId.values());
          }

          async function fetchTotalCases(launchId, signal){
            const data = await httpGet(`/api/launch/${launchId}/statistic`, null, signal);
            if(!Array.isArray(data)) return 0;
            return data.reduce((acc, d) => acc + Number(d?.count || 0), 0);
          }

          async function fetchAutomatedTotalCases(launchId, signal, treeId=14){
            const search = b64Query([{ id:'automated', type:'boolean', value: true }]);
            const data = await httpGet('/api/testresulttree/group', {
              launchId, treeId, search,
              sort: 'duration,asc',
              size: PAGE_SIZE
            }, signal);
            const content = (data && data.content) ? data.content : [];
            let total = 0;
            content.forEach(item => {
              const stat = item?.statistic || {};
              total += Number(stat?.total || 0);
            });
            return total;
          }

          const LEAF_PAGE_SIZE = 2000;
          const __cfvCache = new Map();
          const __testResultCoreCache = new Map();
          const __testCaseOverviewCache = new Map();
          const __tcStreamCache = new Map();
          const LS_TC_STREAM_KEY = 'wb_tc_stream_cache_v1';
          let __tcStreamCacheLoaded = false;

          function isStreamFieldName(name){
            const s = String(name || '').toLowerCase();
            return s.includes('stream') || s.includes('—Å—Ç—Ä–∏–º');
          }

          async function fetchTestResultCfv(resultId, signal){
            if(__cfvCache.has(resultId)) return __cfvCache.get(resultId);
            const data = await httpGet(`/api/testresult/${resultId}/cfv`, { v2: true, projectId: PROJECT_ID }, signal);
            __cfvCache.set(resultId, data);
            return data;
          }

          async function fetchTestResultCore(resultId, signal){
            if(__testResultCoreCache.has(resultId)) return __testResultCoreCache.get(resultId);
            const data = await httpGet(`/api/testresult/${resultId}`, null, signal);
            __testResultCoreCache.set(resultId, data);
            return data;
          }

          async function fetchTestCaseOverview(testCaseId, signal){
            const key = String(testCaseId);
            if(__testCaseOverviewCache.has(key)) return __testCaseOverviewCache.get(key);
            const data = await httpGet(`/api/testcase/${key}/overview`, null, signal);
            __testCaseOverviewCache.set(key, data);
            return data;
          }

          function loadTcStreamCache(){
            if(__tcStreamCacheLoaded) return;
            __tcStreamCacheLoaded = true;
            try{
              const raw = localStorage.getItem(LS_TC_STREAM_KEY);
              if(!raw) return;
              const obj = JSON.parse(raw);
              if(!obj || typeof obj !== 'object') return;
              for(const [k,v] of Object.entries(obj)){
                if(k && v) __tcStreamCache.set(String(k), String(v));
              }
            }catch(e){}
          }

          function persistTcStreamCache(){
            try{
              const obj = Object.create(null);
              for(const [k,v] of __tcStreamCache.entries()){
                obj[k] = v;
              }
              localStorage.setItem(LS_TC_STREAM_KEY, JSON.stringify(obj));
            }catch(e){}
          }

          function extractStreamFromCfv(cfvList){
            const list = Array.isArray(cfvList) ? cfvList : [];
            for(const item of list){
              const cfName = item?.customField?.name;
              if(!isStreamFieldName(cfName)) continue;
              const values = item?.values;
              if(Array.isArray(values)){
                for(const v of values){
                  const name = (typeof v === 'string') ? v : v?.name;
                  if(name) return String(name).trim();
                }
              }else if(values && typeof values === 'object' && values.name){
                return String(values.name).trim();
              }else if(typeof values === 'string'){
                return values.trim();
              }
            }
            return '–ë–µ–∑ —Å—Ç—Ä–∏–º–∞';
          }

          function extractStreamFromOverview(overview){
            const list = Array.isArray(overview?.customFields) ? overview.customFields : [];
            for(const item of list){
              const cfName = item?.customField?.name;
              if(!isStreamFieldName(cfName)) continue;
              let v = item?.name;
              if(!v){
                const vals = item?.values;
                if(Array.isArray(vals) && vals.length){
                  const first = vals[0];
                  v = (typeof first === 'string') ? first : first?.name;
                }
              }
              if(v) return String(v).trim();
            }
            return '–ë–µ–∑ —Å—Ç—Ä–∏–º–∞';
          }

          function getLeafResultId(leaf){
            const id = leaf?.testResultId ?? leaf?.resultId ?? leaf?.result?.id ?? leaf?.id;
            return (id == null) ? null : String(id);
          }

          function getLeafTestCaseId(leaf){
            const id = leaf?.testCaseId ?? leaf?.testCase?.id ?? leaf?.testCase?.testCaseId;
            return (id == null) ? null : String(id);
          }

          async function collectStreamCountsByLaunch(launchId, allMap, autoMap, signal){
            loadTcStreamCache();
            let page = 0;
            while(true){
              const data = await httpGet('/api/testresulttree/leaf', {
                launchId,
                sort: 'duration,asc',
                size: LEAF_PAGE_SIZE,
                page
              }, signal);
              const content = (data && data.content) ? data.content : [];
              if(!content.length) break;

              for(const leaf of content){
                const resultId = getLeafResultId(leaf);
                let stream = '–ë–µ–∑ —Å—Ç—Ä–∏–º–∞';
                let testCaseId = getLeafTestCaseId(leaf);
                try{
                  if(testCaseId == null && resultId){
                    const core = await fetchTestResultCore(resultId, signal);
                    testCaseId = core?.testCaseId ?? null;
                  }
                }catch(e){}

                if(testCaseId != null && __tcStreamCache.has(testCaseId)){
                  stream = __tcStreamCache.get(testCaseId);
                }else if(testCaseId != null){
                  try{
                    const overview = await fetchTestCaseOverview(testCaseId, signal);
                    stream = extractStreamFromOverview(overview);
                  }catch(e){
                    stream = '–ë–µ–∑ —Å—Ç—Ä–∏–º–∞';
                  }
                  __tcStreamCache.set(testCaseId, stream);
                }
                allMap.set(stream, (allMap.get(stream) || 0) + 1);
              }

              if(content.length < LEAF_PAGE_SIZE) break;
              page += 1;
            }

            const search = b64Query([{ id:'automated', type:'boolean', value: true }]);
            page = 0;
            while(true){
              const data = await httpGet('/api/testresulttree/leaf', {
                launchId,
                sort: 'duration,asc',
                size: LEAF_PAGE_SIZE,
                page,
                search
              }, signal);
              const content = (data && data.content) ? data.content : [];
              if(!content.length) break;

              for(const leaf of content){
                const resultId = getLeafResultId(leaf);
                let stream = '–ë–µ–∑ —Å—Ç—Ä–∏–º–∞';
                let testCaseId = getLeafTestCaseId(leaf);
                try{
                  if(testCaseId == null && resultId){
                    const core = await fetchTestResultCore(resultId, signal);
                    testCaseId = core?.testCaseId ?? null;
                  }
                }catch(e){}

                if(testCaseId != null && __tcStreamCache.has(testCaseId)){
                  stream = __tcStreamCache.get(testCaseId);
                }else if(testCaseId != null){
                  try{
                    const overview = await fetchTestCaseOverview(testCaseId, signal);
                    stream = extractStreamFromOverview(overview);
                  }catch(e){
                    stream = '–ë–µ–∑ —Å—Ç—Ä–∏–º–∞';
                  }
                  __tcStreamCache.set(testCaseId, stream);
                }
                autoMap.set(stream, (autoMap.get(stream) || 0) + 1);
              }

              if(content.length < LEAF_PAGE_SIZE) break;
              page += 1;
            }
            persistTcStreamCache();
          }

          function buildCountsByStream(allMap, autoMap){
            const out = new Map();
            const streams = new Set([...allMap.keys(), ...autoMap.keys()]);
            for(const s of streams){
              const allCnt = Number(allMap.get(s) || 0);
              const autoCnt = Number(autoMap.get(s) || 0);
              let manualCnt = allCnt - autoCnt;
              if(manualCnt < 0) manualCnt = 0;
              out.set(s, { manual: manualCnt, auto: autoCnt });
            }
            return out;
          }

          function mergeMapOfCounts(target, src){
            for(const [k, v] of src.entries()){
              target.set(k, (target.get(k) || 0) + Number(v || 0));
            }
          }

          function renderTcStreamDeltaTable(rows){
            if(!tcStreamDeltaTbody) return;
            tcStreamDeltaTbody.innerHTML = '';
            if(!rows.length){
              const tr = document.createElement('tr');
              tr.innerHTML = `<td class="mono text-left" colspan="4">–ù–µ—Ç –∏–∑–º–µ–Ω–µ–Ω–∏–π –ø–æ —Å—Ç—Ä–∏–º–∞–º</td>`;
              tcStreamDeltaTbody.appendChild(tr);
              return;
            }
            for(const r of rows){
              const tr = document.createElement('tr');
              const m = Number(r.manualDelta || 0);
              const a = Number(r.autoDelta || 0);
              tr.innerHTML = `
                <td class="mono text-left">${r.release}</td>
                <td class="mono text-left">${r.stream}</td>
                <td class="mono text-center ${m>0?'text-emerald-600':(m<0?'text-rose-600':'text-slate-600')}">${m>0?'+':''}${m}</td>
                <td class="mono text-center ${a>0?'text-emerald-600':(a<0?'text-rose-600':'text-slate-600')}">${a>0?'+':''}${a}</td>
              `;
              tr.dataset.release = r.release;
              tcStreamDeltaTbody.appendChild(tr);
            }
          }

          function populateReleaseSelect(sel, releases){
            if(!sel) return;
            sel.style.display = '';
            sel.innerHTML = '';
            if(!releases || !releases.length){
              const opt = document.createElement('option');
              opt.value = '';
              opt.textContent = '–ù–µ—Ç —Ä–µ–ª–∏–∑–æ–≤';
              opt.disabled = true;
              opt.selected = true;
              sel.appendChild(opt);
              sel.disabled = true;
              return;
            }
            const optAll = document.createElement('option');
            optAll.value = '__all__';
            optAll.textContent = '–≤—ã–±—Ä–∞—Ç—å –≤—Å–µ / —Å–Ω—è—Ç—å –≤—Å–µ';
            sel.appendChild(optAll);
            for(const rel of releases){
              const opt = document.createElement('option');
              opt.value = rel;
              opt.textContent = rel;
              opt.selected = true;
              sel.appendChild(opt);
            }
            sel.disabled = false;
            updateSelectAllState(sel);
          }

          function populateAllReleaseFilters(releases){
            const list = Array.isArray(releases) ? releases : [];
            [
              tcReleaseFilter,
              tcTableReleaseFilter,
              covReleaseFilter,
              selReleaseFilter,
              avgReleaseFilter,
              chpReleaseFilter,
              cutReleaseFilter,
              iosTypesReleaseFilter,
              andTypesReleaseFilter
            ].forEach(sel => populateReleaseSelect(sel, list));
          }

          function getSelectAllOption(sel){
            if(!sel) return null;
            return Array.from(sel.options).find(o => o.value === '__all__') || null;
          }

          function getRealOptions(sel){
            if(!sel) return [];
            return Array.from(sel.options).filter(o => !o.disabled && o.value !== '__all__');
          }

          function updateSelectAllState(sel){
            const optAll = getSelectAllOption(sel);
            if(!optAll) return;
            const opts = getRealOptions(sel);
            const allSelected = opts.length ? opts.every(o => o.selected) : false;
            optAll.selected = allSelected;
          }

          function attachSelectAllToggle(sel){
            if(!sel || sel.dataset.selectAllInit === '1') return;
            sel.dataset.selectAllInit = '1';
            sel.addEventListener('change', () => {
              const optAll = getSelectAllOption(sel);
              if(!optAll) return;
              const opts = getRealOptions(sel);
              if(!opts.length) return;
              const allSelected = opts.every(o => o.selected);
              if(optAll.selected && !allSelected){
                opts.forEach(o => { o.selected = true; });
              }else if(!optAll.selected && allSelected){
                opts.forEach(o => { o.selected = false; });
              }
              updateSelectAllState(sel);
            });
            updateSelectAllState(sel);
          }

          function getSelectedReleasesFromSelect(sel){
            if(!sel) return null;
            const opts = getRealOptions(sel);
            if(!opts.length) return null;
            const selected = opts.filter(o => o.selected).map(o => o.value);
            return selected.length ? new Set(selected) : new Set();
          }

          function applyTbodyReleaseFilter(sel, tbodyEl){
            if(!tbodyEl) return;
            const selected = getSelectedReleasesFromSelect(sel);
            Array.from(tbodyEl.children).forEach(tr => {
              const rel = tr.dataset.release;
              const show = !selected ? true : (selected.size ? (selected.has(rel) || !rel) : false);
              tr.style.display = show ? '' : 'none';
            });
          }

          function applyReleaseFilter(tcRowsAll, deltaRowsAll){
            const selected = getSelectedReleasesFromSelect(tcReleaseFilter);
            const deltas = !selected ? deltaRowsAll.slice() : (selected.size ? deltaRowsAll.filter(r => selected.has(r.release)) : []);
            renderTcStreamDeltaTable(deltas);
          }

          function applyAllReleaseFilters(){
            if(window.__tcRowsAll && window.__tcDeltaRowsAll){
              applyReleaseFilter(window.__tcRowsAll, window.__tcDeltaRowsAll);
            }else{
              applyTbodyReleaseFilter(tcReleaseFilter, tcStreamDeltaTbody);
            }
            applyTbodyReleaseFilter(tcTableReleaseFilter, tbody);
            applyTbodyReleaseFilter(covReleaseFilter, covTbody);
            applyTbodyReleaseFilter(selReleaseFilter, selTbody);
            applyTbodyReleaseFilter(avgReleaseFilter, avgTbody);
            applyTbodyReleaseFilter(chpReleaseFilter, chpTbody);
            applyTbodyReleaseFilter(cutReleaseFilter, cutTbody);
            applyTbodyReleaseFilter(iosTypesReleaseFilter, iosTypesTbody);
            applyTbodyReleaseFilter(andTypesReleaseFilter, andTypesTbody);
          }

          const __memberStatsCache = new Map();
          const __launchDurationCache = new Map();

          async function fetchMemberStats(launchId, signal){
            if(__memberStatsCache.has(launchId)) return __memberStatsCache.get(launchId);
            const data = await httpGet(`/api/launch/${launchId}/memberstats`, { size: 1000, page: 0 }, signal);
            let out;
            if(Array.isArray(data)) out = data;
            else if(data && typeof data === 'object') out = data.content || [];
            else out = [];
            __memberStatsCache.set(launchId, out);
            return out;
          }

          async function fetchLaunchDurationMs(launchId, signal){
            if(__launchDurationCache.has(launchId)) return __launchDurationCache.get(launchId);
            let ms = 0;
            try{
              const d = await httpGet(`/api/launch/${launchId}`, null, signal);
              ms = Number(d?.duration || d?.statistic?.duration || 0) || 0;
            }catch(e){
              ms = 0;
            }
            __launchDurationCache.set(launchId, ms);
            return ms;
          }

          function swatStreamAgg(memberstats, swatSet){
            let swatTotal = 0;
            let streamTotal = 0;
            let swatDur = 0;
            let streamDur = 0;

            const pushStat = (bucket, statItem) => {
              if(!statItem || typeof statItem !== 'object') return;
              const c = Number(statItem.count ?? statItem.total ?? statItem.tests ?? 0) || 0;
              const d = Number(statItem.duration ?? statItem.time ?? 0) || 0;
              if(c > 0) bucket.total += c;
              if(d > 0) bucket.dur += d;
            };

            for(const m of (memberstats || [])){
              if(!m || typeof m !== 'object') continue;
              const assignee = String(m.assignee || '').trim().toLowerCase();

              let total = 0;
              let dur = 0;

              const stat = m.statistic;

              if(Array.isArray(stat)){
                const bucket = { total: 0, dur: 0 };
                for(const s of stat) pushStat(bucket, s);
                total = bucket.total;
                dur = bucket.dur;
              }else if(stat && typeof stat === 'object'){
                const bucket = { total: 0, dur: 0 };
                if(('count' in stat) || ('total' in stat) || ('duration' in stat) || ('time' in stat)){
                  pushStat(bucket, stat);
                }else{
                  for(const v of Object.values(stat)){
                    if(Array.isArray(v)){
                      for(const vv of v) pushStat(bucket, vv);
                    }else{
                      pushStat(bucket, v);
                    }
                  }
                }
                total = bucket.total;
                dur = bucket.dur;
              }

              if(!dur){
                dur = Number(m.durationSum ?? m.duration ?? m.time ?? 0) || 0;
              }

              if(total <= 0) continue;

              if(assignee && swatSet && swatSet.has(assignee)){
                swatTotal += total;
                swatDur += dur;
              }else{
                streamTotal += total;
                streamDur += dur;
              }
            }

            return { swatTotal, streamTotal, swatDur, streamDur };
          }

          function formatMsPerCase(ms){
            const n = Number(ms) || 0;
            if(n <= 0) return '00:00';
            const totalSec = Math.round(n / 1000);
            const h = Math.floor(totalSec / 3600);
            const m = Math.floor((totalSec % 3600) / 60);
            const s = totalSec % 60;
            const mm = String(m).padStart(2,'0');
            const ss = String(s).padStart(2,'0');
            if(h > 0) return `${h}:${mm}:${ss}`;
            return `${mm}:${ss}`;
          }

          function ruPlural(n, one, few, many){
            const num = Math.abs(Number(n) || 0);
            const n100 = num % 100;
            const n10 = num % 10;
            if(n100 >= 11 && n100 <= 19) return many;
            if(n10 === 1) return one;
            if(n10 >= 2 && n10 <= 4) return few;
            return many;
          }

          function memberTotalCount(m){
            if(!m || typeof m !== 'object') return 0;

            const pushStat = (bucket, statItem) => {
              if(!statItem || typeof statItem !== 'object') return;
              const c = Number(statItem.count ?? statItem.total ?? statItem.tests ?? 0) || 0;
              if(c > 0) bucket.total += c;
            };

            let total = 0;
            const stat = m.statistic;

            if(Array.isArray(stat)){
              const bucket = { total: 0 };
              for(const s of stat) pushStat(bucket, s);
              total = bucket.total;
            }else if(stat && typeof stat === 'object'){
              const bucket = { total: 0 };
              if(('count' in stat) || ('total' in stat) || ('tests' in stat)){
                pushStat(bucket, stat);
              }else{
                for(const v of Object.values(stat)){
                  if(Array.isArray(v)){
                    for(const vv of v) pushStat(bucket, vv);
                  }else{
                    pushStat(bucket, v);
                  }
                }
              }
              total = bucket.total;
            }

            if(!total){
              total = Number(m.total ?? m.count ?? 0) || 0;
            }
            return total;
          }

          function extractSwatAssignees(memberstats, swatSet){
            const set = new Set();
            for(const m of (memberstats || [])){
              if(!m || typeof m !== 'object') continue;
              const assignee = String(m.assignee || '').trim().toLowerCase();
              if(!assignee) continue;
              if(!swatSet || !swatSet.has(assignee)) continue;
              const total = memberTotalCount(m);
              if(total > 0) set.add(assignee);
            }
            return set;
          }

          // ---- charts ----
          function ensureChart(){
            if(!chartCanvas || !window.Chart) return;
            if(tcChart){
              tcChart.data.labels = [];
              tcChart.data.datasets.forEach(d => d.data = []);
              tcChart.update();
              return;
            }

            const cManual = cssVar('--tc-manual', '#f59e0b');
            const cAuto   = cssVar('--tc-auto',   '#3b82f6');
            const cTotal  = cssVar('--tc-total',  '#a855f7');

            tcChart = new Chart(chartCanvas, {
              type: 'line',
              data: {
                labels: [],
                datasets: [
                  { label: '–†—É—á–Ω—ã–µ', data: [], borderColor: cManual, backgroundColor: cManual, tension: 0.25, pointRadius: 3, pointHoverRadius: 5 },
                  { label: '–ê–≤—Ç–æ',   data: [], borderColor: cAuto,   backgroundColor: cAuto,   tension: 0.25, pointRadius: 3, pointHoverRadius: 5 },
                  { label: '–í—Å–µ–≥–æ',  data: [], borderColor: cTotal,  backgroundColor: cTotal,  tension: 0.25, pointRadius: 3, pointHoverRadius: 5 }
                ]
              },
              options: {
                maintainAspectRatio: false,
                plugins: {
                  legend: { display: false },
                  deltaLabels: { datasetIndex: 2 },
                  valueLabels: { datasets: [0, 1] },
                  tooltip: {
                    mode: 'index',
                    intersect: false,
                    itemSort: (a, b) => {
                      const av = Number(a?.raw ?? a?.parsed?.y ?? 0);
                      const bv = Number(b?.raw ?? b?.parsed?.y ?? 0);
                      return (bv - av) || ((a.datasetIndex ?? 0) - (b.datasetIndex ?? 0));
                    },
                    callbacks: {
                      title: (items) => {
                        const lbl = items?.[0]?.label;
                        return lbl ? `–†–µ–ª–∏–∑ ${lbl}` : '';
                      },
                      label: (ctx) => {
                        const i = ctx.dataIndex;
                        const total = Number(tcChart?.data?.datasets?.[2]?.data?.[i] || 0);
                        const val = Number(ctx.raw || 0);
                        let pct = 0;
                        if(ctx.datasetIndex === 2) pct = 100;
                        else if(total > 0) pct = Math.round((val / total) * 1000) / 10;
                        return `${ctx.dataset.label}: ${val} | ${pct}%`;
                      }
                    }
                  }
                },
                interaction: { mode: 'index', intersect: false },
                scales: {
                  x: { ticks: { maxRotation: 0, autoSkip: true }, grid: { color: 'rgba(148,163,184,.25)' } },
                  y: { beginAtZero: true, grace: '12%', grid: { color: 'rgba(148,163,184,.25)' } }
                }
              }
            });
          }

          function ensureCoverageChart(){
            if(!covCanvas || !window.Chart) return;
            if(covChart){
              covChart.data.labels = [];
              covChart.data.datasets.forEach(d => d.data = []);
              covChart._swatPeople = [];
              covChart.update();
              return;
            }

            const cSwat   = cssVar('--cov-swat', '#22c55e');
            const cStream = cssVar('--cov-stream', '#f43f5e');

            covChart = new Chart(covCanvas, {
              type: 'line',
              data: {
                labels: [],
                datasets: [
                  { label: 'SWAT',   data: [], borderColor: cSwat,   backgroundColor: cSwat,   tension: 0.25, pointRadius: 3, pointHoverRadius: 5 },
                  { label: 'STREAM', data: [], borderColor: cStream, backgroundColor: cStream, tension: 0.25, pointRadius: 3, pointHoverRadius: 5 }
                ]
              },
              options: {
                maintainAspectRatio: false,
                plugins: {
                  legend: { display: false },
                  deltaLabels: { datasetIndex: 0 },
                  tooltip: {
                    mode: 'index',
                    intersect: false,
                    itemSort: (a, b) => {
                      const av = Number(a?.raw ?? a?.parsed?.y ?? 0);
                      const bv = Number(b?.raw ?? b?.parsed?.y ?? 0);
                      return (bv - av) || ((a.datasetIndex ?? 0) - (b.datasetIndex ?? 0));
                    },
                    callbacks: {
                      title: (items) => {
                        const lbl = items?.[0]?.label;
                        return lbl ? `–†–µ–ª–∏–∑ ${lbl}` : '';
                      },
                      label: (ctx) => {
                        const i = ctx.dataIndex;
                        const sw = Number(covChart.data.datasets[0].data[i] || 0);
                        const st = Number(covChart.data.datasets[1].data[i] || 0);
                        const sum = Math.max(1, sw + st);
                        const val = Number(ctx.raw || 0);
                        const pct = Math.round((val / sum) * 1000) / 10;

                        if(String(ctx.dataset?.label || '') === 'SWAT'){
                          const ppl = Number(covChart._swatPeople?.[i] || 0);
                          const word = ruPlural(ppl, '—Å–æ—Ç—Ä—É–¥–Ω–∏–∫', '—Å–æ—Ç—Ä—É–¥–Ω–∏–∫–∞', '—Å–æ—Ç—Ä—É–¥–Ω–∏–∫–æ–≤');
                          return `${ctx.dataset.label}: ${val} | ${pct}% | ${ppl} ${word}`;
                        }
                        return `${ctx.dataset.label}: ${val} | ${pct}%`;
                      },
                      footer: (items) => {
                        const i = items?.[0]?.dataIndex;
                        const sw = Number(covChart.data.datasets[0].data[i] || 0);
                        const st = Number(covChart.data.datasets[1].data[i] || 0);
                        return `–í—Å–µ–≥–æ: ${sw + st}`;
                      }
                    }
                  }
                },
                interaction: { mode: 'index', intersect: false },
                scales: {
                  x: { bounds: 'data', ticks: { maxRotation: 0, autoSkip: true }, grid: { color: 'rgba(148,163,184,.25)' } },
                  y: { beginAtZero: true, grace: '12%', grid: { color: 'rgba(148,163,184,.25)' } }
                }
              }
            });
          }

          function ensureSelectiveChart(){
            if(!selCanvas || !window.Chart) return;
            if(selChart){
              selChart.data.labels = [];
              selChart.data.datasets.forEach(d => d.data = []);
              selChart._swatPeople = [];
              selChart.update();
              return;
            }

            const cSwat   = cssVar('--cov-swat', '#22c55e');
            const cStream = cssVar('--cov-stream', '#f43f5e');

            selChart = new Chart(selCanvas, {
              type: 'line',
              data: {
                labels: [],
                datasets: [
                  { label: 'SWAT',   data: [], borderColor: cSwat,   backgroundColor: cSwat,   tension: 0.25, pointRadius: 3, pointHoverRadius: 5 },
                  { label: 'STREAM', data: [], borderColor: cStream, backgroundColor: cStream, tension: 0.25, pointRadius: 3, pointHoverRadius: 5 }
                ]
              },
              options: {
                maintainAspectRatio: false,
                plugins: {
                  legend: { display: false },
                  deltaLabels: { datasetIndex: 0 },
                  tooltip: {
                    mode: 'index',
                    intersect: false,
                    itemSort: (a, b) => {
                      const av = Number(a?.raw ?? a?.parsed?.y ?? 0);
                      const bv = Number(b?.raw ?? b?.parsed?.y ?? 0);
                      return (bv - av) || ((a.datasetIndex ?? 0) - (b.datasetIndex ?? 0));
                    },
                    callbacks: {
                      title: (items) => {
                        const lbl = items?.[0]?.label;
                        return lbl ? `–†–µ–ª–∏–∑ ${lbl}` : '';
                      },
                      label: (ctx) => {
                        const i = ctx.dataIndex;
                        const sw = Number(selChart.data.datasets[0].data[i] || 0);
                        const st = Number(selChart.data.datasets[1].data[i] || 0);
                        const sum = Math.max(1, sw + st);
                        const val = Number(ctx.raw || 0);
                        const pct = Math.round((val / sum) * 1000) / 10;

                        if(String(ctx.dataset?.label || '') === 'SWAT'){
                          const ppl = Number(selChart._swatPeople?.[i] || 0);
                          const word = ruPlural(ppl, '—Å–æ—Ç—Ä—É–¥–Ω–∏–∫', '—Å–æ—Ç—Ä—É–¥–Ω–∏–∫–∞', '—Å–æ—Ç—Ä—É–¥–Ω–∏–∫–æ–≤');
                          return `${ctx.dataset.label}: ${val} | ${pct}% | ${ppl} ${word}`;
                        }
                        return `${ctx.dataset.label}: ${val} | ${pct}%`;
                      },
                      footer: (items) => {
                        const i = items?.[0]?.dataIndex;
                        const sw = Number(selChart.data.datasets[0].data[i] || 0);
                        const st = Number(selChart.data.datasets[1].data[i] || 0);
                        return `–í—Å–µ–≥–æ: ${sw + st}`;
                      }
                    }
                  }
                },
                interaction: { mode: 'index', intersect: false },
                scales: {
                  x: { bounds: 'data', ticks: { maxRotation: 0, autoSkip: true }, grid: { color: 'rgba(148,163,184,.25)' } },
                  y: { beginAtZero: true, grace: '12%', grid: { color: 'rgba(148,163,184,.25)' } }
                }
              }
            });
          }

          function ensureAvgChart(){
            if(!avgCanvas || !window.Chart) return;
            if(avgChart){
              avgChart.data.labels = [];
              avgChart.data.datasets.forEach(d => d.data = []);
              avgChart.update();
              return;
            }

            const cSwat   = cssVar('--cov-swat', '#22c55e');
            const cStream = cssVar('--cov-stream', '#f43f5e');
            const cTotal  = cssVar('--tc-total', '#a855f7');

            avgChart = new Chart(avgCanvas, {
              type: 'line',
              data: {
                labels: [],
                datasets: [
                  { label: 'SWAT',   data: [], borderColor: cSwat,   backgroundColor: cSwat,   tension: 0.25, pointRadius: 3, pointHoverRadius: 5 },
                  { label: 'STREAM', data: [], borderColor: cStream, backgroundColor: cStream, tension: 0.25, pointRadius: 3, pointHoverRadius: 5 },
                  { label: '–û–±—â–µ–µ',  data: [], borderColor: cTotal,  backgroundColor: cTotal,  tension: 0.25, pointRadius: 3, pointHoverRadius: 5 }
                ]
              },
              options: {
                maintainAspectRatio: false,
                plugins: {
                  legend: { display: false },
                  tooltip: {
                    mode: 'index',
                    intersect: false,
                    itemSort: (a, b) => {
                      const av = Number(a?.raw ?? a?.parsed?.y ?? 0);
                      const bv = Number(b?.raw ?? b?.parsed?.y ?? 0);
                      return (bv - av) || ((a.datasetIndex ?? 0) - (b.datasetIndex ?? 0));
                    },
                    callbacks: {
                      title: (items) => {
                        const lbl = items?.[0]?.label;
                        return lbl ? `–†–µ–ª–∏–∑ ${lbl}` : '';
                      },
                      label: (ctx) => {
                        const minutes = Number(ctx.raw || 0);
                        const ms = minutes * 60_000;
                        return `${ctx.dataset.label}: ${formatMsPerCase(ms)}`;
                      }
                    }
                  }
                },
                interaction: { mode: 'index', intersect: false },
                scales: {
                  x: { bounds: 'data', ticks: { maxRotation: 0, autoSkip: true }, grid: { color: 'rgba(148,163,184,.25)' } },
                  y: {
                    beginAtZero: true,
                    grid: { color: 'rgba(148,163,184,.25)' },
                    ticks: { callback: (v) => (Number(v) || 0).toFixed(1) }
                  }
                }
              }
            });
          }

          function ensureChpChart(){
            if(!chpCanvas || !window.Chart) return;
            if(chpChart){
              chpChart.data.labels = [];
              chpChart.data.datasets.forEach(d => d.data = []);
              chpChart.update();
              return;
            }
            const cIos = cssVar('--chp-ios', '#0ea5e9');
            const cAnd = cssVar('--chp-android', '#22c55e');
            const cTot = cssVar('--chp-total', '#a855f7');

            chpChart = new Chart(chpCanvas, {
              type: 'line',
              data: {
                labels: [],
                datasets: [
                  { label: 'iOS', data: [], borderColor: cIos, backgroundColor: cIos, tension: 0.25, pointRadius: 3, pointHoverRadius: 5 },
                  { label: 'Android', data: [], borderColor: cAnd, backgroundColor: cAnd, tension: 0.25, pointRadius: 3, pointHoverRadius: 5 },
                  { label: '–í—Å–µ–≥–æ', data: [], borderColor: cTot, backgroundColor: cTot, tension: 0.25, pointRadius: 3, pointHoverRadius: 5 }
                ]
              },
              options: {
                maintainAspectRatio: false,
                plugins: {
                  legend: { display: false },
                  deltaLabels: { datasetIndex: 2 },
                  tooltip: {
                    mode: 'index',
                    intersect: false,
                    itemSort: (a, b) => {
                      const av = Number(a?.raw ?? a?.parsed?.y ?? 0);
                      const bv = Number(b?.raw ?? b?.parsed?.y ?? 0);
                      return (bv - av) || ((a.datasetIndex ?? 0) - (b.datasetIndex ?? 0));
                    },
                    callbacks: {
                      title: (items) => {
                        const lbl = items?.[0]?.label;
                        return lbl ? `–†–µ–ª–∏–∑ ${lbl}` : '';
                      }
                    }
                  }
                },
                interaction: { mode: 'index', intersect: false },
                scales: {
                  x: { bounds: 'data', ticks: { maxRotation: 0, autoSkip: true }, grid: { color: 'rgba(148,163,184,.25)' } },
                  y: { beginAtZero: true, grace: '12%', grid: { color: 'rgba(148,163,184,.25)' } }
                }
              }
            });
          }

          function ensureCutChart(){
            if(!cutCanvas || !window.Chart) return;
            if(cutChart){
              cutChart.data.labels = [];
              cutChart.data.datasets.forEach(d => {
                d.data = [];
                d._timeLabel = [];
                d._timeMs = [];
                d._lastChpLabel = [];
              });
              cutChart.update();
              return;
            }

            const cIosCut  = cssVar('--cut-ios-cutoff', '#1d4ed8');
            const cIosSt   = cssVar('--cut-ios-store',  '#7c3aed');
            const cAndCut  = cssVar('--cut-android-cutoff', '#22c55e');
            const cAndSt   = cssVar('--cut-android-store',  '#f59e0b');

            const makeDs = (label, color) => ({
              label,
              data: [],
              borderColor: color,
              backgroundColor: color,
              tension: 0.25,
              pointRadius: 3,
              pointHoverRadius: 5,
              spanGaps: true,
              _timeLabel: [],
              _timeMs: [],
              _lastChpLabel: []
            });

            cutChart = new Chart(cutCanvas, {
              type: 'line',
              data: {
                labels: [],
                datasets: [
                  makeDs('iOS Cutoff', cIosCut),
                  makeDs('Android Cutoff', cAndCut),
                  makeDs('iOS Store', cIosSt),
                  makeDs('Android Store', cAndSt),
                ]
              },
              options: {
                maintainAspectRatio: false,
                plugins: {
                  legend: { display: false },
                  cutTimeLabels: {
                    targetMinutes: CUT_TARGET_MINUTES.ios,
                    windowMinutes: CUT_TARGET_WINDOW_MIN,
                    onColor: cssVar('--green', '#22c55e'),
                    lateColor: cssVar('--red', '#f43f5e')
                  },
                  tooltip: {
                    mode: 'index',
                    intersect: false,
                    // –°–ù–ê–ß–ê–õ–ê cutoff (—Ä–∞–Ω—å—à–µ ‚Äî –≤—ã—à–µ), –ü–û–¢–û–ú store (—Ä–∞–Ω—å—à–µ ‚Äî –≤—ã—à–µ)
                    itemSort: (a, b) => {
                      const la = String(a?.dataset?.label || '');
                      const lb = String(b?.dataset?.label || '');
                      const kindA = la.includes('Cutoff') ? 0 : 1;
                      const kindB = lb.includes('Cutoff') ? 0 : 1;
                      if(kindA !== kindB) return kindA - kindB;

                      const dsA = cutChart.data.datasets[a.datasetIndex];
                      const dsB = cutChart.data.datasets[b.datasetIndex];
                      const ta = Number(dsA?._timeMs?.[a.dataIndex]);
                      const tb = Number(dsB?._timeMs?.[b.dataIndex]);

                      const aInf = Number.isFinite(ta) ? ta : Number.POSITIVE_INFINITY;
                      const bInf = Number.isFinite(tb) ? tb : Number.POSITIVE_INFINITY;
                      const diff = aInf - bInf;
                      return diff || ((a.datasetIndex ?? 0) - (b.datasetIndex ?? 0));
                    },
                    callbacks: {
                      title: (items) => {
                        const lbl = items?.[0]?.label;
                        return lbl ? `–†–µ–ª–∏–∑ ${lbl}` : '';
                      },
                      label: (ctx) => {
                        const ds = cutChart.data.datasets[ctx.datasetIndex];
                        let txt = ds?._timeLabel?.[ctx.dataIndex] || '-';
                        const last = ds?._lastChpLabel?.[ctx.dataIndex] || '';
                        if(last && String(ctx.dataset?.label || '').includes('Store')){
                          txt += ` | –ü–æ—Å–ª–µ–¥–Ω–∏–π –ß–ü ${last}`;
                        }
                        return `${ctx.dataset.label}: ${txt}`;
                      }
                    }
                  }
                },
                interaction: { mode: 'index', intersect: false },
                scales: {
                  x: {
                    bounds: 'data',
                    ticks: { maxRotation: 0, autoSkip: true },
                    grid: { color: 'rgba(148,163,184,.25)' }
                  },
                  y: {
                    min: 12 * 60,
                    max: 22 * 60,
                    reverse: false,
                    grid: { color: 'rgba(148,163,184,.25)' },
                    ticks: {
                      stepSize: 120,
                      callback: (v) => {
                        const vv = Math.round(Number(v) || 0);
                        const hh = Math.floor(vv / 60);
                        const mm = vv % 60;
                        return `${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}`;
                      }
                    }
                  }
                }
              }
            });
          }

          function addChartPoint(release, manual, auto, total){
            if(!tcChart) return;
            tcChart.data.labels.push(release);
            tcChart.data.datasets[0].data.push(manual);
            tcChart.data.datasets[1].data.push(auto);
            tcChart.data.datasets[2].data.push(total);
            tcChart.update();
          }

          function addCoveragePoint(release, swatCount, streamCount, swatPeopleCount){
            if(!covChart) return;
            covChart.data.labels.push(release);
            covChart.data.datasets[0].data.push(swatCount);
            covChart.data.datasets[1].data.push(streamCount);
            if(!Array.isArray(covChart._swatPeople)) covChart._swatPeople = [];
            covChart._swatPeople.push(Number(swatPeopleCount) || 0);
            covChart.update();
          }

          function addSelectivePoint(release, swatCount, streamCount, swatPeopleCount){
            if(!selChart) return;
            selChart.data.labels.push(release);
            selChart.data.datasets[0].data.push(swatCount);
            selChart.data.datasets[1].data.push(streamCount);
            if(!Array.isArray(selChart._swatPeople)) selChart._swatPeople = [];
            selChart._swatPeople.push(Number(swatPeopleCount) || 0);
            selChart.update();
          }

          function addAvgPoint(release, swatMin, streamMin, totalMin){
            if(!avgChart) return;
            avgChart.data.labels.push(release);
            avgChart.data.datasets[0].data.push(swatMin);
            avgChart.data.datasets[1].data.push(streamMin);
            avgChart.data.datasets[2].data.push(totalMin);
            avgChart.update();
          }

          function addChpPoint(release, ios, android, total){
            if(!chpChart) return;
            chpChart.data.labels.push(release);
            chpChart.data.datasets[0].data.push(ios);
            chpChart.data.datasets[1].data.push(android);
            chpChart.data.datasets[2].data.push(total);
            chpChart.update();
          }

          function addCutPoint(release, dsIndex, yObjOrNull){
            if(!cutChart) return;
            if(cutChart.data.labels.length === 0 || cutChart.data.labels[cutChart.data.labels.length - 1] !== release){
              cutChart.data.labels.push(release);
              // –¥–ª—è –≤—Å–µ—Ö –¥–∞—Ç–∞—Å–µ—Ç–æ–≤ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ–º –¥–ª–∏–Ω—ã (–µ—Å–ª–∏ –Ω—É–∂–Ω–æ)
              for(const ds of cutChart.data.datasets){
                while(ds.data.length < cutChart.data.labels.length - 1){
                  ds.data.push(null);
                  ds._timeLabel.push('');
                  ds._timeMs.push(null);
                  ds._lastChpLabel.push('');
                }
              }
            }
            const di = cutChart.data.labels.length - 1;
            const ds = cutChart.data.datasets[dsIndex];

            // ensure arrays length
            while(ds.data.length < di){ ds.data.push(null); ds._timeLabel.push(''); ds._timeMs.push(null);
                  ds._lastChpLabel.push(''); }

            if(!yObjOrNull){
              ds.data.push(null);
              ds._timeLabel.push('');
              ds._timeMs.push(null);
                  ds._lastChpLabel.push('');
            }else{
              ds.data.push(yObjOrNull.y);
              ds._timeLabel.push(yObjOrNull.label);
              ds._timeMs.push(yObjOrNull.msLocal);
              ds._lastChpLabel.push(yObjOrNull.lastChp || '');
            }
          }

          // ---- —Ç–∞–±–ª–∏—Ü—ã (—Ä–µ–Ω–¥–µ—Ä) ----
          function renderRow({release, manual, auto, total}){
            const max = Math.max(total, 1);
            const pctM = Math.round((manual / max) * 100);
            const pctA = Math.round((auto / max) * 100);
            const pctT = 100;

            const tr = document.createElement('tr');
            tr.dataset.release = release;
            tr.innerHTML = `
              <td class="mono text-left">${release}</td>
              <td class="mono">${manual}</td>
              <td class="mono">${auto}</td>
              <td class="mono">${total}</td>
              <td class="text-left">
                <div class="space-y-2 min-w-[260px]">
                  <div class="flex items-center gap-2">
                    <span class="text-xs text-slate-500 w-14">–†—É—á–Ω—ã–µ</span>
                    <div class="bar flex-1"><div class="bar-fill bar-fill-manual" style="width:${pctM}%"></div></div>
                    <span class="mono text-xs w-10 text-right">${manual}</span>
                  </div>
                  <div class="flex items-center gap-2">
                    <span class="text-xs text-slate-500 w-14">–ê–≤—Ç–æ</span>
                    <div class="bar flex-1"><div class="bar-fill bar-fill-auto" style="width:${pctA}%"></div></div>
                    <span class="mono text-xs w-10 text-right">${auto}</span>
                  </div>
                  <div class="flex items-center gap-2">
                    <span class="text-xs text-slate-500 w-14">–í—Å–µ–≥–æ</span>
                    <div class="bar flex-1"><div class="bar-fill bar-fill-total" style="width:${pctT}%"></div></div>
                    <span class="mono text-xs w-10 text-right">${total}</span>
                  </div>
                </div>
              </td>
            `;
            tbody.appendChild(tr);
          }

          function renderCovRow({release, swatCount, swatPeople, streamCount}){
            const sum = (Number(swatCount) || 0) + (Number(streamCount) || 0);
            const swPct = sum ? (Math.round(((Number(swatCount)||0) / sum) * 1000) / 10) : 0;
            const stPct = sum ? (Math.round(((Number(streamCount)||0) / sum) * 1000) / 10) : 0;
            const tr2 = document.createElement('tr');
            tr2.dataset.release = release;
            tr2.innerHTML = `
              <td class="mono text-left">${release}</td>
              <td class="mono">${swatCount}</td>
              <td class="mono">${Number(swatPeople || 0)}</td>
              <td class="mono">${streamCount}</td>
              <td class="mono">${sum}</td>
              <td class="text-left"><span class="mono">SWAT ${swPct}%</span> ¬∑ <span class="mono">STREAM ${stPct}%</span></td>
            `;
            covTbody.appendChild(tr2);
          }

          function renderSelRow({release, swatCount, swatPeople, streamCount}){
            const sum = (Number(swatCount) || 0) + (Number(streamCount) || 0);
            const swPct = sum ? (Math.round(((Number(swatCount)||0) / sum) * 1000) / 10) : 0;
            const stPct = sum ? (Math.round(((Number(streamCount)||0) / sum) * 1000) / 10) : 0;
            const tr2 = document.createElement('tr');
            tr2.dataset.release = release;
            tr2.innerHTML = `
              <td class="mono text-left">${release}</td>
              <td class="mono">${swatCount}</td>
              <td class="mono">${Number(swatPeople || 0)}</td>
              <td class="mono">${streamCount}</td>
              <td class="mono">${sum}</td>
              <td class="text-left"><span class="mono">SWAT ${swPct}%</span> ¬∑ <span class="mono">STREAM ${stPct}%</span></td>
            `;
            selTbody.appendChild(tr2);
          }

          function renderAvgRow({release, swatMs, streamMs, totalMs}){
            const tr = document.createElement('tr');
            tr.dataset.release = release;
            tr.innerHTML = `
              <td class="mono text-left">${release}</td>
              <td class="mono">${formatMsPerCase(swatMs)}</td>
              <td class="mono">${formatMsPerCase(streamMs)}</td>
              <td class="mono">${formatMsPerCase(totalMs)}</td>
            `;
            avgTbody.appendChild(tr);
          }

          const CUT_TARGET_MINUTES = {
            ios: 14 * 60,
            android: 14 * 60
          };
          const CUT_TARGET_WINDOW_MIN = 5;

          function parseLabelTimeMinutes(label){
            if(!label) return null;
            const m = String(label).match(/(\d{2}):(\d{2})$/);
            if(!m) return null;
            return Number(m[1]) * 60 + Number(m[2]);
          }

          function formatCutLabel(label, targetMinutes){
            if(!label) return { html: '-', status: null };
            const raw = String(label);
            const timeMatch = raw.match(/(\d{2}:\d{2})$/);
            if(!timeMatch) return { html: raw, status: null };
            const timeText = timeMatch[1];
            const baseText = raw.replace(/\s\d{2}:\d{2}$/, '');
            const minutes = parseLabelTimeMinutes(raw);
            let status = null;
            let note = '';
            if(Number.isFinite(minutes)){
              if(minutes >= targetMinutes && minutes <= targetMinutes + CUT_TARGET_WINDOW_MIN){
                status = 'cut-on';
                note = ' (—Å—Ç–∞—Ä—Ç –≤–æ–≤—Ä–µ–º—è)';
              }else{
                status = 'cut-late';
                note = ' (—Å—Ç–∞—Ä—Ç –ø–æ–∑–∂–µ)';
              }
            }
            const timeHtml = status ? `<span class="cut-time ${status}">${timeText}</span>` : `<span class="cut-time">${timeText}</span>`;
            const noteHtml = status ? `<span class="cut-note ${status}">${note}</span>` : '';
            const lead = baseText ? `${baseText} ` : '';
            return { html: `${lead}${timeHtml}${noteHtml}`, status };
          }

          function renderCutRow({release, iosCut, iosStore, andCut, andStore}){
            const tr = document.createElement('tr');
            const iosFmt = formatCutLabel(iosCut, CUT_TARGET_MINUTES.ios);
            const andFmt = formatCutLabel(andCut, CUT_TARGET_MINUTES.android);
            tr.dataset.release = release;
            tr.innerHTML = `
              <td class="mono text-left">${release}</td>
              <td class="mono cut-cell ${iosFmt.status || ''}">${iosFmt.html}</td>
              <td class="mono">${iosStore || ''}</td>
              <td class="mono cut-cell ${andFmt.status || ''}">${andFmt.html}</td>
              <td class="mono">${andStore || ''}</td>
            `;
            cutTbody.appendChild(tr);
          }

          // ---- concurrency ----
          async function asyncPool(items, concurrency, iterator, signal){
            const results = [];
            let i = 0;
            const workers = Array.from({length: Math.max(1, concurrency)}, async () => {
              while(i < items.length){
                if(signal?.aborted) return;
                const idx = i++;
                results[idx] = await iterator(items[idx], idx);
              }
            });
            await Promise.all(workers);
            return results;
          }

          // ---- collapsers ----
          function initCollapsers(){
            let state = {};
            try{ state = JSON.parse(localStorage.getItem(LS_COLLAPSE_KEY) || '{}') || {}; }catch(e){ state = {}; }

            function save(){
              try{ localStorage.setItem(LS_COLLAPSE_KEY, JSON.stringify(state)); }catch(e){}
            }

            function animateBody(body, collapse){
              const dur = 180;
              body.style.overflow = 'hidden';
              body.style.transition = `height ${dur}ms ease, opacity ${dur}ms ease`;

              if(collapse){
                body.style.display = '';
                const h = body.getBoundingClientRect().height;
                body.style.height = h + 'px';
                body.style.opacity = '1';
                requestAnimationFrame(() => {
                  body.style.height = '0px';
                  body.style.opacity = '0';
                });
                const onEnd = (ev) => {
                  if(ev.propertyName !== 'height') return;
                  body.removeEventListener('transitionend', onEnd);
                  body.style.display = 'none';
                  body.style.height = '';
                  body.style.opacity = '';
                  body.style.overflow = '';
                  body.style.transition = '';
                };
                body.addEventListener('transitionend', onEnd);
              }else{
                body.style.display = '';
                const h = body.scrollHeight;
                body.style.height = '0px';
                body.style.opacity = '0';
                requestAnimationFrame(() => {
                  body.style.height = h + 'px';
                  body.style.opacity = '1';
                });
                const onEnd = (ev) => {
                  if(ev.propertyName !== 'height') return;
                  body.removeEventListener('transitionend', onEnd);
                  body.style.height = '';
                  body.style.opacity = '';
                  body.style.overflow = '';
                  body.style.transition = '';
                };
                body.addEventListener('transitionend', onEnd);
              }
            }

            function resizeChartsForKey(key){
              try{
                if(key === 'tc') tcChart?.resize();
                if(key === 'cov') covChart?.resize();
                if(key === 'sel') selChart?.resize();
                if(key === 'avg') avgChart?.resize();
                if(key === 'chp') chpChart?.resize();
                if(key === 'cut') cutChart?.resize();
                if(key === 'iosTypes') iosTypesChart?.resize();
                if(key === 'andTypes') andTypesChart?.resize();
              }catch(e){}
            }

            const btns = document.querySelectorAll('[data-collapse-btn]');
            btns.forEach(btn => {
              const key = btn.getAttribute('data-collapse-btn');
              const section = btn.closest('section');
              if(!section) return;
              const body = section.querySelector(`[data-collapse-body="${key}"]`);
              if(!body) return;

              const ico = btn.querySelector('[data-collapse-ico]');
              const txt = btn.querySelector('[data-collapse-text]');

              let collapsed = !!state[key];

              const applyInstant = () => {
                body.style.display = collapsed ? 'none' : '';
                btn.setAttribute('aria-expanded', collapsed ? 'false' : 'true');
                if(ico) ico.textContent = collapsed ? '‚ñ∏' : '‚ñæ';
                if(txt) txt.textContent = collapsed ? '–†–∞–∑–≤–µ—Ä–Ω—É—Ç—å' : '–°–≤–µ—Ä–Ω—É—Ç—å';
              };

              applyInstant();

              btn.addEventListener('click', () => {
                collapsed = !collapsed;
                state[key] = collapsed;
                save();

                btn.setAttribute('aria-expanded', collapsed ? 'false' : 'true');
                if(ico) ico.textContent = collapsed ? '‚ñ∏' : '‚ñæ';
                if(txt) txt.textContent = collapsed ? '–†–∞–∑–≤–µ—Ä–Ω—É—Ç—å' : '–°–≤–µ—Ä–Ω—É—Ç—å';

                animateBody(body, collapsed);
                if(!collapsed){
                  requestAnimationFrame(() => requestAnimationFrame(() => resizeChartsForKey(key)));
                }
              });
            });
          }

          function initToggles(){
            document.querySelectorAll('[data-toggle]').forEach(btn => {
              const key = btn.getAttribute('data-toggle');
              const body = document.querySelector(`[data-toggle-body="${key}"]`);
              if(!body) return;
              btn.addEventListener('click', () => {
                const isHidden = body.style.display === 'none';
                body.style.display = isHidden ? '' : 'none';
                btn.setAttribute('aria-expanded', isHidden ? 'true' : 'false');
                const ico = btn.querySelector('span[aria-hidden="true"]');
                if(ico) ico.textContent = isHidden ? '‚ñæ' : '‚ñ∏';
                try{ tcChart?.resize(); }catch(e){}
              });
            });
          }

          // ---- RUN ----
          async function run(){
            validateAndNormalizeReleaseInput(inpFrom);
            validateAndNormalizeReleaseInput(inpTo);
            saveInputs();
            clear();

            const tok = (inpAllureToken?.value || '').trim();
            if(!tok){
              showEmpty('–í—Å—Ç–∞–≤—å—Ç–µ API —Ç–æ–∫–µ–Ω Allure');
              return;
            }

            const releases = buildMajorRange();
            if(!releases.length){
              showEmpty('–£–∫–∞–∂–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –¥–∏–∞–ø–∞–∑–æ–Ω (–Ω–∞–ø—Ä–∏–º–µ—Ä 7.4.1000 ‚Üí 7.4.4000 –∏–ª–∏ 7.3.7 ‚Üí 7.4.2)');
              return;
            }
            populateAllReleaseFilters(releases);

            ensureChart();
            ensureCoverageChart();
            ensureSelectiveChart();
            ensureAvgChart();
            ensureChpChart();
            ensureCutChart();

            showContent();
            showCovContent();
            showSelContent();
            showAvgContent();
            showChpContent();
            showCutContent();
            showIosTypesContent();
            showAndTypesContent();

            const signal = window.__wbAbortController?.signal;

            tbody.innerHTML = '<tr><td class="mono text-left" colspan="5">–°–±–æ—Ä –¥–∞–Ω–Ω—ã—Ö‚Ä¶</td></tr>';

            const LAUNCH_CONCURRENCY = 1000;
            const STREAM_CONCURRENCY = 40;

            const tcRowsData = [];
            const covRowsData = [];
            const selRowsData = [];
            const avgRowsData = [];
            const tcStreamByRelease = [];
            let tcStreamDeltaRowsAll = [];

            let firstRow = true;

            for(const rel of releases){
              if(signal?.aborted) break;

              let swatInfo;
              try{
                swatInfo = await fetchSwatLogins(rel, signal);
              }catch(e){
                showEmpty(`–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å–ø–∏—Å–∫–∞ SWAT –¥–ª—è —Ä–µ–ª–∏–∑–∞ ${rel}: ${e?.message || e}`);
                return;
              }
              const swatSet = swatInfo.set;
              const swatPeopleDeclared = Number(swatInfo.total || 0) || 0;

              let total = 0;
              let manual = 0;
              let auto  = 0;

              // 1) Manual/Auto/Total: –ø–æ Smoke+Selective
              const launchMapAll = new Map();
              for(const kind of KINDS){
                const launches = await fetchLaunches(rel, kind, signal);
                for(const l of launches){
                  const id = Number(l?.id);
                  if(Number.isFinite(id)) launchMapAll.set(id, id);
                }
              }
              const idsAll = Array.from(launchMapAll.keys());

              // AVG TIME: memberstats (counts+durations)
              let avgSwatCnt = 0, avgStreamCnt = 0;
              let avgSwatDur = 0, avgStreamDur = 0;

              const perAvg = await asyncPool(idsAll, LAUNCH_CONCURRENCY, async (id) => {
                const ms = await fetchMemberStats(id, signal);
                const agg = swatStreamAgg(ms, swatSet);

                if((agg.swatDur + agg.streamDur) <= 0){
                  const launchDur = await fetchLaunchDurationMs(id, signal);
                  const totalCnt = Math.max(1, (agg.swatTotal + agg.streamTotal));
                  const swShare = (agg.swatTotal || 0) / totalCnt;
                  const stShare = (agg.streamTotal || 0) / totalCnt;
                  agg.swatDur = launchDur * swShare;
                  agg.streamDur = launchDur * stShare;
                }
                return agg;
              }, signal);

              for(const r of perAvg){
                if(!r) continue;
                avgSwatCnt += Number(r.swatTotal || 0);
                avgStreamCnt += Number(r.streamTotal || 0);
                avgSwatDur += Number(r.swatDur || 0);
                avgStreamDur += Number(r.streamDur || 0);
              }

              const avgTotalCnt = avgSwatCnt + avgStreamCnt;
              const avgTotalDur = avgSwatDur + avgStreamDur;

              const swatMsPerCase = avgSwatCnt ? (avgSwatDur / avgSwatCnt) : 0;
              const streamMsPerCase = avgStreamCnt ? (avgStreamDur / avgStreamCnt) : 0;
              const totalMsPerCase = avgTotalCnt ? (avgTotalDur / avgTotalCnt) : 0;

              addAvgPoint(rel, swatMsPerCase/60000, streamMsPerCase/60000, totalMsPerCase/60000);
              if(avgTbody){
                renderAvgRow({ release: rel, swatMs: swatMsPerCase, streamMs: streamMsPerCase, totalMs: totalMsPerCase });
              }
              avgRowsData.push({ release: rel, swatMs: swatMsPerCase, streamMs: streamMsPerCase, totalMs: totalMsPerCase, total: totalMsPerCase });

              // 2) SWAT/STREAM –•–ë: —Ç–æ–ª—å–∫–æ HB –ª–∞—É–Ω—á–∏, memberstats
              let swatCount = 0;
              let streamCount = 0;

              const hbLaunches = await fetchHBLaunches(rel, signal);
              const idsHB = hbLaunches.map(l => Number(l?.id)).filter(id => Number.isFinite(id));

              const perHB = await asyncPool(idsHB, LAUNCH_CONCURRENCY, async (id) => {
                const ms = await fetchMemberStats(id, signal);
                const agg = swatStreamAgg(ms, swatSet);
                const ppl = extractSwatAssignees(ms, swatSet);
                return { agg, ppl: Array.from(ppl) };
              }, signal);

              const swatPeopleSetHB = new Set();
              for(const r of perHB){
                if(!r) continue;
                const agg = r.agg || r;
                swatCount += Number(agg.swatTotal || 0);
                streamCount += Number(agg.streamTotal || 0);
                if(Array.isArray(r.ppl)){
                  for(const a of r.ppl){
                    if(a) swatPeopleSetHB.add(String(a));
                  }
                }
              }
              const swatPeopleHB = swatPeopleDeclared;

              // 3) SWAT/STREAM Selective (—Ç–æ–ª—å–∫–æ Selective)
              const selLaunches = await fetchLaunches(rel, 'Selective', signal);
              const selIds = selLaunches.map(l => Number(l?.id)).filter(id => Number.isFinite(id));
              let selSwat = 0;
              let selStream = 0;

              const perSel = await asyncPool(selIds, LAUNCH_CONCURRENCY, async (id) => {
                const ms = await fetchMemberStats(id, signal);
                const agg = swatStreamAgg(ms, swatSet);
                const ppl = extractSwatAssignees(ms, swatSet);
                return { agg, ppl: Array.from(ppl) };
              }, signal);

              const swatPeopleSetSel = new Set();
              for(const r of perSel){
                if(!r) continue;
                const agg = r.agg || r;
                selSwat += Number(agg.swatTotal || 0);
                selStream += Number(agg.streamTotal || 0);
                if(Array.isArray(r.ppl)){
                  for(const a of r.ppl){
                    if(a) swatPeopleSetSel.add(String(a));
                  }
                }
              }
              const swatPeopleSel = swatPeopleDeclared;

              // 1) TOTAL/AUTO
              const perLaunchAll = await asyncPool(idsAll, LAUNCH_CONCURRENCY, async (id) => {
                const [t, a] = await Promise.all([
                  fetchTotalCases(id, signal),
                  fetchAutomatedTotalCases(id, signal)
                ]);
                return { t: Number(t||0), a: Number(a||0) };
              }, signal);

              for(const r of perLaunchAll){
                if(!r) continue;
                total += r.t;
                auto  += r.a;
              }
              manual = Math.max(0, total - auto);

              // Stream deltas for Manual/AT (by customField.values.name)
              if(idsAll.length){
                const allMap = new Map();
                const autoMap = new Map();
                const perStream = await asyncPool(idsAll, STREAM_CONCURRENCY, async (id) => {
                  const mAll = new Map();
                  const mAuto = new Map();
                  await collectStreamCountsByLaunch(id, mAll, mAuto, signal);
                  return { all: mAll, auto: mAuto };
                }, signal);
                for(const r of perStream){
                  if(!r) continue;
                  mergeMapOfCounts(allMap, r.all || new Map());
                  mergeMapOfCounts(autoMap, r.auto || new Map());
                }
                tcStreamByRelease.push({ release: rel, counts: buildCountsByStream(allMap, autoMap) });
              }else{
                tcStreamByRelease.push({ release: rel, counts: new Map() });
              }

              // –ß–µ—Ä–µ–ø–∏–∫–∏ (deploy-lab issues) ‚Äî —á–µ—Ä–µ–∑ –ø—Ä–æ–∫—Å–∏
              let chpIos = 0;
              let chpAndroid = 0;
              try{
                [chpIos, chpAndroid] = await Promise.all([
                  fetchDeployIssueCount('IOS', rel, signal),
                  fetchDeployIssueCount('ANDROID', rel, signal)
                ]);
              }catch(e){}
              const chpTotal = (Number(chpIos)||0) + (Number(chpAndroid)||0);
              if(chpTbody){
                const tr = document.createElement('tr');
                tr.dataset.release = rel;
                tr.innerHTML = `
                  <td class="mono text-left">${rel}</td>
                  <td class="mono">${chpIos}</td>
                  <td class="mono">${chpAndroid}</td>
                  <td class="mono">${chpTotal}</td>
                `;
                chpTbody.appendChild(tr);
              }
              addChpPoint(rel, chpIos, chpAndroid, chpTotal);

              // Cutoff/Store (deploy-lab base+deploy)
              let iosCutLbl = null, iosStoreLbl = null, andCutLbl = null, andStoreLbl = null;

              try{
                const [ios, andr, lastChpIos, lastChpAndr] = await Promise.all([
                  fetchDeployDates('IOS', rel, signal),
                  fetchDeployDates('ANDROID', rel, signal),
                  fetchLastCherepik('IOS', rel, signal),
                  fetchLastCherepik('ANDROID', rel, signal),
                ]);

                const iosCut = yValueFromIsoCut(ios.cutoff);
                const andCut = yValueFromIsoCut(andr.cutoff);

                const iosStore = yValueFromMsLocalCut(ios.storeMsLocal);
                if(iosStore) iosStore.lastChp = lastChpIos || '';

                const andStore = yValueFromMsLocalCut(andr.storeMsLocal);
                if(andStore) andStore.lastChp = lastChpAndr || '';

                addCutPoint(rel, 0, iosCut);
                addCutPoint(rel, 1, andCut);
                addCutPoint(rel, 2, iosStore);
                addCutPoint(rel, 3, andStore);

                iosCutLbl = iosCut?.label || null;
                andCutLbl = andCut?.label || null;
                iosStoreLbl = iosStore?.label || null;
                andStoreLbl = andStore?.label || null;
              }catch(e){
                addCutPoint(rel, 0, null);
                addCutPoint(rel, 1, null);
                addCutPoint(rel, 2, null);
                addCutPoint(rel, 3, null);
              }

              if(cutTbody){
                renderCutRow({ release: rel, iosCut: iosCutLbl, iosStore: iosStoreLbl, andCut: andCutLbl, andStore: andStoreLbl });
              }
              cutChart?.update();

              if(firstRow){
                tbody.innerHTML = '';
                firstRow = false;
              }

              renderRow({ release: rel, manual, auto, total });
              addChartPoint(rel, manual, auto, total);
              tcRowsData.push({ release: rel, manual, auto, total });

              if(covTbody){
                renderCovRow({ release: rel, swatCount, swatPeople: swatPeopleHB, streamCount });
              }
              covRowsData.push({ release: rel, swatCount, swatPeople: swatPeopleHB, streamCount, total: (swatCount + streamCount) });
              addCoveragePoint(rel, swatCount, streamCount, swatPeopleHB);

              if(selTbody){
                renderSelRow({ release: rel, swatCount: selSwat, swatPeople: swatPeopleSel, streamCount: selStream });
              }
              selRowsData.push({ release: rel, swatCount: selSwat, swatPeople: swatPeopleSel, streamCount: selStream, total: (selSwat + selStream) });
              addSelectivePoint(rel, selSwat, selStream, swatPeopleSel);
            }

            if(tcStreamByRelease.length){
              const deltaRows = [];
              for(let i=1;i<tcStreamByRelease.length;i++){
                const prev = tcStreamByRelease[i-1];
                const curr = tcStreamByRelease[i];
                const streams = new Set([
                  ...Array.from(prev.counts.keys()),
                  ...Array.from(curr.counts.keys())
                ]);
                for(const s of streams){
                  const p = prev.counts.get(s) || { manual: 0, auto: 0 };
                  const c = curr.counts.get(s) || { manual: 0, auto: 0 };
                  const md = Number(c.manual||0) - Number(p.manual||0);
                  const ad = Number(c.auto||0) - Number(p.auto||0);
                  if(md === 0 && ad === 0) continue;
                  deltaRows.push({ release: curr.release, stream: s, manualDelta: md, autoDelta: ad });
                }
              }
              tcStreamDeltaRowsAll = deltaRows.slice();
            }

            window.__tcRowsAll = tcRowsData.slice();
            window.__tcDeltaRowsAll = tcStreamDeltaRowsAll.slice();
            populateAllReleaseFilters(releases);
            applyAllReleaseFilters();

            // –¢–∏–ø—ã –∑–∞–¥–∞—á (Deploy-lab issues): iOS + Android
            const deployTok = (inpDeployToken?.value || '').trim();
            if(!deployTok){
              showIosTypesEmpty('–í—Å—Ç–∞–≤—å—Ç–µ —Ç–æ–∫–µ–Ω Deploy-lab');
              showAndTypesEmpty('–í—Å—Ç–∞–≤—å—Ç–µ —Ç–æ–∫–µ–Ω Deploy-lab');
            }else{
              const iosRows = [];
              const andRows = [];
              const iosSet = new Set();
              const andSet = new Set();

              for(const rel of releases){
                if(signal?.aborted) break;

                let iosIssues = [];
                let andIssues = [];
                try{
                  [iosIssues, andIssues] = await Promise.all([
                    fetchDeployIssuesList('IOS', rel, signal),
                    fetchDeployIssuesList('ANDROID', rel, signal),
                  ]);
                }catch(e){}

                const a1 = aggregateIssuesByType(iosIssues);
                const a2 = aggregateIssuesByType(andIssues);

                a1.typeSet.forEach(t => iosSet.add(t));
                a2.typeSet.forEach(t => andSet.add(t));

                iosRows.push({ release: rel, counts: a1.counts, details: a1.details });
                andRows.push({ release: rel, counts: a2.counts, details: a2.details });
              }

              const iosTypes = sortTypesByCanon(iosSet);
              const andTypes = sortTypesByCanon(andSet);

              if(!iosTypes.length){
                showIosTypesEmpty('–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –ø–æ —Ç–∏–ø–∞–º –∑–∞–¥–∞—á (iOS) –≤ Deploy-lab');
                if(iosTypesLegend) iosTypesLegend.innerHTML = '';
                if(iosTypesTbody) iosTypesTbody.innerHTML = '';
                if(iosTypesTheadRow) iosTypesTheadRow.innerHTML = '';
                if(iosTypesChart){ try{ iosTypesChart.destroy(); }catch(e){} iosTypesChart = null; }
              }else{
                showIosTypesContent();
                renderTypesTable(iosTypesTheadRow, iosTypesTbody, iosTypes, iosRows);
                iosTypesChart = buildOrUpdateTypesChart(iosTypesChart, iosTypesCanvas, iosTypesLegend, iosTypes, releases, iosRows);
              }

              if(!andTypes.length){
                showAndTypesEmpty('–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –ø–æ —Ç–∏–ø–∞–º –∑–∞–¥–∞—á (Android) –≤ Deploy-lab');
                if(andTypesLegend) andTypesLegend.innerHTML = '';
                if(andTypesTbody) andTypesTbody.innerHTML = '';
                if(andTypesTheadRow) andTypesTheadRow.innerHTML = '';
                if(andTypesChart){ try{ andTypesChart.destroy(); }catch(e){} andTypesChart = null; }
              }else{
                showAndTypesContent();
                renderTypesTable(andTypesTheadRow, andTypesTbody, andTypes, andRows);
                andTypesChart = buildOrUpdateTypesChart(andTypesChart, andTypesCanvas, andTypesLegend, andTypes, releases, andRows);
              }
            }



            // —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ —Å–∫—Ä—ã—Ç—ã—Ö —Ç–∞–±–ª–∏—Ü (–µ—Å–ª–∏ –±—É–¥–µ—à—å –≤–∫–ª—é—á–∞—Ç—å)
            if(tbody && tcRowsData.length){
              tbody.innerHTML = '';
              tcRowsData.sort((a,b) => (Number(b.total)||0) - (Number(a.total)||0));
              tcRowsData.forEach(renderRow);
            }
            if(covTbody && covRowsData.length){
              covTbody.innerHTML = '';
              covRowsData.sort((a,b) => compareReleaseAsc(a.release, b.release));
              covRowsData.forEach(r => renderCovRow({ release: r.release, swatCount: r.swatCount, swatPeople: r.swatPeople, streamCount: r.streamCount }));
              if(covTableWrap) covTableWrap.style.display = '';
            }
            if(selTbody && selRowsData.length){
              selTbody.innerHTML = '';
              selRowsData.sort((a,b) => compareReleaseAsc(a.release, b.release));
              selRowsData.forEach(r => renderSelRow({ release: r.release, swatCount: r.swatCount, swatPeople: r.swatPeople, streamCount: r.streamCount }));
              if(selTableWrap) selTableWrap.style.display = '';
            }
            if(avgTbody && avgRowsData.length){
              avgTbody.innerHTML = '';
              avgRowsData.sort((a,b) => compareReleaseAsc(a.release, b.release));
              avgRowsData.forEach(r => renderAvgRow({ release: r.release, swatMs: r.swatMs, streamMs: r.streamMs, totalMs: r.totalMs }));
              if(avgTableWrap) avgTableWrap.style.display = '';
            }
            if(chpTableWrap && chpTbody && chpTbody.children.length){
              chpTableWrap.style.display = '';
            }
            if(cutTableWrap && cutTbody && cutTbody.children.length){
              cutTableWrap.style.display = '';
            }
            applyAllReleaseFilters();

            if(!tcRowsData.length) showEmpty('–î–∞–Ω–Ω—ã–µ –ø–æ—è–≤—è—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–∑ –∏—Å—Ç–æ—á–Ω–∏–∫–∞');
            if(!selRowsData.length) showSelEmpty('–î–∞–Ω–Ω—ã–µ –ø–æ—è–≤—è—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–∑ –∏—Å—Ç–æ—á–Ω–∏–∫–∞');
          }

          // init
          restoreInputs();
          attachReleaseMask();
          validateAndNormalizeReleaseInput(inpFrom);
          validateAndNormalizeReleaseInput(inpTo);
          showEmpty('–î–∞–Ω–Ω—ã–µ –ø–æ—è–≤—è—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–∑ –∏—Å—Ç–æ—á–Ω–∏–∫–∞');
          showCovEmpty('–î–∞–Ω–Ω—ã–µ –ø–æ—è–≤—è—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–∑ –∏—Å—Ç–æ—á–Ω–∏–∫–∞');
          showSelEmpty('–î–∞–Ω–Ω—ã–µ –ø–æ—è–≤—è—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–∑ –∏—Å—Ç–æ—á–Ω–∏–∫–∞');
          showAvgEmpty('–î–∞–Ω–Ω—ã–µ –ø–æ—è–≤—è—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–∑ –∏—Å—Ç–æ—á–Ω–∏–∫–∞');
          showChpEmpty('–î–∞–Ω–Ω—ã–µ –ø–æ—è–≤—è—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–∑ –∏—Å—Ç–æ—á–Ω–∏–∫–∞');
          showCutEmpty('–î–∞–Ω–Ω—ã–µ –ø–æ—è–≤—è—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–∑ –∏—Å—Ç–æ—á–Ω–∏–∫–∞');
          showIosTypesEmpty('–î–∞–Ω–Ω—ã–µ –ø–æ—è–≤—è—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–∑ –∏—Å—Ç–æ—á–Ω–∏–∫–∞');
          showAndTypesEmpty('–î–∞–Ω–Ω—ã–µ –ø–æ—è–≤—è—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–∑ –∏—Å—Ç–æ—á–Ω–∏–∫–∞');
          initCollapsers();
          initToggles();

          [
            tcReleaseFilter,
            tcTableReleaseFilter,
            covReleaseFilter,
            selReleaseFilter,
            avgReleaseFilter,
            chpReleaseFilter,
            cutReleaseFilter,
            iosTypesReleaseFilter,
            andTypesReleaseFilter
          ].forEach(sel => {
            if(!sel) return;
            attachSelectAllToggle(sel);
            sel.addEventListener('change', applyAllReleaseFilters);
          });
          initToggles();

          proxyBtn?.addEventListener('click', async () => {
            try{
              const r = await fetch(PROXY_BASE + '/health', { cache: 'no-store' });
              const j = await r.json();
              const ok = !!(j && j.ok === true && Number(j.port) === 8787);
              showToast(ok ? `–ü—Ä–æ–∫—Å–∏ OK (–ø–æ—Ä—Ç ${j.port})` : '–ü—Ä–æ–∫—Å–∏ –Ω–µ –æ—Ç–≤–µ—á–∞–µ—Ç', ok);
            }catch(e){
              showToast('–ü—Ä–æ–∫—Å–∏ –Ω–µ –æ—Ç–≤–µ—á–∞–µ—Ç', false);
            }
          });

          startBtn?.addEventListener('click', async () => {
            try{
              setRunning(true);
              await run();
            }catch(e){
              if(!(window.__wbAbortController?.signal?.aborted)){
                console.error(e);
                showEmpty(`–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö: ${e?.message || e}`);
              }
            }finally{
              if(!window.__wbAbortController?.signal?.aborted){
                setRunning(false);
              }
            }
          });

          stopBtn?.addEventListener('click', () => {
            setRunning(false);
          });
        })();
      </script>
    </main>
  </div>

  <div id="toast" class="pointer-events-none fixed bottom-6 left-1/2 -translate-x-1/2 opacity-0 transition-opacity duration-200">
    <div id="toastInner" class="px-4 py-2 rounded-2xl text-sm font-semibold bg-white/90 ring-1 ring-[#ecebff] text-slate-700 shadow"></div>
  </div>
</body>
</html>

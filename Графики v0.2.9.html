<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>WB All Table ‚Äî –≥—Ä–∞—Ñ–∏–∫–∏</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Tailwind –∫–∞–∫ –≤ uwu_6 (–¥–ª—è —É–¥–æ–±–Ω—ã—Ö —É—Ç–∏–ª–∏—Ç) -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

  <!-- –í—Å–µ –∫–∞—Å—Ç–æ–º–Ω—ã–µ —Å—Ç–∏–ª–∏ –≤—ã–Ω–µ—Å–µ–Ω—ã –≤ style.css -->
  <link rel="stylesheet" href="./style.css" />
</head>
<body class="min-h-screen">
  <div class="max-w-6xl mx-auto px-4 py-6">
    <header class="flex items-center justify-between gap-3 flex-wrap">
      <div class="brand-badge">
        <span class="brand-dot"></span>
        <div>
          <div class="flex items-center gap-2">
            <div class="font-extrabold leading-tight">WB All Table</div>
            <span id="appVersion" class="inline-flex items-center gap-1 text-[11px] font-semibold px-2 py-0.5 rounded-full bg-white/70 ring-1 ring-[#ecebff] text-slate-600">
              <span aria-hidden="true">üè∑Ô∏è</span><span>v0.2.9</span>
            </span>
          </div>
        </div>
      </div>
    </header>

    <main class="mt-5 grid grid-cols-1 gap-4">
      <!-- –ë–ª–æ–∫ –≤–≤–æ–¥–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ (–æ—Ç–¥–µ–ª—å–Ω–æ –æ—Ç —Ç–∞–±–ª–∏—Ü/–≥—Ä–∞—Ñ–∏–∫–æ–≤) -->
      <section class="card p-5 space-y-3">
        <div>
          <h2 class="text-lg font-semibold">–ü–∞—Ä–∞–º–µ—Ç—Ä—ã –∑–∞–ø—É—Å–∫–∞</h2>
          <div class="hint">–ó–∞–ø–æ–ª–Ω–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∏ –Ω–∞–∂–º–∏ ¬´–ó–∞–ø—É—Å—Ç–∏—Ç—å —Å–±–æ—Ä¬ª.</div>
        </div>

        <form class="w-full" onsubmit="return false;">
          <div class="border border-[#ecebff] rounded-2xl bg-white p-4">
            <div class="grid grid-cols-1 md:grid-cols-12 gap-3 items-end">
              <div class="md:col-span-4">
                <label class="block text-xs font-semibold text-[#111827] mb-1">–í–µ—Ä—Å–∏—è —Ä–µ–ª–∏–∑–∞</label>
                <div class="grid grid-cols-1 sm:grid-cols-2 gap-2">
                  <input class="input" id="releaseFrom" type="text" inputmode="numeric" placeholder="–û—Ç, –Ω–∞–ø—Ä. 7.3.5000" />
                  <input class="input" id="releaseTo" type="text" inputmode="numeric" placeholder="–î–æ, –Ω–∞–ø—Ä. 7.3.8000" />
                </div>
              </div>

              <div class="md:col-span-6">
                <label class="block text-xs font-semibold text-[#111827] mb-1">API —Ç–æ–∫–µ–Ω Allure</label>
                <input class="input" id="allureToken" type="password" autocomplete="off" placeholder="–í—Å—Ç–∞–≤—å—Ç–µ —Ç–æ–∫–µ–Ω Allure" />
              </div>

              <div class="md:col-span-2">
                <button id="startBtn" type="button" class="btn btn-grad w-full">–ó–∞–ø—É—Å—Ç–∏—Ç—å —Å–±–æ—Ä</button>
                <button id="stopBtn" type="button" class="btn btn-danger w-full" style="display:none;">–û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Å–±–æ—Ä</button>
                <button id="proxyBtn" type="button" class="mt-2 w-full inline-flex items-center justify-center gap-2 text-sm font-semibold px-3 py-2 rounded-2xl bg-white/70 ring-1 ring-[#ecebff] text-slate-700 hover:bg-white">
                  –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –ø—Ä–æ–∫—Å–∏
                </button>
              </div>

              <div class="md:col-span-4">
                <label class="block text-xs font-semibold text-[#111827] mb-1">Deploy-lab token</label>
                <input class="input" id="deployToken" type="password" autocomplete="off" placeholder="–í—Å—Ç–∞–≤—å—Ç–µ Deploy-lab token" />
              </div>
            </div>

            <div class="mt-3 flex items-center gap-2 flex-wrap">
              <span class="text-xs text-slate-500">SWAT –ø–æ–ª—É—á–∞–µ–º</span>
              <a
                class="text-xs text-[#7c3aed] underline decoration-dotted hover:decoration-solid"
                href="https://docs.google.com/document/d/1AYHrg_w_aCdiunytlDVmbmyQAxiHRr51Z0Djju4GAnE/edit?tab=t.0"
                target="_blank" rel="noopener"
              >–æ—Ç—Å—é–¥–∞</a>
            </div>

            <div class="mt-1 text-xs text-slate-500">
              –ü–æ–ª—É—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö —á–µ—Ä–µ–∑ deploy-lab –∏–¥–µ—Ç —á–µ—Ä–µ–∑ –ø—Ä–æ–∫—Å–∏ <span class="mono">localhost:8787</span>
            </div>
          </div>
        </form>
      </section>

      <!-- 1) –¢–µ—Å—Ç –∫–µ–π—Å—ã -->
      <section class="card p-5 space-y-4">
        <div class="flex items-start justify-between gap-4 flex-wrap">
          <div>
            <h2 class="text-lg font-semibold">–¢–µ—Å—Ç –∫–µ–π—Å—ã –æ—Ç —Ä–µ–ª–∏–∑–∞ –∫ —Ä–µ–ª–∏–∑—É</h2>
          </div>
          <button type="button"
            class="inline-flex items-center gap-1.5 text-xs font-semibold px-2.5 py-1 rounded-xl bg-white/70 ring-1 ring-[#ecebff] text-slate-600 hover:bg-white"
            data-collapse-btn="tc" aria-expanded="true">
            <span data-collapse-ico aria-hidden="true">‚ñæ</span>
            <span data-collapse-text>–°–≤–µ—Ä–Ω—É—Ç—å</span>
          </button>
        </div>

        <div data-collapse-body="tc" class="space-y-4">
          <div class="overflow-auto border border-[#ecebff] rounded-2xl">
            <div id="tcEmpty" class="p-6 text-center text-sm text-slate-500 bg-white flex items-center justify-center" style="min-height:520px" aria-live="polite">
              –î–∞–Ω–Ω—ã–µ –ø–æ—è–≤—è—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–∑ –∏—Å—Ç–æ—á–Ω–∏–∫–∞
            </div>

            <div id="tcContent" class="tc-content" style="display:none;">
              <div class="chart-viewport" id="tcTrendViewport">
                <canvas id="tcTrendChart" aria-label="Test cases chart" role="img"></canvas>
              </div>

              <div id="tcTableWrap" style="display:none; overflow:auto">
                <table id="tcTable">
                  <thead>
                    <tr>
                      <th class="text-left">–†–µ–ª–∏–∑</th>
                      <th>–†—É—á–Ω—ã–µ</th>
                      <th>–ê–≤—Ç–æ</th>
                      <th>–í—Å–µ–≥–æ</th>
                      <th class="text-left">–ü–æ–ª–æ—Å—ã</th>
                    </tr>
                  </thead>
                  <tbody id="tcTbody"></tbody>
                </table>
              </div>
            </div>
          </div>

          <div class="flex flex-wrap items-center justify-start gap-3">
            <div class="legend">
              <span class="lg-item"><span class="dot dot-manual"></span>–†—É—á–Ω—ã–µ</span>
              <span class="lg-item"><span class="dot dot-auto"></span>–ê–≤—Ç–æ</span>
              <span class="lg-item"><span class="dot dot-total"></span>–í—Å–µ–≥–æ</span>
            </div>
          </div>
        </div>
      </section>

      <!-- 2) SWAT/STREAM –•–ë -->
      <section class="card p-5 space-y-4">
        <div class="flex items-start justify-between gap-4 flex-wrap">
          <div>
            <h2 class="text-lg font-semibold">–ü–æ–∫—Ä—ã—Ç–∏–µ SWAT –∏ STREAM –•–ë</h2>
          </div>
          <button type="button"
            class="inline-flex items-center gap-1.5 text-xs font-semibold px-2.5 py-1 rounded-xl bg-white/70 ring-1 ring-[#ecebff] text-slate-600 hover:bg-white"
            data-collapse-btn="cov" aria-expanded="true">
            <span data-collapse-ico aria-hidden="true">‚ñæ</span>
            <span data-collapse-text>–°–≤–µ—Ä–Ω—É—Ç—å</span>
          </button>
        </div>

        <div data-collapse-body="cov" class="space-y-4">
          <div class="overflow-auto border border-[#ecebff] rounded-2xl">
            <div id="covEmpty" class="p-6 text-center text-sm text-slate-500 bg-white flex items-center justify-center" style="min-height:520px" aria-live="polite">
              –î–∞–Ω–Ω—ã–µ –ø–æ—è–≤—è—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–∑ –∏—Å—Ç–æ—á–Ω–∏–∫–∞
            </div>

            <div id="covContent" class="tc-content" style="display:none;">
              <div class="chart-viewport" id="covTrendViewport">
                <canvas id="covTrendChart" aria-label="SWAT/STREAM coverage chart" role="img"></canvas>
              </div>

              <div id="covTableWrap" style="display:none; overflow:auto">
                <table id="covTable">
                  <thead>
                    <tr>
                      <th class="text-left">–†–µ–ª–∏–∑</th>
                      <th>SWAT</th>
                      <th>STREAM</th>
                      <th>–í—Å–µ–≥–æ</th>
                      <th class="text-left">–ü–æ–∫—Ä—ã—Ç–∏–µ</th>
                    </tr>
                  </thead>
                  <tbody id="covTbody"></tbody>
                </table>
              </div>
            </div>
          </div>

          <div class="flex flex-wrap items-center justify-start gap-3">
            <div class="legend">
              <span class="lg-item"><span class="dot dot-swat"></span>SWAT</span>
              <span class="lg-item"><span class="dot dot-stream"></span>STREAM</span>
            </div>
          </div>
        </div>
      </section>

      <!-- 3) SWAT/STREAM Selective -->
      <section class="card p-5 space-y-4">
        <div class="flex items-start justify-between gap-4 flex-wrap">
          <div>
            <h2 class="text-lg font-semibold">–ü–æ–∫—Ä—ã—Ç–∏–µ SWAT –∏ STREAM Selective</h2>
          </div>
          <button type="button"
            class="inline-flex items-center gap-1.5 text-xs font-semibold px-2.5 py-1 rounded-xl bg-white/70 ring-1 ring-[#ecebff] text-slate-600 hover:bg-white"
            data-collapse-btn="sel" aria-expanded="true">
            <span data-collapse-ico aria-hidden="true">‚ñæ</span>
            <span data-collapse-text>–°–≤–µ—Ä–Ω—É—Ç—å</span>
          </button>
        </div>

        <div data-collapse-body="sel" class="space-y-4">
          <div class="overflow-auto border border-[#ecebff] rounded-2xl">
            <div id="selEmpty" class="p-6 text-center text-sm text-slate-500 bg-white flex items-center justify-center" style="min-height:520px" aria-live="polite">
              –î–∞–Ω–Ω—ã–µ –ø–æ—è–≤—è—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–∑ –∏—Å—Ç–æ—á–Ω–∏–∫–∞
            </div>

            <div id="selContent" class="tc-content" style="display:none;">
              <div class="chart-viewport" id="selTrendViewport">
                <canvas id="selTrendChart" aria-label="SWAT/STREAM Selective chart" role="img"></canvas>
              </div>

              <div id="selTableWrap" style="display:none; overflow:auto">
                <table id="selTable">
                  <thead>
                    <tr>
                      <th class="text-left">–†–µ–ª–∏–∑</th>
                      <th>SWAT</th>
                      <th>STREAM</th>
                      <th>–í—Å–µ–≥–æ</th>
                      <th class="text-left">–ü–æ–∫—Ä—ã—Ç–∏–µ</th>
                    </tr>
                  </thead>
                  <tbody id="selTbody"></tbody>
                </table>
              </div>
            </div>
          </div>

          <div class="flex flex-wrap items-center justify-start gap-3">
            <div class="legend">
              <span class="lg-item"><span class="dot dot-swat"></span>SWAT</span>
              <span class="lg-item"><span class="dot dot-stream"></span>STREAM</span>
            </div>
          </div>
        </div>
      </section>

      <!-- 4) –°—Ä–µ–¥–Ω–µ–µ –≤—Ä–µ–º—è -->
      <section class="card p-5 space-y-4">
        <div class="flex items-start justify-between gap-4 flex-wrap">
          <div>
            <h2 class="text-lg font-semibold">–°—Ä–µ–¥–Ω–µ–µ –≤—Ä–µ–º—è –ø—Ä–æ—Ö–æ–∂–¥–µ–Ω–∏—è –∫–µ–π—Å–∞</h2>
          </div>
          <button type="button"
            class="inline-flex items-center gap-1.5 text-xs font-semibold px-2.5 py-1 rounded-xl bg-white/70 ring-1 ring-[#ecebff] text-slate-600 hover:bg-white"
            data-collapse-btn="avg" aria-expanded="true">
            <span data-collapse-ico aria-hidden="true">‚ñæ</span>
            <span data-collapse-text>–°–≤–µ—Ä–Ω—É—Ç—å</span>
          </button>
        </div>

        <div data-collapse-body="avg" class="space-y-4">
          <div class="overflow-auto border border-[#ecebff] rounded-2xl">
            <div id="avgEmpty" class="p-6 text-center text-sm text-slate-500 bg-white flex items-center justify-center" style="min-height:520px" aria-live="polite">
              –î–∞–Ω–Ω—ã–µ –ø–æ—è–≤—è—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–∑ –∏—Å—Ç–æ—á–Ω–∏–∫–∞
            </div>

            <div id="avgContent" class="tc-content" style="display:none;">
              <div class="chart-viewport" id="avgTrendViewport">
                <canvas id="avgTrendChart" aria-label="Average time chart" role="img"></canvas>
              </div>

              <div id="avgTableWrap" style="display:none; overflow:auto">
                <table id="avgTable">
                  <thead>
                    <tr>
                      <th class="text-left">–†–µ–ª–∏–∑</th>
                      <th>SWAT</th>
                      <th>STREAM</th>
                      <th>–û–±—â–µ–µ</th>
                    </tr>
                  </thead>
                  <tbody id="avgTbody"></tbody>
                </table>
              </div>
            </div>
          </div>

          <div class="flex flex-wrap items-center justify-start gap-3">
            <div class="legend">
              <span class="lg-item"><span class="dot dot-swat"></span>SWAT</span>
              <span class="lg-item"><span class="dot dot-stream"></span>STREAM</span>
              <span class="lg-item"><span class="dot dot-total"></span>–û–±—â–µ–µ</span>
            </div>
          </div>
        </div>
      </section>

      <!-- 5) –ß–µ—Ä–µ–ø–∏–∫–∏ -->
      <section class="card p-5 space-y-4">
        <div class="flex items-start justify-between gap-4 flex-wrap">
          <div>
            <h2 class="text-lg font-semibold">–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —á–µ—Ä–µ–ø–∏–∫–æ–≤</h2>
          </div>
          <button type="button"
            class="inline-flex items-center gap-1.5 text-xs font-semibold px-2.5 py-1 rounded-xl bg-white/70 ring-1 ring-[#ecebff] text-slate-600 hover:bg-white"
            data-collapse-btn="chp" aria-expanded="true">
            <span data-collapse-ico aria-hidden="true">‚ñæ</span>
            <span data-collapse-text>–°–≤–µ—Ä–Ω—É—Ç—å</span>
          </button>
        </div>

        <div data-collapse-body="chp" class="space-y-4">
          <div class="overflow-auto border border-[#ecebff] rounded-2xl">
            <div id="chpEmpty" class="p-6 text-center text-sm text-slate-500 bg-white flex items-center justify-center" style="min-height:520px" aria-live="polite">
              –î–∞–Ω–Ω—ã–µ –ø–æ—è–≤—è—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–∑ –∏—Å—Ç–æ—á–Ω–∏–∫–∞
            </div>

            <div id="chpContent" class="tc-content" style="display:none;">
              <div class="chart-viewport" id="chpTrendViewport">
                <canvas id="chpTrendChart" aria-label="Cherepiki chart" role="img"></canvas>
              </div>

              <div id="chpTableWrap" style="display:none; overflow:auto">
                <table id="chpTable">
                  <thead>
                    <tr>
                      <th class="text-left">–†–µ–ª–∏–∑</th>
                      <th>iOS</th>
                      <th>Android</th>
                      <th>–í—Å–µ–≥–æ</th>
                    </tr>
                  </thead>
                  <tbody id="chpTbody"></tbody>
                </table>
              </div>
            </div>
          </div>

          <div class="flex flex-wrap items-center justify-start gap-3">
            <div class="legend">
              <span class="lg-item"><span class="dot" style="background: var(--chp-ios, #0ea5e9)"></span>iOS</span>
              <span class="lg-item"><span class="dot" style="background: var(--chp-android, #22c55e)"></span>Android</span>
              <span class="lg-item"><span class="dot" style="background: var(--chp-total, #a855f7)"></span>–í—Å–µ–≥–æ</span>
            </div>
          </div>
        </div>
      </section>

      <!-- 6) –í—Ä–µ–º—è cutoff –∏ –æ—Ç–ø—Ä–∞–≤–∫–∏ –≤ store -->
      <section class="card p-5 space-y-4">
        <div class="flex items-start justify-between gap-4 flex-wrap">
          <div>
            <h2 class="text-lg font-semibold">–í—Ä–µ–º—è cutoff –∏ –æ—Ç–ø—Ä–∞–≤–∫–∏ –≤ store</h2>
          </div>
          <button type="button"
            class="inline-flex items-center gap-1.5 text-xs font-semibold px-2.5 py-1 rounded-xl bg-white/70 ring-1 ring-[#ecebff] text-slate-600 hover:bg-white"
            data-collapse-btn="cut" aria-expanded="true">
            <span data-collapse-ico aria-hidden="true">‚ñæ</span>
            <span data-collapse-text>–°–≤–µ—Ä–Ω—É—Ç—å</span>
          </button>
        </div>

        <div data-collapse-body="cut" class="space-y-4">
          <div class="overflow-auto border border-[#ecebff] rounded-2xl">
            <div id="cutEmpty" class="p-6 text-center text-sm text-slate-500 bg-white flex items-center justify-center" style="min-height:520px" aria-live="polite">
              –î–∞–Ω–Ω—ã–µ –ø–æ—è–≤—è—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–∑ –∏—Å—Ç–æ—á–Ω–∏–∫–∞
            </div>

            <div id="cutContent" class="tc-content" style="display:none;">
              <div class="chart-viewport" id="cutTrendViewport">
                <canvas id="cutTrendChart" aria-label="Cutoff & Store chart" role="img"></canvas>
              </div>

              <div id="cutTableWrap" style="display:none; overflow:auto">
                <table id="cutTable">
                  <thead>
                    <tr>
                      <th class="text-left">–†–µ–ª–∏–∑</th>
                      <th>iOS Cutoff</th>
                      <th>iOS Store</th>
                      <th>Android Cutoff</th>
                      <th>Android Store</th>
                    </tr>
                  </thead>
                  <tbody id="cutTbody"></tbody>
                </table>
              </div>
            </div>
          </div>

          <div class="flex flex-wrap items-center justify-start gap-3">
            <div class="legend">
              <span class="lg-item"><span class="dot dot-ios-cutoff"></span>iOS Cutoff</span>
              <span class="lg-item"><span class="dot dot-ios-store"></span>iOS Store</span>
              <span class="lg-item"><span class="dot dot-android-cutoff"></span>Android Cutoff</span>
              <span class="lg-item"><span class="dot dot-android-store"></span>Android Store</span>
            </div>
          </div>
        </div>
      </section>

      <script>
        (function(){
          const BASE_URL = 'https://allure-testops.wb.ru';
          const PROJECT_ID = 7;
          const PAGE_SIZE = 1000;
          const KINDS = ['Smoke', 'Selective'];
          const SWAT_LIST_URL = 'https://script.google.com/macros/s/AKfycbzLmb5ATmHOip7REPsl_iSLH2GuEHui0W_czyrPgW_8G1Wl-RY8CiM2UeAdqQQEwoNx-Q/exec';
          const PROXY_BASE = 'http://localhost:8787';
          const LS_COLLAPSE_KEY = 'wb_all_table_collapsed';

          const DEPLOY_BASE_URL_TMPL   = 'https://deploy-lab-api.wb.ru/releaseboss/admin_panel/release/{prefix}_{rel}';
          const DEPLOY_DEPLOY_URL_TMPL = 'https://deploy-lab-api.wb.ru/releaseboss/admin_panel/release/{prefix}_{rel}/deploy';
          const DEPLOY_ISSUES_URL_TMPL = 'https://deploy-lab-api.wb.ru/releaseboss/admin_panel/release/{prefix}_{rel}/issues';

          const LS_TOKEN_KEY = 'swat_uwu_token';
          const LS_RANGE_KEY = 'swat_uwu_release_range';
          const LS_DEPLOY_KEY = 'wb_all_table_deploy_token';

          const startBtn = document.getElementById('startBtn');
          const stopBtn  = document.getElementById('stopBtn');
          const proxyBtn = document.getElementById('proxyBtn');

          const inpFrom  = document.getElementById('releaseFrom');
          const inpTo    = document.getElementById('releaseTo');
          const inpAllureToken = document.getElementById('allureToken');
          const inpDeployToken = document.getElementById('deployToken');

          // Sections: TC
          const emptyBox = document.getElementById('tcEmpty');
          const contentWrap = document.getElementById('tcContent');
          const tbody = document.getElementById('tcTbody');

          // Coverage (HB)
          const covEmpty = document.getElementById('covEmpty');
          const covContent = document.getElementById('covContent');
          const covTbody = document.getElementById('covTbody');

          // Coverage Selective
          const selEmpty = document.getElementById('selEmpty');
          const selContent = document.getElementById('selContent');
          const selTbody = document.getElementById('selTbody');
          const selCanvas = document.getElementById('selTrendChart');

          // Average time
          const avgEmpty = document.getElementById('avgEmpty');
          const avgContent = document.getElementById('avgContent');
          const avgTbody = document.getElementById('avgTbody');
          const avgCanvas = document.getElementById('avgTrendChart');

          // Cherepiki
          const chpEmpty = document.getElementById('chpEmpty');
          const chpContent = document.getElementById('chpContent');
          const chpTbody = document.getElementById('chpTbody');
          const chpCanvas = document.getElementById('chpTrendChart');

          // Cutoff/store
          const cutEmpty = document.getElementById('cutEmpty');
          const cutContent = document.getElementById('cutContent');
          const cutTbody = document.getElementById('cutTbody');
          const cutCanvas = document.getElementById('cutTrendChart');

          const chartCanvas = document.getElementById('tcTrendChart');
          const covCanvas = document.getElementById('covTrendChart');

          let tcChart = null;
          let covChart = null;
          let selChart = null;
          let avgChart = null;
          let chpChart = null;
          let cutChart = null;

          // SWAT list cache: fetch exec per release (cache by release)
          const __swatCache = new Map();
          const __swatPromiseCache = new Map();

          // Plugin: delta labels above points
          const deltaLabelsPlugin = {
            id: 'deltaLabels',
            afterDatasetsDraw(chart, args, pluginOptions){
              const opts = pluginOptions || chart?.options?.plugins?.deltaLabels;
              if(!opts) return;
              const dsIndex = Number(opts.datasetIndex);
              if(!Number.isFinite(dsIndex)) return;
              const ds = chart.data?.datasets?.[dsIndex];
              const meta = chart.getDatasetMeta(dsIndex);
              if(!ds || !meta || !meta.data) return;

              const data = Array.isArray(ds.data) ? ds.data : [];
              if(data.length < 2) return;

              const green = (opts.upColor) || '#22c55e';
              const red   = (opts.downColor) || '#f43f5e';
              const font  = (opts.font) || '600 11px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial';

              const fmt = (v) => {
                const n = Number(v);
                if(!Number.isFinite(n)) return '';
                const sign = n > 0 ? '+' : '';
                return sign + Math.round(n).toLocaleString('ru-RU');
              };

              const ctx = chart.ctx;
              ctx.save();

              // draw across full canvas (avoid clipping near top)
              ctx.beginPath();
              ctx.rect(0, 0, chart.width, chart.height);
              ctx.clip();

              ctx.font = font;
              ctx.textAlign = 'center';
              ctx.textBaseline = 'bottom';

              for(let i = 1; i < data.length; i++){
                const cur = Number(data[i]);
                const prev = Number(data[i-1]);
                if(!Number.isFinite(cur) || !Number.isFinite(prev)) continue;
                const delta = cur - prev;
                if(!delta) continue;

                const pt = meta.data[i];
                if(!pt) continue;

                const label = fmt(delta);
                if(!label) continue;

                ctx.fillStyle = delta > 0 ? green : red;
                ctx.fillText(label, pt.x, pt.y - 12);
              }

              ctx.restore();
            }
          };

          try{
            if(window.Chart && typeof window.Chart.register === 'function'){
              window.Chart.register(deltaLabelsPlugin);
            }
          }catch(e){}

          function b64Utf8(str){
            return btoa(unescape(encodeURIComponent(str)));
          }
          function b64Query(filters){
            return b64Utf8(JSON.stringify(filters));
          }

          function normalizeLogin(v){
            if(v === null || v === undefined) return '';
            let s = String(v).trim();
            if(!s) return '';
            s = s.replace(/^@+/, '');
            s = s.split(/[\s,(]/)[0];
            return s.trim().toLowerCase();
          }

          function authHeaders(){
            const tok = (inpAllureToken?.value || '').trim();
            return {
              'Accept': 'application/json',
              'Authorization': `Api-Token ${tok}`
            };
          }

          // –í–ê–ñ–ù–û: —Ç—É—Ç –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –º–∏–Ω–∏–º–∞–ª—å–Ω–æ –Ω—É–∂–Ω—ã–µ –∑–∞–≥–æ–ª–æ–≤–∫–∏
          function deployHeaders(){
            const tok = (inpDeployToken?.value || '').trim();
            return {
              'accept': '*/*',
              'accept-language': 'ru,en;q=0.9',
              'authorization-deploy-lab': `Bearer ${tok}`
            };
          }

          function showToast(msg, ok=true){
            const el = document.getElementById('toast');
            const inner = document.getElementById('toastInner');
            if(!el || !inner) return;
            inner.textContent = msg;
            inner.className = 'px-4 py-2 rounded-2xl text-sm font-semibold ring-1 shadow ' + (ok
              ? 'bg-white/90 ring-[#ecebff] text-slate-700'
              : 'bg-rose-50 ring-rose-200 text-rose-700'
            );
            el.style.opacity = '1';
            clearTimeout(showToast.__t);
            showToast.__t = setTimeout(() => { el.style.opacity = '0'; }, 1800);
          }

          async function proxyGetJson(targetUrl, headers, signal){
            const p = new URL(PROXY_BASE + '/proxy');
            p.searchParams.set('url', targetUrl);
            const r = await fetch(p.toString(), { headers, signal });
            if(!r.ok) throw new Error(`Proxy HTTP ${r.status}`);
            return r.json();
          }

          async function fetchLastCherepik(prefix, release, signal){
            const tok = (inpDeployToken?.value || '').trim();
            if(!tok) return null;

            const url = `https://deploy-lab-api.wb.ru/releaseboss/admin_panel/release/${prefix}_${release}/notification_history`;
            try {
              const headers = {
                'authorization-deploy-lab': `Bearer ${tok}`,
                'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36'
              };
              const response = await proxyGetJson(url, headers, signal);
              if (!Array.isArray(response?.logs)) return null;

              // –ë–µ—Ä—ë–º —Å–∞–º—ã–π –ù–û–í–´–ô –ª–æ–≥ (–º–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è date) —Å—Ä–µ–¥–∏ —Å–æ–æ–±—â–µ–Ω–∏–π —Å "–ù–æ–≤—ã–π —á–µ—Ä–∏–ø–∏–∫"
              let maxMsLocal = null;
              for (const log of response.logs) {
                if (log?.message && String(log.message).includes('–ù–æ–≤—ã–π —á–µ—Ä–∏–ø–∏–∫')) {
                  const dateStr = log.date;
                  const p = toMskLocalParts(dateStr);
                  if (p && Number.isFinite(p.msLocal)) {
                    if (maxMsLocal === null || p.msLocal > maxMsLocal) maxMsLocal = p.msLocal;
                  }
                }
              }

              if (maxMsLocal === null) return null;
              return labelFromMsLocal(maxMsLocal);
            } catch (e) {
              console.error('Error fetching last cherepik:', e);
              return null;
            }
          }

          async function fetchDeployIssueCount(prefix, release, signal){
            const tok = (inpDeployToken?.value || '').trim();
            if(!tok) return 0;
            const url = DEPLOY_ISSUES_URL_TMPL
              .replace('{prefix}', prefix)
              .replace('{rel}', release);
            const data = await proxyGetJson(url, deployHeaders(), signal);
            if(!Array.isArray(data)) return 0;
            let n = 0;
            for(const item of data){
              if(item && item.merged_after_cutoff === true) n += 1;
            }
            return n;
          }

          // ---- –¥–∞—Ç—ã/–≤—Ä–µ–º—è –∏–∑ deploy-lab (1–≤1 –ø–æ python): cutoff_date –∏–∑ base, store_time = earliest note.date –∏–∑ deploy ----

          function normalizeIsoForJS(s){
            if(!s) return null;
            let x = String(s).trim();
            // trim fractional seconds to max 3 digits (JS Date is picky)
            x = x.replace(/(\.\d{3})\d+(?=[Z+\-])/, '$1');
            x = x.replace(/(\.\d{2})(?=[Z+\-])/, '$10');
            x = x.replace(/(\.\d)(?=[Z+\-])/, '$100');
            return x;
          }

          function parseTzOffsetMinutes(iso){
            if(!iso) return 0;
            const s = String(iso);
            if(s.endsWith('Z')) return 0;
            const m = s.match(/([+\-])(\d{2}):?(\d{2})$/);
            if(!m) return 0;
            const sign = m[1] === '-' ? -1 : 1;
            const hh = Number(m[2] || 0);
            const mm = Number(m[3] || 0);
            return sign * (hh * 60 + mm);
          }

          function pad2(n){ return String(n).padStart(2,'0'); }

          function dayShortRuFromDow(dow){
            // 0 –≤—Å,1 –ø–Ω,2 –≤—Ç,3 —Å—Ä,4 —á—Ç,5 –ø—Ç,6 —Å–±
            return ['–≤—Å','–ø–Ω','–≤—Ç','—Å—Ä','—á—Ç','–ø—Ç','—Å–±'][dow] || '';
          }

          function toMskLocalParts(iso){
            const norm = normalizeIsoForJS(iso);
            if(!norm) return null;

            const d = new Date(norm);
            if(Number.isNaN(d.getTime())) return null;

            const offMin = parseTzOffsetMinutes(norm);
            const msLocal = d.getTime() + offMin * 60_000;
            const dl = new Date(msLocal);

            const dow = dl.getUTCDay(); // day in that offset zone
            const dayShort = dayShortRuFromDow(dow);
            const dd = pad2(dl.getUTCDate());
            const MM = pad2(dl.getUTCMonth()+1);
            const hh = pad2(dl.getUTCHours());
            const mm = pad2(dl.getUTCMinutes());

            return {
              msLocal,
              dow,
              dayShort,
              dateText: `${dd}.${MM}`,
              timeText: `${hh}:${mm}`,
              fullText: `${dayShort} ${dd}.${MM} ${hh}:${mm}`
            };
          }

          // –∏–Ω–¥–µ–∫—Å –¥–ª—è –æ—Å–∏ Y: –ø–æ—Ä—è–¥–æ–∫ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —Å–≤–µ—Ä—Ö—É –≤–Ω–∏–∑: –≤—Å, —Å–±, –ø—Ç, —á—Ç, —Å—Ä, –≤—Ç, –ø–Ω
          function dayIndexCustom(dow){
            // dow: 0 –≤—Å ... 6 —Å–±
            // idx: 0 –≤—Å, 1 —Å–±, 2 –ø—Ç, 3 —á—Ç, 4 —Å—Ä, 5 –≤—Ç, 6 –ø–Ω
            return (7 - dow) % 7;
          }

          function yValueFromIso(iso){
            const p = toMskLocalParts(iso);
            if(!p) return null;
            const idx = dayIndexCustom(p.dow);
            const dl = new Date(p.msLocal);
            const mins = dl.getUTCHours() * 60 + dl.getUTCMinutes() + (dl.getUTCSeconds() / 60);
            return {
              y: idx * 1440 + mins,
              msLocal: p.msLocal,
              label: p.fullText
            };
          }

          function yValueFromMsLocal(msLocal){
            const ms = Number(msLocal);
            if(!Number.isFinite(ms)) return null;
            const dl = new Date(ms);
            if(Number.isNaN(dl.getTime())) return null;
            const idx = dayIndexCustom(dl.getUTCDay());
            const mins = dl.getUTCHours() * 60 + dl.getUTCMinutes() + (dl.getUTCSeconds() / 60);
            return {
              y: idx * 1440 + mins,
              msLocal: ms,
              label: labelFromMsLocal(ms)
            };
          }


          function extractEarliestNoteDate(deployObj, sectionKey){
            if(!deployObj || typeof deployObj !== 'object') return null;
            const sec = deployObj[sectionKey];
            if(!sec || typeof sec !== 'object') return null;
            const notes = Array.isArray(sec.notes) ? sec.notes : [];
            const dates = [];
            for(const n of notes){
              const iso = n && n.date;
              const p = toMskLocalParts(iso);
              if(p && Number.isFinite(p.msLocal)) dates.push(p.msLocal);
            }
            if(!dates.length) return null;
            const minMs = Math.min(...dates);
            // –≤–µ—Ä–Ω—É—Ç—å –∏—Å—Ö–æ–¥–Ω—ã–π ISO –Ω–µ –º–æ–∂–µ–º, –Ω–æ –º–æ–∂–µ–º –≤–µ—Ä–Ω—É—Ç—å msLocal + label (label –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏–º –∏–∑ msLocal)
            return minMs;
          }

          function labelFromMsLocal(msLocal){
            const dl = new Date(msLocal);
            const dow = dl.getUTCDay();
            const dayShort = dayShortRuFromDow(dow);
            const dd = pad2(dl.getUTCDate());
            const MM = pad2(dl.getUTCMonth()+1);
            const hh = pad2(dl.getUTCHours());
            const mm = pad2(dl.getUTCMinutes());
            return `${dayShort} ${dd}.${MM} ${hh}:${mm}`;
          }

          async function fetchDeployDates(prefix, release, signal){
            const tok = (inpDeployToken?.value || '').trim();
            if(!tok) return { cutoff: null, store: null };

            const baseUrl = DEPLOY_BASE_URL_TMPL.replace('{prefix}', prefix).replace('{rel}', release);
            const deployUrl = DEPLOY_DEPLOY_URL_TMPL.replace('{prefix}', prefix).replace('{rel}', release);

            let cutoffIso = null;
            let storeMsLocal = null;

            try{
              const base = await proxyGetJson(baseUrl, deployHeaders(), signal);
              cutoffIso = base?.cutoff_date || null;
            }catch(e){
              cutoffIso = null;
            }

            try{
              const dep = await proxyGetJson(deployUrl, deployHeaders(), signal);
              if(prefix === 'ANDROID'){
                storeMsLocal = extractEarliestNoteDate(dep, 'Google Play');
              }else{
                storeMsLocal = extractEarliestNoteDate(dep, 'AppStore');
              }
            }catch(e){
              storeMsLocal = null;
            }

            return { cutoff: cutoffIso, storeMsLocal };
          }

          // ---- helpers: UI/empty ----
          function setEmpty(text){
            if(!emptyBox) return;
            emptyBox.textContent = text;
            emptyBox.style.display = '';
          }
          function showContent(){
            if(emptyBox) emptyBox.style.display = 'none';
            contentWrap.style.display = '';
          }
          function showEmpty(text){
            setEmpty(text);
            contentWrap.style.display = 'none';
          }

          function setCovEmpty(text){
            if(!covEmpty) return;
            covEmpty.textContent = text;
            covEmpty.style.display = '';
          }
          function showCovContent(){
            if(covEmpty) covEmpty.style.display = 'none';
            if(covContent) covContent.style.display = '';
          }
          function showCovEmpty(text){
            setCovEmpty(text);
            if(covContent) covContent.style.display = 'none';
          }

          function setSelEmpty(text){
            if(!selEmpty) return;
            selEmpty.textContent = text;
            selEmpty.style.display = '';
          }
          function showSelContent(){
            if(selEmpty) selEmpty.style.display = 'none';
            if(selContent) selContent.style.display = '';
          }
          function showSelEmpty(text){
            setSelEmpty(text);
            if(selContent) selContent.style.display = 'none';
          }

          function setAvgEmpty(text){
            if(!avgEmpty) return;
            avgEmpty.textContent = text;
            avgEmpty.style.display = '';
          }
          function showAvgContent(){
            if(avgEmpty) avgEmpty.style.display = 'none';
            if(avgContent) avgContent.style.display = '';
          }
          function showAvgEmpty(text){
            setAvgEmpty(text);
            if(avgContent) avgContent.style.display = 'none';
          }

          function setChpEmpty(text){
            if(!chpEmpty) return;
            chpEmpty.textContent = text;
            chpEmpty.style.display = '';
          }
          function showChpContent(){
            if(chpEmpty) chpEmpty.style.display = 'none';
            if(chpContent) chpContent.style.display = '';
          }
          function showChpEmpty(text){
            setChpEmpty(text);
            if(chpContent) chpContent.style.display = 'none';
          }

          function setCutEmpty(text){
            if(!cutEmpty) return;
            cutEmpty.textContent = text;
            cutEmpty.style.display = '';
          }
          function showCutContent(){
            if(cutEmpty) cutEmpty.style.display = 'none';
            if(cutContent) cutContent.style.display = '';
          }
          function showCutEmpty(text){
            setCutEmpty(text);
            if(cutContent) cutContent.style.display = 'none';
          }

          function setRunning(running){
            if(running){
              startBtn.style.display = 'none';
              stopBtn.style.display = '';
              window.__wbAbortController = new AbortController();
              showEmpty('–î–∞–Ω–Ω—ã–µ –ø–æ—è–≤—è—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–∑ –∏—Å—Ç–æ—á–Ω–∏–∫–∞');
              showCovEmpty('–î–∞–Ω–Ω—ã–µ –ø–æ—è–≤—è—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–∑ –∏—Å—Ç–æ—á–Ω–∏–∫–∞');
              showSelEmpty('–î–∞–Ω–Ω—ã–µ –ø–æ—è–≤—è—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–∑ –∏—Å—Ç–æ—á–Ω–∏–∫–∞');
              showAvgEmpty('–î–∞–Ω–Ω—ã–µ –ø–æ—è–≤—è—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–∑ –∏—Å—Ç–æ—á–Ω–∏–∫–∞');
              showChpEmpty('–î–∞–Ω–Ω—ã–µ –ø–æ—è–≤—è—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–∑ –∏—Å—Ç–æ—á–Ω–∏–∫–∞');
              showCutEmpty('–î–∞–Ω–Ω—ã–µ –ø–æ—è–≤—è—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–∑ –∏—Å—Ç–æ—á–Ω–∏–∫–∞');
            }else{
              stopBtn.style.display = 'none';
              startBtn.style.display = '';
              if(window.__wbAbortController){
                try{ window.__wbAbortController.abort(); }catch(e){}
              }
              window.__wbAbortController = null;
            }
          }

          function saveInputs(){
            try{ localStorage.setItem(LS_TOKEN_KEY, inpAllureToken.value || ''); }catch(e){}
            try{ localStorage.setItem(LS_DEPLOY_KEY, inpDeployToken.value || ''); }catch(e){}
            try{ localStorage.setItem(LS_RANGE_KEY, JSON.stringify({ from: inpFrom.value || '', to: inpTo.value || '' })); }catch(e){}
          }

          function restoreInputs(){
            try{
              const tok = localStorage.getItem(LS_TOKEN_KEY) || '';
              if(inpAllureToken) inpAllureToken.value = tok;
            }catch(e){}
            try{
              const dt = localStorage.getItem(LS_DEPLOY_KEY) || '';
              if(inpDeployToken) inpDeployToken.value = dt;
            }catch(e){}
            try{
              const raw = localStorage.getItem(LS_RANGE_KEY);
              if(raw){
                const obj = JSON.parse(raw);
                if(inpFrom) inpFrom.value = obj?.from || '';
                if(inpTo) inpTo.value = obj?.to || '';
              }
            }catch(e){}
          }

          function clear(){
            tbody.innerHTML = '';
            if(tcChart){
              tcChart.data.labels = [];
              tcChart.data.datasets.forEach(d => d.data = []);
              tcChart.update();
            }

            if(covTbody) covTbody.innerHTML = '';
            if(covChart){
              covChart.data.labels = [];
              covChart.data.datasets.forEach(d => d.data = []);
              covChart._swatPeople = [];
              covChart.update();
            }

            if(selTbody) selTbody.innerHTML = '';
            if(selChart){
              selChart.data.labels = [];
              selChart.data.datasets.forEach(d => d.data = []);
              selChart._swatPeople = [];
              selChart.update();
            }

            if(avgTbody) avgTbody.innerHTML = '';
            if(avgChart){
              avgChart.data.labels = [];
              avgChart.data.datasets.forEach(d => d.data = []);
              avgChart.update();
            }

            if(chpTbody) chpTbody.innerHTML = '';
            if(chpChart){
              chpChart.data.labels = [];
              chpChart.data.datasets.forEach(d => d.data = []);
              chpChart.update();
            }

            if(cutTbody) cutTbody.innerHTML = '';
            if(cutChart){
              cutChart.data.labels = [];
              cutChart.data.datasets.forEach(d => {
                d.data = [];
                d._timeLabel = [];
                d._timeMs = [];
                d._lastChpLabel = [];
              });
              cutChart.update();
            }
          }

          async function fetchSwatLogins(release, signal){
            const rel = String(release || '').trim();
            if(!rel) return { set: new Set(), total: 0 };

            if(__swatCache.has(rel)) return __swatCache.get(rel);
            if(__swatPromiseCache.has(rel)) return __swatPromiseCache.get(rel);

            const p = (async () => {
              const url = new URL(SWAT_LIST_URL);
              url.searchParams.set('release', rel);

              const r = await fetch(url.toString(), { signal });
              if(!r.ok) throw new Error(`SWAT list HTTP ${r.status}`);

              const data = await r.json();
              const logins = Array.isArray(data?.worked_SWAT?.login) ? data.worked_SWAT.login : [];
              const declaredTotal = Number(data?.worked_SWAT?.total || 0) || 0;

              const set = new Set();
              for(const l of logins){
                const norm = normalizeLogin(l);
                if(norm) set.add(norm);
              }

              const out = { set, total: declaredTotal || set.size };
              __swatCache.set(rel, out);
              __swatPromiseCache.delete(rel);
              return out;
            })();

            __swatPromiseCache.set(rel, p);

            try{
              return await p;
            }catch(e){
              __swatPromiseCache.delete(rel);
              __swatCache.delete(rel);
              throw e;
            }
          }

          function cssVar(name, fallback){
            try{
              const v = getComputedStyle(document.documentElement).getPropertyValue(name).trim();
              return v || fallback;
            }catch{ return fallback; }
          }

          // ---- —Ä–µ–ª–∏–∑—ã ----
          function parseVersion(v){
            const raw = (v||'').trim();
            const parts = raw.split('.').map(x => x.trim());
            if(parts.length < 3) return null;

            const [major, minor, buildRaw] = parts;
            if(!/^\d+$/.test(major) || !/^\d+$/.test(minor) || !/^\d+$/.test(buildRaw)) return null;

            const majorN = Number(major);
            const minorN = Number(minor);
            if(!Number.isFinite(majorN) || !Number.isFinite(minorN)) return null;

            let buildN = Number(buildRaw);
            if(!Number.isFinite(buildN)) return null;

            const len = buildRaw.length;
            if(len < 4){
              buildN = buildN * Math.pow(10, 4 - len);
            }

            const buildStrNorm = String(buildN).padStart(4, '0');
            return { major, minor, majorN, minorN, build: buildN, buildStrRaw: buildRaw, buildStrNorm };
          }

          function formatRelease(vObj){
            const m = String(vObj.majorN);
            const n = String(vObj.minorN);
            const b = (vObj.buildStrNorm ? String(vObj.buildStrNorm) : String(vObj.build).padStart(4, '0'));
            return `${m}.${n}.${b}`;
          }

          function validateAndNormalizeReleaseInput(inputEl){
            if(!inputEl) return null;
            const raw = (inputEl.value || '').trim();
            if(!raw) return null;
            const v = parseVersion(raw);
            if(!v) return null;
            const norm = formatRelease(v);
            inputEl.value = norm;
            return norm;
          }

          function attachReleaseMask(){
            [inpFrom, inpTo].forEach(el => {
              if(!el) return;
              el.addEventListener('blur', () => validateAndNormalizeReleaseInput(el));
            });
          }

          function buildMajorRange(){
            const a = parseVersion(inpFrom?.value);
            const b = parseVersion(inpTo?.value);
            if(!a || !b) return [];
            if(a.majorN !== b.majorN) return [];

            const step = 1000;

            const aKey = a.minorN * 10000 + a.build;
            const bKey = b.minorN * 10000 + b.build;
            const loV = aKey <= bKey ? a : b;
            const hiV = aKey <= bKey ? b : a;

            const out = [];
            for(let m = loV.minorN; m <= hiV.minorN; m++){
              let startBuild = 0;
              let endBuild   = 9000;

              if(m === loV.minorN) startBuild = Math.ceil(loV.build / step) * step;
              if(m === hiV.minorN) endBuild   = Math.floor(hiV.build / step) * step;

              if(startBuild > endBuild) continue;
              for(let build = startBuild; build <= endBuild; build += step){
                const buildStr = String(build).padStart(4, '0');
                out.push(`${loV.major}.${m}.${buildStr}`);
              }
            }
            return out;
          }

          // ---- allure http ----
          async function httpGet(path, params, signal){
            const url = new URL(BASE_URL + path);
            if(params){
              Object.entries(params).forEach(([k,v]) => {
                if(v !== undefined && v !== null && v !== '') url.searchParams.set(k, String(v));
              });
            }
            const r = await fetch(url.toString(), { headers: authHeaders(), signal });
            if(!r.ok) throw new Error(`HTTP ${r.status} ${path}`);
            return r.json();
          }

          async function fetchLaunches(version, kind, signal){
            const terms = [`[${kind}] –†–µ–≥—Ä–µ—Å—Å ${version}`];
            if(kind === 'Smoke') terms.push(`[High/Blocker][DeployLab] –†–µ–≥—Ä–µ—Å—Å ${version}`);
            if(kind === 'Selective') terms.push(`[Selective][DeployLab] –†–µ–≥—Ä–µ—Å—Å ${version}`);

            const byId = new Map();
            for(const term of terms){
              const search = b64Query([{ id:'name', type:'string', value: term }]);
              let page = 0;
              while(true){
                const data = await httpGet('/api/launch', {
                  page, size: PAGE_SIZE, search,
                  projectId: PROJECT_ID,
                  preview: 'true',
                  sort: 'createdDate,desc'
                }, signal);

                const content = (data && data.content) ? data.content : [];
                if(!content.length) break;
                content.forEach(it => {
                  const id = Number(it && it.id);
                  if(Number.isFinite(id)) byId.set(id, it);
                });
                if(content.length < PAGE_SIZE) break;
                page += 1;
              }
            }
            return Array.from(byId.values());
          }

          async function fetchHBLaunches(version, signal){
            const term = `[High/Blocker][DeployLab] –†–µ–≥—Ä–µ—Å—Å ${version}`;
            const search = b64Query([{ id:'name', type:'string', value: term }]);
            const byId = new Map();
            let page = 0;
            while(true){
              const data = await httpGet('/api/launch', {
                page, size: PAGE_SIZE, search,
                projectId: PROJECT_ID,
                preview: 'true',
                sort: 'createdDate,desc'
              }, signal);

              const content = (data && data.content) ? data.content : [];
              if(!content.length) break;
              content.forEach(it => {
                const id = Number(it && it.id);
                if(Number.isFinite(id)) byId.set(id, it);
              });
              if(content.length < PAGE_SIZE) break;
              page += 1;
            }
            return Array.from(byId.values());
          }

          async function fetchTotalCases(launchId, signal){
            const data = await httpGet(`/api/launch/${launchId}/statistic`, null, signal);
            if(!Array.isArray(data)) return 0;
            return data.reduce((acc, d) => acc + Number(d?.count || 0), 0);
          }

          async function fetchAutomatedTotalCases(launchId, signal, treeId=14){
            const search = b64Query([{ id:'automated', type:'boolean', value: true }]);
            const data = await httpGet('/api/testresulttree/group', {
              launchId, treeId, search,
              sort: 'duration,asc',
              size: PAGE_SIZE
            }, signal);
            const content = (data && data.content) ? data.content : [];
            let total = 0;
            content.forEach(item => {
              const stat = item?.statistic || {};
              total += Number(stat?.total || 0);
            });
            return total;
          }

          const __memberStatsCache = new Map();
          const __launchDurationCache = new Map();

          async function fetchMemberStats(launchId, signal){
            if(__memberStatsCache.has(launchId)) return __memberStatsCache.get(launchId);
            const data = await httpGet(`/api/launch/${launchId}/memberstats`, { size: 1000, page: 0 }, signal);
            let out;
            if(Array.isArray(data)) out = data;
            else if(data && typeof data === 'object') out = data.content || [];
            else out = [];
            __memberStatsCache.set(launchId, out);
            return out;
          }

          async function fetchLaunchDurationMs(launchId, signal){
            if(__launchDurationCache.has(launchId)) return __launchDurationCache.get(launchId);
            let ms = 0;
            try{
              const d = await httpGet(`/api/launch/${launchId}`, null, signal);
              ms = Number(d?.duration || d?.statistic?.duration || 0) || 0;
            }catch(e){
              ms = 0;
            }
            __launchDurationCache.set(launchId, ms);
            return ms;
          }

          function swatStreamAgg(memberstats, swatSet){
            let swatTotal = 0;
            let streamTotal = 0;
            let swatDur = 0;
            let streamDur = 0;

            const pushStat = (bucket, statItem) => {
              if(!statItem || typeof statItem !== 'object') return;
              const c = Number(statItem.count ?? statItem.total ?? statItem.tests ?? 0) || 0;
              const d = Number(statItem.duration ?? statItem.time ?? 0) || 0;
              if(c > 0) bucket.total += c;
              if(d > 0) bucket.dur += d;
            };

            for(const m of (memberstats || [])){
              if(!m || typeof m !== 'object') continue;
              const assignee = String(m.assignee || '').trim().toLowerCase();

              let total = 0;
              let dur = 0;

              const stat = m.statistic;

              if(Array.isArray(stat)){
                const bucket = { total: 0, dur: 0 };
                for(const s of stat) pushStat(bucket, s);
                total = bucket.total;
                dur = bucket.dur;
              }else if(stat && typeof stat === 'object'){
                const bucket = { total: 0, dur: 0 };
                if(('count' in stat) || ('total' in stat) || ('duration' in stat) || ('time' in stat)){
                  pushStat(bucket, stat);
                }else{
                  for(const v of Object.values(stat)){
                    if(Array.isArray(v)){
                      for(const vv of v) pushStat(bucket, vv);
                    }else{
                      pushStat(bucket, v);
                    }
                  }
                }
                total = bucket.total;
                dur = bucket.dur;
              }

              if(!dur){
                dur = Number(m.durationSum ?? m.duration ?? m.time ?? 0) || 0;
              }

              if(total <= 0) continue;

              if(assignee && swatSet && swatSet.has(assignee)){
                swatTotal += total;
                swatDur += dur;
              }else{
                streamTotal += total;
                streamDur += dur;
              }
            }

            return { swatTotal, streamTotal, swatDur, streamDur };
          }

          function formatMsPerCase(ms){
            const n = Number(ms) || 0;
            if(n <= 0) return '00:00';
            const totalSec = Math.round(n / 1000);
            const h = Math.floor(totalSec / 3600);
            const m = Math.floor((totalSec % 3600) / 60);
            const s = totalSec % 60;
            const mm = String(m).padStart(2,'0');
            const ss = String(s).padStart(2,'0');
            if(h > 0) return `${h}:${mm}:${ss}`;
            return `${mm}:${ss}`;
          }

          function ruPlural(n, one, few, many){
            const num = Math.abs(Number(n) || 0);
            const n100 = num % 100;
            const n10 = num % 10;
            if(n100 >= 11 && n100 <= 19) return many;
            if(n10 === 1) return one;
            if(n10 >= 2 && n10 <= 4) return few;
            return many;
          }

          function memberTotalCount(m){
            if(!m || typeof m !== 'object') return 0;

            const pushStat = (bucket, statItem) => {
              if(!statItem || typeof statItem !== 'object') return;
              const c = Number(statItem.count ?? statItem.total ?? statItem.tests ?? 0) || 0;
              if(c > 0) bucket.total += c;
            };

            let total = 0;
            const stat = m.statistic;

            if(Array.isArray(stat)){
              const bucket = { total: 0 };
              for(const s of stat) pushStat(bucket, s);
              total = bucket.total;
            }else if(stat && typeof stat === 'object'){
              const bucket = { total: 0 };
              if(('count' in stat) || ('total' in stat) || ('tests' in stat)){
                pushStat(bucket, stat);
              }else{
                for(const v of Object.values(stat)){
                  if(Array.isArray(v)){
                    for(const vv of v) pushStat(bucket, vv);
                  }else{
                    pushStat(bucket, v);
                  }
                }
              }
              total = bucket.total;
            }

            if(!total){
              total = Number(m.total ?? m.count ?? 0) || 0;
            }
            return total;
          }

          function extractSwatAssignees(memberstats, swatSet){
            const set = new Set();
            for(const m of (memberstats || [])){
              if(!m || typeof m !== 'object') continue;
              const assignee = String(m.assignee || '').trim().toLowerCase();
              if(!assignee) continue;
              if(!swatSet || !swatSet.has(assignee)) continue;
              const total = memberTotalCount(m);
              if(total > 0) set.add(assignee);
            }
            return set;
          }

          // ---- charts ----
          function ensureChart(){
            if(!chartCanvas || !window.Chart) return;
            if(tcChart){
              tcChart.data.labels = [];
              tcChart.data.datasets.forEach(d => d.data = []);
              tcChart.update();
              return;
            }

            const cManual = cssVar('--tc-manual', '#f59e0b');
            const cAuto   = cssVar('--tc-auto',   '#3b82f6');
            const cTotal  = cssVar('--tc-total',  '#a855f7');

            tcChart = new Chart(chartCanvas, {
              type: 'line',
              data: {
                labels: [],
                datasets: [
                  { label: '–†—É—á–Ω—ã–µ', data: [], borderColor: cManual, backgroundColor: cManual, tension: 0.25, pointRadius: 3, pointHoverRadius: 5 },
                  { label: '–ê–≤—Ç–æ',   data: [], borderColor: cAuto,   backgroundColor: cAuto,   tension: 0.25, pointRadius: 3, pointHoverRadius: 5 },
                  { label: '–í—Å–µ–≥–æ',  data: [], borderColor: cTotal,  backgroundColor: cTotal,  tension: 0.25, pointRadius: 3, pointHoverRadius: 5 }
                ]
              },
              options: {
                maintainAspectRatio: false,
                plugins: {
                  legend: { display: false },
                  deltaLabels: { datasetIndex: 2 },
                  tooltip: {
                    mode: 'index',
                    intersect: false,
                    itemSort: (a, b) => {
                      const av = Number(a?.raw ?? a?.parsed?.y ?? 0);
                      const bv = Number(b?.raw ?? b?.parsed?.y ?? 0);
                      return (bv - av) || ((a.datasetIndex ?? 0) - (b.datasetIndex ?? 0));
                    },
                    callbacks: {
                      title: (items) => {
                        const lbl = items?.[0]?.label;
                        return lbl ? `–†–µ–ª–∏–∑ ${lbl}` : '';
                      },
                      label: (ctx) => {
                        const i = ctx.dataIndex;
                        const total = Number(tcChart?.data?.datasets?.[2]?.data?.[i] || 0);
                        const val = Number(ctx.raw || 0);
                        let pct = 0;
                        if(ctx.datasetIndex === 2) pct = 100;
                        else if(total > 0) pct = Math.round((val / total) * 1000) / 10;
                        return `${ctx.dataset.label}: ${val} | ${pct}%`;
                      }
                    }
                  }
                },
                interaction: { mode: 'index', intersect: false },
                scales: {
                  x: { ticks: { maxRotation: 0, autoSkip: true }, grid: { color: 'rgba(148,163,184,.25)' } },
                  y: { beginAtZero: true, grace: '12%', grid: { color: 'rgba(148,163,184,.25)' } }
                }
              }
            });
          }

          function ensureCoverageChart(){
            if(!covCanvas || !window.Chart) return;
            if(covChart){
              covChart.data.labels = [];
              covChart.data.datasets.forEach(d => d.data = []);
              covChart._swatPeople = [];
              covChart.update();
              return;
            }

            const cSwat   = cssVar('--cov-swat', '#22c55e');
            const cStream = cssVar('--cov-stream', '#f43f5e');

            covChart = new Chart(covCanvas, {
              type: 'line',
              data: {
                labels: [],
                datasets: [
                  { label: 'SWAT',   data: [], borderColor: cSwat,   backgroundColor: cSwat,   tension: 0.25, pointRadius: 3, pointHoverRadius: 5 },
                  { label: 'STREAM', data: [], borderColor: cStream, backgroundColor: cStream, tension: 0.25, pointRadius: 3, pointHoverRadius: 5 }
                ]
              },
              options: {
                maintainAspectRatio: false,
                plugins: {
                  legend: { display: false },
                  deltaLabels: { datasetIndex: 0 },
                  tooltip: {
                    mode: 'index',
                    intersect: false,
                    itemSort: (a, b) => {
                      const av = Number(a?.raw ?? a?.parsed?.y ?? 0);
                      const bv = Number(b?.raw ?? b?.parsed?.y ?? 0);
                      return (bv - av) || ((a.datasetIndex ?? 0) - (b.datasetIndex ?? 0));
                    },
                    callbacks: {
                      title: (items) => {
                        const lbl = items?.[0]?.label;
                        return lbl ? `–†–µ–ª–∏–∑ ${lbl}` : '';
                      },
                      label: (ctx) => {
                        const i = ctx.dataIndex;
                        const sw = Number(covChart.data.datasets[0].data[i] || 0);
                        const st = Number(covChart.data.datasets[1].data[i] || 0);
                        const sum = Math.max(1, sw + st);
                        const val = Number(ctx.raw || 0);
                        const pct = Math.round((val / sum) * 1000) / 10;

                        if(String(ctx.dataset?.label || '') === 'SWAT'){
                          const ppl = Number(covChart._swatPeople?.[i] || 0);
                          const word = ruPlural(ppl, '—Å–æ—Ç—Ä—É–¥–Ω–∏–∫', '—Å–æ—Ç—Ä—É–¥–Ω–∏–∫–∞', '—Å–æ—Ç—Ä—É–¥–Ω–∏–∫–æ–≤');
                          return `${ctx.dataset.label}: ${val} | ${pct}% | ${ppl} ${word}`;
                        }
                        return `${ctx.dataset.label}: ${val} | ${pct}%`;
                      },
                      footer: (items) => {
                        const i = items?.[0]?.dataIndex;
                        const sw = Number(covChart.data.datasets[0].data[i] || 0);
                        const st = Number(covChart.data.datasets[1].data[i] || 0);
                        return `–í—Å–µ–≥–æ: ${sw + st}`;
                      }
                    }
                  }
                },
                interaction: { mode: 'index', intersect: false },
                scales: {
                  x: { bounds: 'data', ticks: { maxRotation: 0, autoSkip: true }, grid: { color: 'rgba(148,163,184,.25)' } },
                  y: { beginAtZero: true, grace: '12%', grid: { color: 'rgba(148,163,184,.25)' } }
                }
              }
            });
          }

          function ensureSelectiveChart(){
            if(!selCanvas || !window.Chart) return;
            if(selChart){
              selChart.data.labels = [];
              selChart.data.datasets.forEach(d => d.data = []);
              selChart._swatPeople = [];
              selChart.update();
              return;
            }

            const cSwat   = cssVar('--cov-swat', '#22c55e');
            const cStream = cssVar('--cov-stream', '#f43f5e');

            selChart = new Chart(selCanvas, {
              type: 'line',
              data: {
                labels: [],
                datasets: [
                  { label: 'SWAT',   data: [], borderColor: cSwat,   backgroundColor: cSwat,   tension: 0.25, pointRadius: 3, pointHoverRadius: 5 },
                  { label: 'STREAM', data: [], borderColor: cStream, backgroundColor: cStream, tension: 0.25, pointRadius: 3, pointHoverRadius: 5 }
                ]
              },
              options: {
                maintainAspectRatio: false,
                plugins: {
                  legend: { display: false },
                  deltaLabels: { datasetIndex: 0 },
                  tooltip: {
                    mode: 'index',
                    intersect: false,
                    itemSort: (a, b) => {
                      const av = Number(a?.raw ?? a?.parsed?.y ?? 0);
                      const bv = Number(b?.raw ?? b?.parsed?.y ?? 0);
                      return (bv - av) || ((a.datasetIndex ?? 0) - (b.datasetIndex ?? 0));
                    },
                    callbacks: {
                      title: (items) => {
                        const lbl = items?.[0]?.label;
                        return lbl ? `–†–µ–ª–∏–∑ ${lbl}` : '';
                      },
                      label: (ctx) => {
                        const i = ctx.dataIndex;
                        const sw = Number(selChart.data.datasets[0].data[i] || 0);
                        const st = Number(selChart.data.datasets[1].data[i] || 0);
                        const sum = Math.max(1, sw + st);
                        const val = Number(ctx.raw || 0);
                        const pct = Math.round((val / sum) * 1000) / 10;

                        if(String(ctx.dataset?.label || '') === 'SWAT'){
                          const ppl = Number(selChart._swatPeople?.[i] || 0);
                          const word = ruPlural(ppl, '—Å–æ—Ç—Ä—É–¥–Ω–∏–∫', '—Å–æ—Ç—Ä—É–¥–Ω–∏–∫–∞', '—Å–æ—Ç—Ä—É–¥–Ω–∏–∫–æ–≤');
                          return `${ctx.dataset.label}: ${val} | ${pct}% | ${ppl} ${word}`;
                        }
                        return `${ctx.dataset.label}: ${val} | ${pct}%`;
                      },
                      footer: (items) => {
                        const i = items?.[0]?.dataIndex;
                        const sw = Number(selChart.data.datasets[0].data[i] || 0);
                        const st = Number(selChart.data.datasets[1].data[i] || 0);
                        return `–í—Å–µ–≥–æ: ${sw + st}`;
                      }
                    }
                  }
                },
                interaction: { mode: 'index', intersect: false },
                scales: {
                  x: { bounds: 'data', ticks: { maxRotation: 0, autoSkip: true }, grid: { color: 'rgba(148,163,184,.25)' } },
                  y: { beginAtZero: true, grace: '12%', grid: { color: 'rgba(148,163,184,.25)' } }
                }
              }
            });
          }

          function ensureAvgChart(){
            if(!avgCanvas || !window.Chart) return;
            if(avgChart){
              avgChart.data.labels = [];
              avgChart.data.datasets.forEach(d => d.data = []);
              avgChart.update();
              return;
            }

            const cSwat   = cssVar('--cov-swat', '#22c55e');
            const cStream = cssVar('--cov-stream', '#f43f5e');
            const cTotal  = cssVar('--tc-total', '#a855f7');

            avgChart = new Chart(avgCanvas, {
              type: 'line',
              data: {
                labels: [],
                datasets: [
                  { label: 'SWAT',   data: [], borderColor: cSwat,   backgroundColor: cSwat,   tension: 0.25, pointRadius: 3, pointHoverRadius: 5 },
                  { label: 'STREAM', data: [], borderColor: cStream, backgroundColor: cStream, tension: 0.25, pointRadius: 3, pointHoverRadius: 5 },
                  { label: '–û–±—â–µ–µ',  data: [], borderColor: cTotal,  backgroundColor: cTotal,  tension: 0.25, pointRadius: 3, pointHoverRadius: 5 }
                ]
              },
              options: {
                maintainAspectRatio: false,
                plugins: {
                  legend: { display: false },
                  tooltip: {
                    mode: 'index',
                    intersect: false,
                    itemSort: (a, b) => {
                      const av = Number(a?.raw ?? a?.parsed?.y ?? 0);
                      const bv = Number(b?.raw ?? b?.parsed?.y ?? 0);
                      return (bv - av) || ((a.datasetIndex ?? 0) - (b.datasetIndex ?? 0));
                    },
                    callbacks: {
                      title: (items) => {
                        const lbl = items?.[0]?.label;
                        return lbl ? `–†–µ–ª–∏–∑ ${lbl}` : '';
                      },
                      label: (ctx) => {
                        const minutes = Number(ctx.raw || 0);
                        const ms = minutes * 60_000;
                        return `${ctx.dataset.label}: ${formatMsPerCase(ms)}`;
                      }
                    }
                  }
                },
                interaction: { mode: 'index', intersect: false },
                scales: {
                  x: { bounds: 'data', ticks: { maxRotation: 0, autoSkip: true }, grid: { color: 'rgba(148,163,184,.25)' } },
                  y: {
                    beginAtZero: true,
                    grid: { color: 'rgba(148,163,184,.25)' },
                    ticks: { callback: (v) => (Number(v) || 0).toFixed(1) }
                  }
                }
              }
            });
          }

          function ensureChpChart(){
            if(!chpCanvas || !window.Chart) return;
            if(chpChart){
              chpChart.data.labels = [];
              chpChart.data.datasets.forEach(d => d.data = []);
              chpChart.update();
              return;
            }
            const cIos = cssVar('--chp-ios', '#0ea5e9');
            const cAnd = cssVar('--chp-android', '#22c55e');
            const cTot = cssVar('--chp-total', '#a855f7');

            chpChart = new Chart(chpCanvas, {
              type: 'line',
              data: {
                labels: [],
                datasets: [
                  { label: 'iOS', data: [], borderColor: cIos, backgroundColor: cIos, tension: 0.25, pointRadius: 3, pointHoverRadius: 5 },
                  { label: 'Android', data: [], borderColor: cAnd, backgroundColor: cAnd, tension: 0.25, pointRadius: 3, pointHoverRadius: 5 },
                  { label: '–í—Å–µ–≥–æ', data: [], borderColor: cTot, backgroundColor: cTot, tension: 0.25, pointRadius: 3, pointHoverRadius: 5 }
                ]
              },
              options: {
                maintainAspectRatio: false,
                plugins: {
                  legend: { display: false },
                  deltaLabels: { datasetIndex: 2 },
                  tooltip: {
                    mode: 'index',
                    intersect: false,
                    itemSort: (a, b) => {
                      const av = Number(a?.raw ?? a?.parsed?.y ?? 0);
                      const bv = Number(b?.raw ?? b?.parsed?.y ?? 0);
                      return (bv - av) || ((a.datasetIndex ?? 0) - (b.datasetIndex ?? 0));
                    },
                    callbacks: {
                      title: (items) => {
                        const lbl = items?.[0]?.label;
                        return lbl ? `–†–µ–ª–∏–∑ ${lbl}` : '';
                      }
                    }
                  }
                },
                interaction: { mode: 'index', intersect: false },
                scales: {
                  x: { bounds: 'data', ticks: { maxRotation: 0, autoSkip: true }, grid: { color: 'rgba(148,163,184,.25)' } },
                  y: { beginAtZero: true, grace: '12%', grid: { color: 'rgba(148,163,184,.25)' } }
                }
              }
            });
          }

          function ensureCutChart(){
            if(!cutCanvas || !window.Chart) return;
            if(cutChart){
              cutChart.data.labels = [];
              cutChart.data.datasets.forEach(d => {
                d.data = [];
                d._timeLabel = [];
                d._timeMs = [];
                d._lastChpLabel = [];
              });
              cutChart.update();
              return;
            }

            const cIosCut  = cssVar('--cut-ios-cutoff', '#0ea5e9');
            const cIosSt   = cssVar('--cut-ios-store',  '#a855f7');
            const cAndCut  = cssVar('--cut-android-cutoff', '#22c55e');
            const cAndSt   = cssVar('--cut-android-store',  '#f59e0b');

            const dayTicks = ['–≤—Å','—Å–±','–ø—Ç','—á—Ç','—Å—Ä','–≤—Ç','–ø–Ω'];

            const makeDs = (label, color) => ({
              label,
              data: [],
              borderColor: color,
              backgroundColor: color,
              tension: 0.25,
              pointRadius: 3,
              pointHoverRadius: 5,
              spanGaps: true,
              _timeLabel: [],
              _timeMs: [],
              _lastChpLabel: []
            });

            cutChart = new Chart(cutCanvas, {
              type: 'line',
              data: {
                labels: [],
                datasets: [
                  makeDs('iOS Cutoff', cIosCut),
                  makeDs('Android Cutoff', cAndCut),
                  makeDs('iOS Store', cIosSt),
                  makeDs('Android Store', cAndSt),
                ]
              },
              options: {
                maintainAspectRatio: false,
                plugins: {
                  legend: { display: false },
                  tooltip: {
                    mode: 'index',
                    intersect: false,
                    // –°–ù–ê–ß–ê–õ–ê cutoff (—Ä–∞–Ω—å—à–µ ‚Äî –≤—ã—à–µ), –ü–û–¢–û–ú store (—Ä–∞–Ω—å—à–µ ‚Äî –≤—ã—à–µ)
                    itemSort: (a, b) => {
                      const la = String(a?.dataset?.label || '');
                      const lb = String(b?.dataset?.label || '');
                      const kindA = la.includes('Cutoff') ? 0 : 1;
                      const kindB = lb.includes('Cutoff') ? 0 : 1;
                      if(kindA !== kindB) return kindA - kindB;

                      const dsA = cutChart.data.datasets[a.datasetIndex];
                      const dsB = cutChart.data.datasets[b.datasetIndex];
                      const ta = Number(dsA?._timeMs?.[a.dataIndex]);
                      const tb = Number(dsB?._timeMs?.[b.dataIndex]);

                      const aInf = Number.isFinite(ta) ? ta : Number.POSITIVE_INFINITY;
                      const bInf = Number.isFinite(tb) ? tb : Number.POSITIVE_INFINITY;
                      const diff = aInf - bInf;
                      return diff || ((a.datasetIndex ?? 0) - (b.datasetIndex ?? 0));
                    },
                    callbacks: {
                      title: (items) => {
                        const lbl = items?.[0]?.label;
                        return lbl ? `–†–µ–ª–∏–∑ ${lbl}` : '';
                      },
                      label: (ctx) => {
                        const ds = cutChart.data.datasets[ctx.datasetIndex];
                        let txt = ds?._timeLabel?.[ctx.dataIndex] || '-';
                        const last = ds?._lastChpLabel?.[ctx.dataIndex] || '';
                        if(last && String(ctx.dataset?.label || '').includes('Store')){
                          txt += ` | –ü–æ—Å–ª–µ–¥–Ω–∏–π –ß–ü ${last}`;
                        }
                        return `${ctx.dataset.label}: ${txt}`;
                      }
                    }
                  }
                },
                interaction: { mode: 'index', intersect: false },
                scales: {
                  x: {
                    bounds: 'data',
                    ticks: { maxRotation: 0, autoSkip: true },
                    grid: { color: 'rgba(148,163,184,.25)' }
                  },
                  y: {
                    min: 0,
                    max: 6 * 1440 + 1439,
                    reverse: true,
                    grid: { color: 'rgba(148,163,184,.25)' },
                    ticks: {
                      stepSize: 1440,
                      callback: (v) => {
                        const idx = Math.round(Number(v) / 1440);
                        return dayTicks[idx] ?? '';
                      }
                    }
                  }
                }
              }
            });
          }

          function addChartPoint(release, manual, auto, total){
            if(!tcChart) return;
            tcChart.data.labels.push(release);
            tcChart.data.datasets[0].data.push(manual);
            tcChart.data.datasets[1].data.push(auto);
            tcChart.data.datasets[2].data.push(total);
            tcChart.update();
          }

          function addCoveragePoint(release, swatCount, streamCount, swatPeopleCount){
            if(!covChart) return;
            covChart.data.labels.push(release);
            covChart.data.datasets[0].data.push(swatCount);
            covChart.data.datasets[1].data.push(streamCount);
            if(!Array.isArray(covChart._swatPeople)) covChart._swatPeople = [];
            covChart._swatPeople.push(Number(swatPeopleCount) || 0);
            covChart.update();
          }

          function addSelectivePoint(release, swatCount, streamCount, swatPeopleCount){
            if(!selChart) return;
            selChart.data.labels.push(release);
            selChart.data.datasets[0].data.push(swatCount);
            selChart.data.datasets[1].data.push(streamCount);
            if(!Array.isArray(selChart._swatPeople)) selChart._swatPeople = [];
            selChart._swatPeople.push(Number(swatPeopleCount) || 0);
            selChart.update();
          }

          function addAvgPoint(release, swatMin, streamMin, totalMin){
            if(!avgChart) return;
            avgChart.data.labels.push(release);
            avgChart.data.datasets[0].data.push(swatMin);
            avgChart.data.datasets[1].data.push(streamMin);
            avgChart.data.datasets[2].data.push(totalMin);
            avgChart.update();
          }

          function addChpPoint(release, ios, android, total){
            if(!chpChart) return;
            chpChart.data.labels.push(release);
            chpChart.data.datasets[0].data.push(ios);
            chpChart.data.datasets[1].data.push(android);
            chpChart.data.datasets[2].data.push(total);
            chpChart.update();
          }

          function addCutPoint(release, dsIndex, yObjOrNull){
            if(!cutChart) return;
            if(cutChart.data.labels.length === 0 || cutChart.data.labels[cutChart.data.labels.length - 1] !== release){
              cutChart.data.labels.push(release);
              // –¥–ª—è –≤—Å–µ—Ö –¥–∞—Ç–∞—Å–µ—Ç–æ–≤ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ–º –¥–ª–∏–Ω—ã (–µ—Å–ª–∏ –Ω—É–∂–Ω–æ)
              for(const ds of cutChart.data.datasets){
                while(ds.data.length < cutChart.data.labels.length - 1){
                  ds.data.push(null);
                  ds._timeLabel.push('');
                  ds._timeMs.push(null);
                  ds._lastChpLabel.push('');
                }
              }
            }
            const di = cutChart.data.labels.length - 1;
            const ds = cutChart.data.datasets[dsIndex];

            // ensure arrays length
            while(ds.data.length < di){ ds.data.push(null); ds._timeLabel.push(''); ds._timeMs.push(null);
                  ds._lastChpLabel.push(''); }

            if(!yObjOrNull){
              ds.data.push(null);
              ds._timeLabel.push('');
              ds._timeMs.push(null);
                  ds._lastChpLabel.push('');
            }else{
              ds.data.push(yObjOrNull.y);
              ds._timeLabel.push(yObjOrNull.label);
              ds._timeMs.push(yObjOrNull.msLocal);
              ds._lastChpLabel.push(yObjOrNull.lastChp || '');
            }
          }

          // ---- —Ç–∞–±–ª–∏—Ü—ã (—Ä–µ–Ω–¥–µ—Ä) ----
          function renderRow({release, manual, auto, total}){
            const max = Math.max(total, 1);
            const pctM = Math.round((manual / max) * 100);
            const pctA = Math.round((auto / max) * 100);
            const pctT = 100;

            const tr = document.createElement('tr');
            tr.innerHTML = `
              <td class="mono text-left">${release}</td>
              <td class="mono">${manual}</td>
              <td class="mono">${auto}</td>
              <td class="mono">${total}</td>
              <td class="text-left">
                <div class="space-y-2 min-w-[260px]">
                  <div class="flex items-center gap-2">
                    <span class="text-xs text-slate-500 w-14">–†—É—á–Ω—ã–µ</span>
                    <div class="bar flex-1"><div class="bar-fill bar-fill-manual" style="width:${pctM}%"></div></div>
                    <span class="mono text-xs w-10 text-right">${manual}</span>
                  </div>
                  <div class="flex items-center gap-2">
                    <span class="text-xs text-slate-500 w-14">–ê–≤—Ç–æ</span>
                    <div class="bar flex-1"><div class="bar-fill bar-fill-auto" style="width:${pctA}%"></div></div>
                    <span class="mono text-xs w-10 text-right">${auto}</span>
                  </div>
                  <div class="flex items-center gap-2">
                    <span class="text-xs text-slate-500 w-14">–í—Å–µ–≥–æ</span>
                    <div class="bar flex-1"><div class="bar-fill bar-fill-total" style="width:${pctT}%"></div></div>
                    <span class="mono text-xs w-10 text-right">${total}</span>
                  </div>
                </div>
              </td>
            `;
            tbody.appendChild(tr);
          }

          function renderCovRow({release, swatCount, streamCount}){
            const sum = (Number(swatCount) || 0) + (Number(streamCount) || 0);
            const swPct = sum ? (Math.round(((Number(swatCount)||0) / sum) * 1000) / 10) : 0;
            const stPct = sum ? (Math.round(((Number(streamCount)||0) / sum) * 1000) / 10) : 0;
            const tr2 = document.createElement('tr');
            tr2.innerHTML = `
              <td class="mono text-left">${release}</td>
              <td class="mono">${swatCount}</td>
              <td class="mono">${streamCount}</td>
              <td class="mono">${sum}</td>
              <td class="text-left"><span class="mono">SWAT ${swPct}%</span> ¬∑ <span class="mono">STREAM ${stPct}%</span></td>
            `;
            covTbody.appendChild(tr2);
          }

          function renderSelRow({release, swatCount, streamCount}){
            const sum = (Number(swatCount) || 0) + (Number(streamCount) || 0);
            const swPct = sum ? (Math.round(((Number(swatCount)||0) / sum) * 1000) / 10) : 0;
            const stPct = sum ? (Math.round(((Number(streamCount)||0) / sum) * 1000) / 10) : 0;
            const tr2 = document.createElement('tr');
            tr2.innerHTML = `
              <td class="mono text-left">${release}</td>
              <td class="mono">${swatCount}</td>
              <td class="mono">${streamCount}</td>
              <td class="mono">${sum}</td>
              <td class="text-left"><span class="mono">SWAT ${swPct}%</span> ¬∑ <span class="mono">STREAM ${stPct}%</span></td>
            `;
            selTbody.appendChild(tr2);
          }

          function renderAvgRow({release, swatMs, streamMs, totalMs}){
            const tr = document.createElement('tr');
            tr.innerHTML = `
              <td class="mono text-left">${release}</td>
              <td class="mono">${formatMsPerCase(swatMs)}</td>
              <td class="mono">${formatMsPerCase(streamMs)}</td>
              <td class="mono">${formatMsPerCase(totalMs)}</td>
            `;
            avgTbody.appendChild(tr);
          }

          function renderCutRow({release, iosCut, iosStore, andCut, andStore}){
            const tr = document.createElement('tr');
            tr.innerHTML = `
              <td class="mono text-left">${release}</td>
              <td class="mono">${iosCut || '-'}</td>
              <td class="mono">${iosStore || ''}</td>
              <td class="mono">${andCut || '-'}</td>
              <td class="mono">${andStore || ''}</td>
            `;
            cutTbody.appendChild(tr);
          }

          // ---- concurrency ----
          async function asyncPool(items, concurrency, iterator, signal){
            const results = [];
            let i = 0;
            const workers = Array.from({length: Math.max(1, concurrency)}, async () => {
              while(i < items.length){
                if(signal?.aborted) return;
                const idx = i++;
                results[idx] = await iterator(items[idx], idx);
              }
            });
            await Promise.all(workers);
            return results;
          }

          // ---- collapsers ----
          function initCollapsers(){
            let state = {};
            try{ state = JSON.parse(localStorage.getItem(LS_COLLAPSE_KEY) || '{}') || {}; }catch(e){ state = {}; }

            function save(){
              try{ localStorage.setItem(LS_COLLAPSE_KEY, JSON.stringify(state)); }catch(e){}
            }

            function animateBody(body, collapse){
              const dur = 180;
              body.style.overflow = 'hidden';
              body.style.transition = `height ${dur}ms ease, opacity ${dur}ms ease`;

              if(collapse){
                body.style.display = '';
                const h = body.getBoundingClientRect().height;
                body.style.height = h + 'px';
                body.style.opacity = '1';
                requestAnimationFrame(() => {
                  body.style.height = '0px';
                  body.style.opacity = '0';
                });
                const onEnd = (ev) => {
                  if(ev.propertyName !== 'height') return;
                  body.removeEventListener('transitionend', onEnd);
                  body.style.display = 'none';
                  body.style.height = '';
                  body.style.opacity = '';
                  body.style.overflow = '';
                  body.style.transition = '';
                };
                body.addEventListener('transitionend', onEnd);
              }else{
                body.style.display = '';
                const h = body.scrollHeight;
                body.style.height = '0px';
                body.style.opacity = '0';
                requestAnimationFrame(() => {
                  body.style.height = h + 'px';
                  body.style.opacity = '1';
                });
                const onEnd = (ev) => {
                  if(ev.propertyName !== 'height') return;
                  body.removeEventListener('transitionend', onEnd);
                  body.style.height = '';
                  body.style.opacity = '';
                  body.style.overflow = '';
                  body.style.transition = '';
                };
                body.addEventListener('transitionend', onEnd);
              }
            }

            function resizeChartsForKey(key){
              try{
                if(key === 'tc') tcChart?.resize();
                if(key === 'cov') covChart?.resize();
                if(key === 'sel') selChart?.resize();
                if(key === 'avg') avgChart?.resize();
                if(key === 'chp') chpChart?.resize();
                if(key === 'cut') cutChart?.resize();
              }catch(e){}
            }

            const btns = document.querySelectorAll('[data-collapse-btn]');
            btns.forEach(btn => {
              const key = btn.getAttribute('data-collapse-btn');
              const section = btn.closest('section');
              if(!section) return;
              const body = section.querySelector(`[data-collapse-body="${key}"]`);
              if(!body) return;

              const ico = btn.querySelector('[data-collapse-ico]');
              const txt = btn.querySelector('[data-collapse-text]');

              let collapsed = !!state[key];

              const applyInstant = () => {
                body.style.display = collapsed ? 'none' : '';
                btn.setAttribute('aria-expanded', collapsed ? 'false' : 'true');
                if(ico) ico.textContent = collapsed ? '‚ñ∏' : '‚ñæ';
                if(txt) txt.textContent = collapsed ? '–†–∞–∑–≤–µ—Ä–Ω—É—Ç—å' : '–°–≤–µ—Ä–Ω—É—Ç—å';
              };

              applyInstant();

              btn.addEventListener('click', () => {
                collapsed = !collapsed;
                state[key] = collapsed;
                save();

                btn.setAttribute('aria-expanded', collapsed ? 'false' : 'true');
                if(ico) ico.textContent = collapsed ? '‚ñ∏' : '‚ñæ';
                if(txt) txt.textContent = collapsed ? '–†–∞–∑–≤–µ—Ä–Ω—É—Ç—å' : '–°–≤–µ—Ä–Ω—É—Ç—å';

                animateBody(body, collapsed);
                if(!collapsed){
                  requestAnimationFrame(() => requestAnimationFrame(() => resizeChartsForKey(key)));
                }
              });
            });
          }

          // ---- RUN ----
          async function run(){
            validateAndNormalizeReleaseInput(inpFrom);
            validateAndNormalizeReleaseInput(inpTo);
            saveInputs();
            clear();

            const tok = (inpAllureToken?.value || '').trim();
            if(!tok){
              showEmpty('–í—Å—Ç–∞–≤—å—Ç–µ API —Ç–æ–∫–µ–Ω Allure');
              return;
            }

            const releases = buildMajorRange();
            if(!releases.length){
              showEmpty('–£–∫–∞–∂–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –¥–∏–∞–ø–∞–∑–æ–Ω (–Ω–∞–ø—Ä–∏–º–µ—Ä 7.4.1000 ‚Üí 7.4.4000 –∏–ª–∏ 7.3.7 ‚Üí 7.4.2)');
              return;
            }

            ensureChart();
            ensureCoverageChart();
            ensureSelectiveChart();
            ensureAvgChart();
            ensureChpChart();
            ensureCutChart();

            showContent();
            showCovContent();
            showSelContent();
            showAvgContent();
            showChpContent();
            showCutContent();

            const signal = window.__wbAbortController?.signal;

            tbody.innerHTML = '<tr><td class="mono text-left" colspan="5">–°–±–æ—Ä –¥–∞–Ω–Ω—ã—Ö‚Ä¶</td></tr>';

            const LAUNCH_CONCURRENCY = 10;

            const tcRowsData = [];
            const covRowsData = [];
            const selRowsData = [];
            const avgRowsData = [];

            let firstRow = true;

            for(const rel of releases){
              if(signal?.aborted) break;

              let swatInfo;
              try{
                swatInfo = await fetchSwatLogins(rel, signal);
              }catch(e){
                showEmpty(`–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å–ø–∏—Å–∫–∞ SWAT –¥–ª—è —Ä–µ–ª–∏–∑–∞ ${rel}: ${e?.message || e}`);
                return;
              }
              const swatSet = swatInfo.set;
              const swatPeopleDeclared = Number(swatInfo.total || 0) || 0;

              let total = 0;
              let manual = 0;
              let auto  = 0;

              // 1) Manual/Auto/Total: –ø–æ Smoke+Selective
              const launchMapAll = new Map();
              for(const kind of KINDS){
                const launches = await fetchLaunches(rel, kind, signal);
                for(const l of launches){
                  const id = Number(l?.id);
                  if(Number.isFinite(id)) launchMapAll.set(id, id);
                }
              }
              const idsAll = Array.from(launchMapAll.keys());

              // AVG TIME: memberstats (counts+durations)
              let avgSwatCnt = 0, avgStreamCnt = 0;
              let avgSwatDur = 0, avgStreamDur = 0;

              const perAvg = await asyncPool(idsAll, LAUNCH_CONCURRENCY, async (id) => {
                const ms = await fetchMemberStats(id, signal);
                const agg = swatStreamAgg(ms, swatSet);

                if((agg.swatDur + agg.streamDur) <= 0){
                  const launchDur = await fetchLaunchDurationMs(id, signal);
                  const totalCnt = Math.max(1, (agg.swatTotal + agg.streamTotal));
                  const swShare = (agg.swatTotal || 0) / totalCnt;
                  const stShare = (agg.streamTotal || 0) / totalCnt;
                  agg.swatDur = launchDur * swShare;
                  agg.streamDur = launchDur * stShare;
                }
                return agg;
              }, signal);

              for(const r of perAvg){
                if(!r) continue;
                avgSwatCnt += Number(r.swatTotal || 0);
                avgStreamCnt += Number(r.streamTotal || 0);
                avgSwatDur += Number(r.swatDur || 0);
                avgStreamDur += Number(r.streamDur || 0);
              }

              const avgTotalCnt = avgSwatCnt + avgStreamCnt;
              const avgTotalDur = avgSwatDur + avgStreamDur;

              const swatMsPerCase = avgSwatCnt ? (avgSwatDur / avgSwatCnt) : 0;
              const streamMsPerCase = avgStreamCnt ? (avgStreamDur / avgStreamCnt) : 0;
              const totalMsPerCase = avgTotalCnt ? (avgTotalDur / avgTotalCnt) : 0;

              addAvgPoint(rel, swatMsPerCase/60000, streamMsPerCase/60000, totalMsPerCase/60000);
              if(avgTbody){
                renderAvgRow({ release: rel, swatMs: swatMsPerCase, streamMs: streamMsPerCase, totalMs: totalMsPerCase });
              }
              avgRowsData.push({ release: rel, swatMs: swatMsPerCase, streamMs: streamMsPerCase, totalMs: totalMsPerCase, total: totalMsPerCase });

              // 2) SWAT/STREAM –•–ë: —Ç–æ–ª—å–∫–æ HB –ª–∞—É–Ω—á–∏, memberstats
              let swatCount = 0;
              let streamCount = 0;

              const hbLaunches = await fetchHBLaunches(rel, signal);
              const idsHB = hbLaunches.map(l => Number(l?.id)).filter(id => Number.isFinite(id));

              const perHB = await asyncPool(idsHB, LAUNCH_CONCURRENCY, async (id) => {
                const ms = await fetchMemberStats(id, signal);
                const agg = swatStreamAgg(ms, swatSet);
                const ppl = extractSwatAssignees(ms, swatSet);
                return { agg, ppl: Array.from(ppl) };
              }, signal);

              const swatPeopleSetHB = new Set();
              for(const r of perHB){
                if(!r) continue;
                const agg = r.agg || r;
                swatCount += Number(agg.swatTotal || 0);
                streamCount += Number(agg.streamTotal || 0);
                if(Array.isArray(r.ppl)){
                  for(const a of r.ppl){
                    if(a) swatPeopleSetHB.add(String(a));
                  }
                }
              }
              const swatPeopleHB = swatPeopleDeclared;

              // 3) SWAT/STREAM Selective (—Ç–æ–ª—å–∫–æ Selective)
              const selLaunches = await fetchLaunches(rel, 'Selective', signal);
              const selIds = selLaunches.map(l => Number(l?.id)).filter(id => Number.isFinite(id));
              let selSwat = 0;
              let selStream = 0;

              const perSel = await asyncPool(selIds, LAUNCH_CONCURRENCY, async (id) => {
                const ms = await fetchMemberStats(id, signal);
                const agg = swatStreamAgg(ms, swatSet);
                const ppl = extractSwatAssignees(ms, swatSet);
                return { agg, ppl: Array.from(ppl) };
              }, signal);

              const swatPeopleSetSel = new Set();
              for(const r of perSel){
                if(!r) continue;
                const agg = r.agg || r;
                selSwat += Number(agg.swatTotal || 0);
                selStream += Number(agg.streamTotal || 0);
                if(Array.isArray(r.ppl)){
                  for(const a of r.ppl){
                    if(a) swatPeopleSetSel.add(String(a));
                  }
                }
              }
              const swatPeopleSel = swatPeopleDeclared;

              // 1) TOTAL/AUTO
              const perLaunchAll = await asyncPool(idsAll, LAUNCH_CONCURRENCY, async (id) => {
                const [t, a] = await Promise.all([
                  fetchTotalCases(id, signal),
                  fetchAutomatedTotalCases(id, signal)
                ]);
                return { t: Number(t||0), a: Number(a||0) };
              }, signal);

              for(const r of perLaunchAll){
                if(!r) continue;
                total += r.t;
                auto  += r.a;
              }
              manual = Math.max(0, total - auto);

              // –ß–µ—Ä–µ–ø–∏–∫–∏ (deploy-lab issues) ‚Äî —á–µ—Ä–µ–∑ –ø—Ä–æ–∫—Å–∏
              let chpIos = 0;
              let chpAndroid = 0;
              try{
                [chpIos, chpAndroid] = await Promise.all([
                  fetchDeployIssueCount('IOS', rel, signal),
                  fetchDeployIssueCount('ANDROID', rel, signal)
                ]);
              }catch(e){}
              const chpTotal = (Number(chpIos)||0) + (Number(chpAndroid)||0);
              if(chpTbody){
                const tr = document.createElement('tr');
                tr.innerHTML = `
                  <td class="mono text-left">${rel}</td>
                  <td class="mono">${chpIos}</td>
                  <td class="mono">${chpAndroid}</td>
                  <td class="mono">${chpTotal}</td>
                `;
                chpTbody.appendChild(tr);
              }
              addChpPoint(rel, chpIos, chpAndroid, chpTotal);

              // Cutoff/Store (deploy-lab base+deploy)
              let iosCutLbl = null, iosStoreLbl = null, andCutLbl = null, andStoreLbl = null;

              try{
                const [ios, andr, lastChpIos, lastChpAndr] = await Promise.all([
                  fetchDeployDates('IOS', rel, signal),
                  fetchDeployDates('ANDROID', rel, signal),
                  fetchLastCherepik('IOS', rel, signal),
                  fetchLastCherepik('ANDROID', rel, signal),
                ]);

                const iosCut = yValueFromIso(ios.cutoff);
                const andCut = yValueFromIso(andr.cutoff);

                const iosStore = yValueFromMsLocal(ios.storeMsLocal);
                if(iosStore) iosStore.lastChp = lastChpIos || '';

                const andStore = yValueFromMsLocal(andr.storeMsLocal);
                if(andStore) andStore.lastChp = lastChpAndr || '';

                addCutPoint(rel, 0, iosCut);
                addCutPoint(rel, 1, andCut);
                addCutPoint(rel, 2, iosStore);
                addCutPoint(rel, 3, andStore);

                iosCutLbl = iosCut?.label || null;
                andCutLbl = andCut?.label || null;
                iosStoreLbl = iosStore?.label || null;
                andStoreLbl = andStore?.label || null;
              }catch(e){
                addCutPoint(rel, 0, null);
                addCutPoint(rel, 1, null);
                addCutPoint(rel, 2, null);
                addCutPoint(rel, 3, null);
              }

              if(cutTbody){
                renderCutRow({ release: rel, iosCut: iosCutLbl, iosStore: iosStoreLbl, andCut: andCutLbl, andStore: andStoreLbl });
              }
              cutChart?.update();

              if(firstRow){
                tbody.innerHTML = '';
                firstRow = false;
              }

              renderRow({ release: rel, manual, auto, total });
              addChartPoint(rel, manual, auto, total);
              tcRowsData.push({ release: rel, manual, auto, total });

              if(covTbody){
                renderCovRow({ release: rel, swatCount, streamCount });
              }
              covRowsData.push({ release: rel, swatCount, streamCount, total: (swatCount + streamCount) });
              addCoveragePoint(rel, swatCount, streamCount, swatPeopleHB);

              if(selTbody){
                renderSelRow({ release: rel, swatCount: selSwat, streamCount: selStream });
              }
              selRowsData.push({ release: rel, swatCount: selSwat, streamCount: selStream, total: (selSwat + selStream) });
              addSelectivePoint(rel, selSwat, selStream, swatPeopleSel);
            }

            // —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ —Å–∫—Ä—ã—Ç—ã—Ö —Ç–∞–±–ª–∏—Ü (–µ—Å–ª–∏ –±—É–¥–µ—à—å –≤–∫–ª—é—á–∞—Ç—å)
            if(tbody && tcRowsData.length){
              tbody.innerHTML = '';
              tcRowsData.sort((a,b) => (Number(b.total)||0) - (Number(a.total)||0));
              tcRowsData.forEach(renderRow);
            }
            if(covTbody && covRowsData.length){
              covTbody.innerHTML = '';
              covRowsData.sort((a,b) => (Number(b.total)||0) - (Number(a.total)||0));
              covRowsData.forEach(r => renderCovRow({ release: r.release, swatCount: r.swatCount, streamCount: r.streamCount }));
            }
            if(selTbody && selRowsData.length){
              selTbody.innerHTML = '';
              selRowsData.sort((a,b) => (Number(b.total)||0) - (Number(a.total)||0));
              selRowsData.forEach(r => renderSelRow({ release: r.release, swatCount: r.swatCount, streamCount: r.streamCount }));
            }
            if(avgTbody && avgRowsData.length){
              avgTbody.innerHTML = '';
              avgRowsData.sort((a,b) => (Number(b.total)||0) - (Number(a.total)||0));
              avgRowsData.forEach(r => renderAvgRow({ release: r.release, swatMs: r.swatMs, streamMs: r.streamMs, totalMs: r.totalMs }));
            }

            if(!tcRowsData.length) showEmpty('–î–∞–Ω–Ω—ã–µ –ø–æ—è–≤—è—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–∑ –∏—Å—Ç–æ—á–Ω–∏–∫–∞');
            if(!selRowsData.length) showSelEmpty('–î–∞–Ω–Ω—ã–µ –ø–æ—è–≤—è—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–∑ –∏—Å—Ç–æ—á–Ω–∏–∫–∞');
          }

          // init
          restoreInputs();
          attachReleaseMask();
          validateAndNormalizeReleaseInput(inpFrom);
          validateAndNormalizeReleaseInput(inpTo);
          showEmpty('–î–∞–Ω–Ω—ã–µ –ø–æ—è–≤—è—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–∑ –∏—Å—Ç–æ—á–Ω–∏–∫–∞');
          showCovEmpty('–î–∞–Ω–Ω—ã–µ –ø–æ—è–≤—è—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–∑ –∏—Å—Ç–æ—á–Ω–∏–∫–∞');
          showSelEmpty('–î–∞–Ω–Ω—ã–µ –ø–æ—è–≤—è—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–∑ –∏—Å—Ç–æ—á–Ω–∏–∫–∞');
          showAvgEmpty('–î–∞–Ω–Ω—ã–µ –ø–æ—è–≤—è—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–∑ –∏—Å—Ç–æ—á–Ω–∏–∫–∞');
          showChpEmpty('–î–∞–Ω–Ω—ã–µ –ø–æ—è–≤—è—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–∑ –∏—Å—Ç–æ—á–Ω–∏–∫–∞');
          showCutEmpty('–î–∞–Ω–Ω—ã–µ –ø–æ—è–≤—è—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–∑ –∏—Å—Ç–æ—á–Ω–∏–∫–∞');
          initCollapsers();

          proxyBtn?.addEventListener('click', async () => {
            try{
              const r = await fetch(PROXY_BASE + '/health', { cache: 'no-store' });
              const j = await r.json();
              const ok = !!(j && j.ok === true && Number(j.port) === 8787);
              showToast(ok ? `–ü—Ä–æ–∫—Å–∏ OK (–ø–æ—Ä—Ç ${j.port})` : '–ü—Ä–æ–∫—Å–∏ –Ω–µ –æ—Ç–≤–µ—á–∞–µ—Ç', ok);
            }catch(e){
              showToast('–ü—Ä–æ–∫—Å–∏ –Ω–µ –æ—Ç–≤–µ—á–∞–µ—Ç', false);
            }
          });

          startBtn?.addEventListener('click', async () => {
            try{
              setRunning(true);
              await run();
            }catch(e){
              if(!(window.__wbAbortController?.signal?.aborted)){
                console.error(e);
                showEmpty(`–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö: ${e?.message || e}`);
              }
            }finally{
              if(!window.__wbAbortController?.signal?.aborted){
                setRunning(false);
              }
            }
          });

          stopBtn?.addEventListener('click', () => {
            setRunning(false);
          });
        })();
      </script>
    </main>
  </div>

  <div id="toast" class="pointer-events-none fixed bottom-6 left-1/2 -translate-x-1/2 opacity-0 transition-opacity duration-200">
    <div id="toastInner" class="px-4 py-2 rounded-2xl text-sm font-semibold bg-white/90 ring-1 ring-[#ecebff] text-slate-700 shadow"></div>
  </div>
</body>
</html>